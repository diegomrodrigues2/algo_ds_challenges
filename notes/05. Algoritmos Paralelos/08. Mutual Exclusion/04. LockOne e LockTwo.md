# ğŸ”’ LockOne e LockTwo

## ğŸ¯ Conceito Central

Dois algoritmos **inadequados mas interessantes** para 2 threads. Cada um funciona em cenÃ¡rios especÃ­ficos onde o outro falha, demonstrando trade-offs fundamentais em exclusÃ£o mÃºtua.

## ğŸ¨ Diagrama de Deadlock no LockOne

```mermaid
sequenceDiagram
    participant ğŸ‘¤ Thread A
    participant ğŸ‘¤ Thread B
    participant ğŸš© Flag A
    participant ğŸš© Flag B
    
    ğŸ‘¤ Thread A->>ğŸš© Flag A: flag[A] = true
    ğŸ‘¤ Thread B->>ğŸš© Flag B: flag[B] = true
    ğŸ‘¤ Thread A->>ğŸš© Flag B: while (flag[B]) {} // ğŸ”’ Presa
    ğŸ‘¤ Thread B->>ğŸš© Flag A: while (flag[A]) {} // ğŸ”’ Presa
    Note over ğŸ‘¤ Thread A, ğŸ‘¤ Thread B: ğŸ’€ Deadlock: Ambas presas
```

## ğŸ“Š LockOne Algorithm

### ğŸ”§ ImplementaÃ§Ã£o
```java
class LockOne {
    boolean[] flag = {false, false};
    
    void lock() {
        int i = ThreadID.get();
        int j = 1 - i;
        flag[i] = true;           // Indica interesse
        while (flag[j]) {}        // Aguarda outra desistir
    }
    
    void unlock() {
        int i = ThreadID.get();
        flag[i] = false;          // Desiste do lock
    }
}
```

### âœ… Propriedades
- **Mutual Exclusion**: âœ… Satisfaz
- **Deadlock-Freedom**: âŒ Pode deadlock
- **Starvation-Freedom**: âŒ NÃ£o garante

### âš ï¸ Problema: Deadlock
```
Thread A: flag[A] = true
Thread B: flag[B] = true
Thread A: while (flag[B]) {}  // ğŸ”’ Presa
Thread B: while (flag[A]) {}  // ğŸ”’ Presa
```

## ğŸ¨ Diagrama de Deadlock no LockTwo

```mermaid
sequenceDiagram
    participant ğŸ‘¤ Thread A
    participant ğŸ¯ Victim
    participant ğŸ”’ SeÃ§Ã£o CrÃ­tica
    
    Note over ğŸ‘¤ Thread A, ğŸ¯ Victim: CenÃ¡rio de deadlock sequencial
    
    ğŸ‘¤ Thread A->>ğŸ¯ Victim: victim = A
    Note right of ğŸ‘¤ Thread A: Loop: while (victim == A)
    Note over ğŸ‘¤ Thread A: ğŸ’€ Presa! A condiÃ§Ã£o nunca<br/>se torna falsa sem a<br/>intervenÃ§Ã£o de outra thread.
    
    Note over ğŸ‘¤ Thread A, ğŸ”’ SeÃ§Ã£o CrÃ­tica: A nunca consegue entrar<br/>na seÃ§Ã£o crÃ­tica.
```

## ğŸ“Š LockTwo Algorithm

### ğŸ”§ ImplementaÃ§Ã£o
```java
class LockTwo {
    int victim = 0;
    
    void lock() {
        int i = ThreadID.get();
        victim = i;               // Deixa outra ir primeiro
        while (victim == i) {}    // Aguarda nÃ£o ser vÃ­tima
    }
    
    void unlock() {
        // NÃ£o precisa fazer nada
    }
}
```

### âœ… Propriedades
- **Mutual Exclusion**: âœ… Satisfaz
- **Deadlock-Freedom**: âŒ Pode deadlock
- **Starvation-Freedom**: âŒ NÃ£o garante

### âš ï¸ Problema: Deadlock Sequencial
```
Thread A executa completamente: victim = A
Thread B tenta entrar: victim = B
Thread A tenta novamente: victim = A
Thread B aguarda: while (victim == B) {}  // ğŸ”’ Presa
```

## ğŸ“‹ ComparaÃ§Ã£o dos Algoritmos

| Aspecto | LockOne | LockTwo |
|---------|---------|---------|
| **Funciona quando** | ğŸ”„ Threads sequenciais | ğŸ”„ Threads concorrentes |
| **Falha quando** | ğŸ”„ Threads concorrentes | ğŸ”„ Threads sequenciais |
| **Complexidade** | ğŸŸ¢ Simples | ğŸŸ¢ Simples |
| **Overhead** | ğŸš€ Baixo | ğŸš€ Baixo |
| **Praticidade** | âŒ Limitada | âŒ Limitada |

## ğŸ”§ AnÃ¡lise TeÃ³rica

### LockOne: Prova de Mutual Exclusion
```
Se CS_A^j || CS_B^k (concorrentes):
write_A(flag[A]=true) â†’ read_A(flag[B]=false) â†’ CS_A
write_B(flag[B]=true) â†’ read_B(flag[A]=false) â†’ CS_B
read_A(flag[B]=false) â†’ write_B(flag[B]=true)

ContradiÃ§Ã£o: flag[B] nÃ£o pode ser false e true
```

### LockTwo: Prova de Mutual Exclusion
```
Se CS_A^j || CS_B^k (concorrentes):
write_A(victim=A) â†’ read_A(victim=B) â†’ CS_A
write_B(victim=B) â†’ read_B(victim=A) â†’ CS_B

ContradiÃ§Ã£o: victim nÃ£o pode ser A e B simultaneamente
```

## âš¡ Insights Fundamentais

- **Complementaridade**: Cada algoritmo funciona onde o outro falha
- **Trade-off**: Sequencial vs Concorrente
- **MotivaÃ§Ã£o**: Necessidade de combinar abordagens
- **PrÃ³ximo passo**: Algoritmo de Peterson combina ambos 