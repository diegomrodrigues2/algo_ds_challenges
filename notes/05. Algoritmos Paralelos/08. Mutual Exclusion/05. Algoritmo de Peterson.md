# ğŸ”’ Algoritmo de Peterson

## ğŸ¯ Conceito Central

**Algoritmo mais elegante** para 2 threads que combina LockOne e LockTwo. Ã‰ **starvation-free** e considerado o padrÃ£o ouro para exclusÃ£o mÃºtua entre 2 threads.

## ğŸ¨ Diagrama de Funcionamento do Peterson

```mermaid
sequenceDiagram
    participant ğŸ‘¤ Thread A
    participant ğŸ‘¤ Thread B
    participant ğŸš© Flag A
    participant ğŸš© Flag B
    participant ğŸ¯ Victim
    
    Note over ğŸ‘¤ Thread A, ğŸ¯ Victim: CenÃ¡rio: A e B chegam simultaneamente
    ğŸ‘¤ Thread A->>ğŸš© Flag A: flag[A] = true
    ğŸ‘¤ Thread B->>ğŸš© Flag B: flag[B] = true
    ğŸ‘¤ Thread A->>ğŸ¯ Victim: victim = A
    ğŸ‘¤ Thread B->>ğŸ¯ Victim: victim = B
    
    Note over ğŸ¯ Victim: B foi a Ãºltima a escrever, entÃ£o victim=B
    
    ğŸ‘¤ Thread A->>ğŸš© Flag B: while (flag[B] && victim == A) {}
    Note right of ğŸ‘¤ Thread A: CondiÃ§Ã£o Ã© (true && false) -> Falso
    Note over ğŸ‘¤ Thread A: âœ… Entra na SeÃ§Ã£o CrÃ­tica!
    
    ğŸ‘¤ Thread B->>ğŸš© Flag A: while (flag[A] && victim == B) {}
    Note right of ğŸ‘¤ Thread B: CondiÃ§Ã£o Ã© (true && true) -> Verdadeiro
    Note over ğŸ‘¤ Thread B: ğŸ”’ Presa, pois Ã© a vÃ­tima (victim == B)<br/>e a outra thread quer entrar (flag[A] == true)
```

## ğŸ”§ ImplementaÃ§Ã£o

```java
class PetersonLock {
    boolean[] flag = {false, false};
    int victim = 0;
    
    void lock() {
        int i = ThreadID.get();
        int j = 1 - i;
        
        flag[i] = true;                    // LockOne: indica interesse
        victim = i;                        // LockTwo: deixa outra ir primeiro
        
        while (flag[j] && victim == i) {}  // Combina ambas condiÃ§Ãµes
    }
    
    void unlock() {
        int i = ThreadID.get();
        flag[i] = false;                   // Desiste do lock
    }
}
```

## âœ… Propriedades

| Propriedade | Status | Garantia |
|-------------|--------|----------|
| **Mutual Exclusion** | âœ… | SeÃ§Ãµes crÃ­ticas nÃ£o se sobrepÃµem |
| **Deadlock-Freedom** | âœ… | Sistema nunca congela |
| **Starvation-Freedom** | âœ… | Toda thread eventualmente consegue |

## ğŸ”§ AnÃ¡lise da CondiÃ§Ã£o de Espera

### CondiÃ§Ã£o: `flag[j] && victim == i`

- **flag[j] = false**: Thread j desistiu â†’ posso entrar
- **victim != i**: NÃ£o sou mais a vÃ­tima â†’ posso entrar
- **Ambas true**: Thread j quer entrar E sou vÃ­tima â†’ aguardo

### Por que Funciona?

1. **Se A e B chegam simultaneamente**:
   - A define victim = A, B define victim = B
   - Ãšltimo a escrever "ganha" (victim final)
   - Perdedor aguarda atÃ© winner sair

2. **Se A chega antes de B**:
   - A define victim = A, entra na seÃ§Ã£o crÃ­tica
   - B define victim = B, aguarda A sair

## ğŸ¨ Diagrama de Prova de Mutual Exclusion

```mermaid
sequenceDiagram
    participant ğŸ‘¤ Thread A
    participant ğŸ‘¤ Thread B
    participant ğŸš© Flag A
    participant ğŸš© Flag B
    participant ğŸ¯ Victim
    
    Note over ğŸ‘¤ Thread A, ğŸ¯ Victim: âŒ SuposiÃ§Ã£o: CS_A || CS_B (concorrentes)
    ğŸ‘¤ Thread A->>ğŸš© Flag A: flag[A] = true
    ğŸ‘¤ Thread A->>ğŸ¯ Victim: victim = A
    ğŸ‘¤ Thread A->>ğŸš© Flag B: read flag[B] = false
    ğŸ‘¤ Thread A->>ğŸ¯ Victim: read victim = A
    ğŸ‘¤ Thread A->>ğŸ”’ CS_A: Entra seÃ§Ã£o crÃ­tica
    
    ğŸ‘¤ Thread B->>ğŸš© Flag B: flag[B] = true
    ğŸ‘¤ Thread B->>ğŸ¯ Victim: victim = B
    ğŸ‘¤ Thread B->>ğŸš© Flag A: read flag[A] = false
    ğŸ‘¤ Thread B->>ğŸ¯ Victim: read victim = B
    ğŸ‘¤ Thread B->>ğŸ”’ CS_B: Entra seÃ§Ã£o crÃ­tica
    
    Note over ğŸ‘¤ Thread A, ğŸ‘¤ Thread B: ğŸ”¥ ContradiÃ§Ã£o: flag[B] nÃ£o pode ser false e true
```

## ğŸ“Š Prova de Mutual Exclusion

### Suponha CS_A^j || CS_B^k (concorrentes)

```
write_A(flag[A]=true) â†’ write_A(victim=A) â†’ read_A(flag[B]) â†’ read_A(victim) â†’ CS_A
write_B(flag[B]=true) â†’ write_B(victim=B) â†’ read_B(flag[A]) â†’ read_B(victim) â†’ CS_B
```

### AnÃ¡lise da ContradiÃ§Ã£o

- Se A foi Ãºltimo a escrever victim: `write_B(victim=B) â†’ write_A(victim=A)`
- A leu victim = A, entÃ£o deve ter lido flag[B] = false
- Mas B escreveu flag[B] = true antes de escrever victim
- **ContradiÃ§Ã£o**: flag[B] nÃ£o pode ser false e true

## ğŸ“Š Prova de Starvation-Freedom

### Suponha A fica presa no lock()

- A aguarda: `flag[B] = false` OU `victim != A`
- Se B estÃ¡ na seÃ§Ã£o crÃ­tica: eventualmente define flag[B] = false
- Se B estÃ¡ no lock(): define victim = B, liberando A
- **ContradiÃ§Ã£o**: A nÃ£o pode ficar presa indefinidamente

## âš¡ Vantagens

- **Simplicidade**: Apenas 3 variÃ¡veis compartilhadas
- **EficiÃªncia**: 2 writes + 2 reads para lock()
- **CorreÃ§Ã£o**: Todas as propriedades desejadas
- **ElegÃ¢ncia**: Combina ideias de LockOne e LockTwo

## ğŸ”§ ImplementaÃ§Ã£o Python

```python
class PetersonLock:
    def __init__(self):
        self.flag = [False, False]
        self.victim = 0
        
    def lock(self):
        i = threading.current_thread().ident % 2
        j = 1 - i
        
        self.flag[i] = True
        self.victim = i
        
        while self.flag[j] and self.victim == i:
            pass
            
    def unlock(self):
        i = threading.current_thread().ident % 2
        self.flag[i] = False
```

## ğŸ“‹ ComparaÃ§Ã£o com Outros Algoritmos

| Aspecto | LockOne | LockTwo | Peterson |
|---------|---------|---------|----------|
| **Mutual Exclusion** | âœ… | âœ… | âœ… |
| **Deadlock-Freedom** | âŒ | âŒ | âœ… |
| **Starvation-Freedom** | âŒ | âŒ | âœ… |
| **Complexidade** | ğŸŸ¢ Simples | ğŸŸ¢ Simples | ğŸŸ¢ Simples |
| **Praticidade** | âŒ Limitada | âŒ Limitada | âœ… Completa | 