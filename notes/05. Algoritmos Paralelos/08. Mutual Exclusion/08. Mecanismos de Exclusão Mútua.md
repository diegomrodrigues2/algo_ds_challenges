# ğŸ”§ Mecanismos de ExclusÃ£o MÃºtua

## ğŸ¯ Conceito Central

**Mecanismos prÃ¡ticos** para implementar exclusÃ£o mÃºtua em linguagens de programaÃ§Ã£o reais. Incluem mutexes, semÃ¡foros e operaÃ§Ãµes atÃ´micas.

## ğŸ“Š 1. Mutexes (Bloqueios)

### ğŸ”§ ImplementaÃ§Ã£o C++ com RAII

```cpp
#include <mutex>
#include <memory>

class SafeCounter {
private:
    std::mutex mutex_;
    long value_ = 0;
    
public:
    long getAndIncrement() {
        std::lock_guard<std::mutex> lock(mutex_);  // ğŸ”’ RAII
        long temp = value_;
        value_ = temp + 1;
        return temp;
    }
};
```

### ğŸ¨ Diagrama de Mutex com RAII

```mermaid
sequenceDiagram
    participant ğŸ‘¤ Thread
    participant ğŸ”’ Mutex
    participant ğŸ“¦ Recurso
    participant ğŸ›¡ï¸ RAII
    
    ğŸ‘¤ Thread->>ğŸ›¡ï¸ RAII: lock_guard(mutex)
    ğŸ›¡ï¸ RAII->>ğŸ”’ Mutex: lock()
    ğŸ‘¤ Thread->>ğŸ“¦ Recurso: Acesso seguro
    ğŸ‘¤ Thread->>ğŸ›¡ï¸ RAII: ~lock_guard()
    ğŸ›¡ï¸ RAII->>ğŸ”’ Mutex: unlock()
    Note over ğŸ›¡ï¸ RAII: Garante liberaÃ§Ã£o mesmo com exceÃ§Ã£o
```

### ğŸ”§ ImplementaÃ§Ã£o Python (asyncio)

```python
import asyncio

class AsyncSafeCounter:
    def __init__(self):
        self._lock = asyncio.Lock()
        self._value = 0
    
    async def get_and_increment(self):
        async with self._lock:  # ğŸ”’ async with
            temp = self._value
            self._value = temp + 1
            return temp
```

### ğŸ¨ Diagrama de asyncio.Lock

```mermaid
sequenceDiagram
    participant ğŸ‘¤ Tarefa A
    participant ğŸ‘¤ Tarefa B
    participant ğŸ”’ asyncio.Lock
    participant ğŸ“¦ Recurso
    
    ğŸ‘¤ Tarefa A->>ğŸ”’ asyncio.Lock: await lock.acquire()
    ğŸ”’ asyncio.Lock->>ğŸ‘¤ Tarefa A: lock adquirido
    ğŸ‘¤ Tarefa A->>ğŸ“¦ Recurso: Acesso exclusivo
    ğŸ‘¤ Tarefa A->>ğŸ”’ asyncio.Lock: lock.release()
    
    ğŸ‘¤ Tarefa B->>ğŸ”’ asyncio.Lock: await lock.acquire()
    ğŸ”’ asyncio.Lock->>ğŸ‘¤ Tarefa B: lock adquirido
    ğŸ‘¤ Tarefa B->>ğŸ“¦ Recurso: Acesso exclusivo
    ğŸ‘¤ Tarefa B->>ğŸ”’ asyncio.Lock: lock.release()
```

## ğŸ“Š 2. SemÃ¡foros (SemÃ¡foros)

### ğŸ¯ Conceito
**GeneralizaÃ§Ã£o dos mutexes**: Permite que N threads acessem um recurso simultaneamente.

### ğŸ¨ Diagrama de SemÃ¡foro como Porteiro

```mermaid
stateDiagram-v2
    direction LR
    [*] --> Ocupado: release()
    Ocupado --> [*]: acquire()
    
    [*] --> AguardandoPermissao: acquire()
    AguardandoPermissao --> AcessandoRecurso: [contador > 0]
    AguardandoPermissao --> Bloqueada: [contador == 0]
    
    AcessandoRecurso --> AguardandoPermissao: release()
    Bloqueada --> AcessandoRecurso: Outra thread chama release()
    AcessandoRecurso --> Fim: Trabalho concluÃ­do
    Fim --> [*]
```

### ğŸ”§ ImplementaÃ§Ã£o Python

```python
import asyncio

class ConnectionPool:
    def __init__(self, max_connections=5):
        self._semaphore = asyncio.Semaphore(max_connections)
        self._connections = []
    
    async def get_connection(self):
        async with self._semaphore:  # ğŸš¦ Limita a 5 conexÃµes
            # Simula obtenÃ§Ã£o de conexÃ£o
            connection = await self._create_connection()
            return connection
```

## ğŸ“Š 3. OperaÃ§Ãµes AtÃ´micas

### ğŸ¯ Conceito
**OperaÃ§Ãµes indivisÃ­veis** garantidas pelo hardware. NÃ£o precisam de locks explÃ­citos.

### ğŸ¨ Diagrama de Compare-And-Swap (CAS)

```mermaid
sequenceDiagram
    participant ğŸ‘¤ Thread A
    participant ğŸ‘¤ Thread B
    participant ğŸ“¦ MemÃ³ria
    participant âš¡ CAS
    
    ğŸ‘¤ Thread A->>ğŸ“¦ MemÃ³ria: LÃª valor atual (0)
    ğŸ‘¤ Thread A->>âš¡ CAS: CAS(endereÃ§o, 0, 1)
    âš¡ CAS->>ğŸ“¦ MemÃ³ria: Verifica se ainda Ã© 0
    âš¡ CAS->>ğŸ“¦ MemÃ³ria: Atualiza para 1
    âš¡ CAS->>ğŸ‘¤ Thread A: true (sucesso)
    
    ğŸ‘¤ Thread B->>ğŸ“¦ MemÃ³ria: LÃª valor atual (1)
    ğŸ‘¤ Thread B->>âš¡ CAS: CAS(endereÃ§o, 1, 2)
    âš¡ CAS->>ğŸ“¦ MemÃ³ria: Verifica se ainda Ã© 1
    âš¡ CAS->>ğŸ“¦ MemÃ³ria: Atualiza para 2
    âš¡ CAS->>ğŸ‘¤ Thread B: true (sucesso)
```

### ğŸ”§ ImplementaÃ§Ã£o C++

```cpp
#include <atomic>

class AtomicCounter {
private:
    std::atomic<long> value_{0};
    
public:
    long getAndIncrement() {
        long expected = value_.load();
        while (!value_.compare_exchange_weak(expected, expected + 1)) {
            // ğŸ”„ Tenta novamente se valor mudou
        }
        return expected;
    }
};
```

## ğŸ“Š ComparaÃ§Ã£o dos Mecanismos

| Aspecto | ğŸ”’ Mutex | ğŸš¦ SemÃ¡foro | âš¡ OperaÃ§Ã£o AtÃ´mica |
|---------|----------|-------------|-------------------|
| **Acesso** | 1 thread | N threads | OperaÃ§Ã£o Ãºnica |
| **Overhead** | â° Alto | â° MÃ©dio | ğŸš€ Baixo |
| **Flexibilidade** | ğŸŸ¢ Alta | ğŸŸ¢ Alta | âŒ Limitada |
| **Complexidade** | ğŸŸ¡ MÃ©dia | ğŸŸ¡ MÃ©dia | ğŸŸ¢ Baixa |
| **AplicaÃ§Ã£o** | SeÃ§Ãµes crÃ­ticas | Pool de recursos | Contadores simples |

## ğŸ”§ PrevenÃ§Ã£o de Deadlock

### ğŸ¨ Diagrama de Hierarquia de Bocks

```mermaid
graph TD
    subgraph Ordem de AquisiÃ§Ã£o
        direction LR
        A(ğŸ”’ Lock A) --> B(ğŸ”’ Lock B)
        B --> C(ğŸ”’ Lock C)
        A --> C
    end

    subgraph CenÃ¡rio de Deadlock Evitado
        Th1(Thread 1: A â†’ B)
        Th2(Thread 2: B â†’ A)
        Th1 -- adquire A --> Th1_waits(Thread 1 espera por B)
        Th2 -- adquire B --> Th2_waits(Thread 2 espera por A)
        Th1_waits -.-> Th2(Causa espera)
        Th2_waits -.-> Th1(Causa espera)
    end
    
    linkStyle 4,5 stroke:red,stroke-width:2px,stroke-dasharray: 5 5;
```

### âš¡ Regra de Ouro
**Sempre adquira locks na mesma ordem predefinida**

```cpp
// âœ… Correto: Ordem consistente
std::lock_guard<std::mutex> lock1(mutex_a);
std::lock_guard<std::mutex> lock2(mutex_b);

// âŒ Incorreto: Ordem inconsistente
std::lock_guard<std::mutex> lock2(mutex_b);
std::lock_guard<std::mutex> lock1(mutex_a);
```

## ğŸ¯ AplicaÃ§Ãµes PrÃ¡ticas

- **Mutexes**: ProteÃ§Ã£o de dados compartilhados
- **SemÃ¡foros**: LimitaÃ§Ã£o de taxa, pool de conexÃµes
- **OperaÃ§Ãµes atÃ´micas**: Contadores, flags, referÃªncias
- **PrevenÃ§Ã£o de deadlock**: Hierarquia de locks, timeout 