# 🔧 Mecanismos de Exclusão Mútua

## 🎯 Conceito Central

**Mecanismos práticos** para implementar exclusão mútua em linguagens de programação reais. Incluem mutexes, semáforos e operações atômicas.

## 📊 1. Mutexes (Bloqueios)

### 🔧 Implementação C++ com RAII

```cpp
#include <mutex>
#include <memory>

class SafeCounter {
private:
    std::mutex mutex_;
    long value_ = 0;
    
public:
    long getAndIncrement() {
        std::lock_guard<std::mutex> lock(mutex_);  // 🔒 RAII
        long temp = value_;
        value_ = temp + 1;
        return temp;
    }
};
```

### 🎨 Diagrama de Mutex com RAII

```mermaid
sequenceDiagram
    participant 👤 Thread
    participant 🔒 Mutex
    participant 📦 Recurso
    participant 🛡️ RAII
    
    👤 Thread->>🛡️ RAII: lock_guard(mutex)
    🛡️ RAII->>🔒 Mutex: lock()
    👤 Thread->>📦 Recurso: Acesso seguro
    👤 Thread->>🛡️ RAII: ~lock_guard()
    🛡️ RAII->>🔒 Mutex: unlock()
    Note over 🛡️ RAII: Garante liberação mesmo com exceção
```

### 🔧 Implementação Python (asyncio)

```python
import asyncio

class AsyncSafeCounter:
    def __init__(self):
        self._lock = asyncio.Lock()
        self._value = 0
    
    async def get_and_increment(self):
        async with self._lock:  # 🔒 async with
            temp = self._value
            self._value = temp + 1
            return temp
```

### 🎨 Diagrama de asyncio.Lock

```mermaid
sequenceDiagram
    participant 👤 Tarefa A
    participant 👤 Tarefa B
    participant 🔒 asyncio.Lock
    participant 📦 Recurso
    
    👤 Tarefa A->>🔒 asyncio.Lock: await lock.acquire()
    🔒 asyncio.Lock->>👤 Tarefa A: lock adquirido
    👤 Tarefa A->>📦 Recurso: Acesso exclusivo
    👤 Tarefa A->>🔒 asyncio.Lock: lock.release()
    
    👤 Tarefa B->>🔒 asyncio.Lock: await lock.acquire()
    🔒 asyncio.Lock->>👤 Tarefa B: lock adquirido
    👤 Tarefa B->>📦 Recurso: Acesso exclusivo
    👤 Tarefa B->>🔒 asyncio.Lock: lock.release()
```

## 📊 2. Semáforos (Semáforos)

### 🎯 Conceito
**Generalização dos mutexes**: Permite que N threads acessem um recurso simultaneamente.

### 🎨 Diagrama de Semáforo como Porteiro

```mermaid
stateDiagram-v2
    direction LR
    [*] --> Ocupado: release()
    Ocupado --> [*]: acquire()
    
    [*] --> AguardandoPermissao: acquire()
    AguardandoPermissao --> AcessandoRecurso: [contador > 0]
    AguardandoPermissao --> Bloqueada: [contador == 0]
    
    AcessandoRecurso --> AguardandoPermissao: release()
    Bloqueada --> AcessandoRecurso: Outra thread chama release()
    AcessandoRecurso --> Fim: Trabalho concluído
    Fim --> [*]
```

### 🔧 Implementação Python

```python
import asyncio

class ConnectionPool:
    def __init__(self, max_connections=5):
        self._semaphore = asyncio.Semaphore(max_connections)
        self._connections = []
    
    async def get_connection(self):
        async with self._semaphore:  # 🚦 Limita a 5 conexões
            # Simula obtenção de conexão
            connection = await self._create_connection()
            return connection
```

## 📊 3. Operações Atômicas

### 🎯 Conceito
**Operações indivisíveis** garantidas pelo hardware. Não precisam de locks explícitos.

### 🎨 Diagrama de Compare-And-Swap (CAS)

```mermaid
sequenceDiagram
    participant 👤 Thread A
    participant 👤 Thread B
    participant 📦 Memória
    participant ⚡ CAS
    
    👤 Thread A->>📦 Memória: Lê valor atual (0)
    👤 Thread A->>⚡ CAS: CAS(endereço, 0, 1)
    ⚡ CAS->>📦 Memória: Verifica se ainda é 0
    ⚡ CAS->>📦 Memória: Atualiza para 1
    ⚡ CAS->>👤 Thread A: true (sucesso)
    
    👤 Thread B->>📦 Memória: Lê valor atual (1)
    👤 Thread B->>⚡ CAS: CAS(endereço, 1, 2)
    ⚡ CAS->>📦 Memória: Verifica se ainda é 1
    ⚡ CAS->>📦 Memória: Atualiza para 2
    ⚡ CAS->>👤 Thread B: true (sucesso)
```

### 🔧 Implementação C++

```cpp
#include <atomic>

class AtomicCounter {
private:
    std::atomic<long> value_{0};
    
public:
    long getAndIncrement() {
        long expected = value_.load();
        while (!value_.compare_exchange_weak(expected, expected + 1)) {
            // 🔄 Tenta novamente se valor mudou
        }
        return expected;
    }
};
```

## 📊 Comparação dos Mecanismos

| Aspecto | 🔒 Mutex | 🚦 Semáforo | ⚡ Operação Atômica |
|---------|----------|-------------|-------------------|
| **Acesso** | 1 thread | N threads | Operação única |
| **Overhead** | ⏰ Alto | ⏰ Médio | 🚀 Baixo |
| **Flexibilidade** | 🟢 Alta | 🟢 Alta | ❌ Limitada |
| **Complexidade** | 🟡 Média | 🟡 Média | 🟢 Baixa |
| **Aplicação** | Seções críticas | Pool de recursos | Contadores simples |

## 🔧 Prevenção de Deadlock

### 🎨 Diagrama de Hierarquia de Bocks

```mermaid
graph TD
    subgraph Ordem de Aquisição
        direction LR
        A(🔒 Lock A) --> B(🔒 Lock B)
        B --> C(🔒 Lock C)
        A --> C
    end

    subgraph Cenário de Deadlock Evitado
        Th1(Thread 1: A → B)
        Th2(Thread 2: B → A)
        Th1 -- adquire A --> Th1_waits(Thread 1 espera por B)
        Th2 -- adquire B --> Th2_waits(Thread 2 espera por A)
        Th1_waits -.-> Th2(Causa espera)
        Th2_waits -.-> Th1(Causa espera)
    end
    
    linkStyle 4,5 stroke:red,stroke-width:2px,stroke-dasharray: 5 5;
```

### ⚡ Regra de Ouro
**Sempre adquira locks na mesma ordem predefinida**

```cpp
// ✅ Correto: Ordem consistente
std::lock_guard<std::mutex> lock1(mutex_a);
std::lock_guard<std::mutex> lock2(mutex_b);

// ❌ Incorreto: Ordem inconsistente
std::lock_guard<std::mutex> lock2(mutex_b);
std::lock_guard<std::mutex> lock1(mutex_a);
```

## 🎯 Aplicações Práticas

- **Mutexes**: Proteção de dados compartilhados
- **Semáforos**: Limitação de taxa, pool de conexões
- **Operações atômicas**: Contadores, flags, referências
- **Prevenção de deadlock**: Hierarquia de locks, timeout 