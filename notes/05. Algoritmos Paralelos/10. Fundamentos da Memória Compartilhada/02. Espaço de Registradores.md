# 📊 Espaço de Registradores

## 🎯 Visão Geral

**Registradores** são objetos fundamentais que encapsulam valores observáveis por `read()` e modificáveis por `write()`. Diferem em **tamanho**, **número de leitores/escritores** e **propriedades de consistência**.

## 🔢 Classificações de Registradores

### 📋 Tipos por Capacidade
| Tipo | 🎯 Definição | 📝 Exemplo |
|------|--------------|------------|
| **Boolean** | Valores true/false | Flags de estado |
| **M-valued** | Valores 0 a M-1 | Contadores limitados |
| **Integer** | Valores inteiros | Contadores gerais |

### 👥 Tipos por Acesso
| Abreviação | 🎯 Significado | ⚡ Característica |
|------------|----------------|-------------------|
| **SRSW** | Single-Reader, Single-Writer | Um leitor, um escritor |
| **MRSW** | Multi-Reader, Single-Writer | Múltiplos leitores, um escritor |
| **MRMW** | Multi-Reader, Multi-Writer | Múltiplos leitores e escritores |

## 🛡️ Propriedades de Consistência

### 📊 Hierarquia de Consistência
```
Safe < Regular < Atomic
```

### 🔒 Safe Registers
- **Comportamento**: Leitura sem sobreposição retorna último valor escrito
- **Sobreposição**: Pode retornar qualquer valor no intervalo permitido
- **⚠️ Paradoxo**: "Safe" mas na verdade muito inseguro

### 🔄 Regular Registers
- **Comportamento**: Leitura pode "piscar" entre valores antigo e novo
- **Restrição**: Só retorna valores escritos por alguma operação `write()`
- **Propriedade**: Quiescently consistent

### ⚡ Atomic Registers
- **Comportamento**: Linearizável - equivalente a execução sequencial
- **Garantia**: Cada `read()` retorna "último" valor escrito
- **Padrão**: Modelo padrão de computação concorrente

## 📈 Condições Matemáticas

### 🔢 Condições para Regular Registers
```
(4.1.1) Nunca R^i → W^i (não lê do futuro)
(4.1.2) Nunca W^i → W^j → R^i (não lê do passado distante)
```

### ⚡ Condição Adicional para Atomic
```
(4.1.3) Se R^i → R^j então i ≤ j (ordem de leitura preservada)
```

## 🎨 Diagrama do Espaço de Registradores

```mermaid
graph TD
    subgraph "Dimensão 1: Tamanho"
        🔢[Boolean] --> 📊[M-valued] --> 🔢[Integer]
    end
    
    subgraph "Dimensão 2: Acesso"
        👤[SRSW] --> 👥[MRSW] --> 👥[MRMW]
    end
    
    subgraph "Dimensão 3: Consistência"
        ⚠️[Safe] --> 🔄[Regular] --> ⚡[Atomic]
    end
    
    🔢 -.-> 👤
    📊 -.-> 👥
    ⚡ -.-> 🔢
```

## 📊 Exemplo de Execução

### 🕐 Cenário de Teste
```
Tempo: R¹ → W(1) → R² → R³
```

### 📋 Comportamentos por Tipo
| Tipo | R¹ | R² | R³ | 📝 Justificativa |
|------|----|----|----|------------------|
| **Safe** | 0 | ? | ? | R², R³ sobrepõem W(1) |
| **Regular** | 0 | 0/1 | 0/1 | Pode piscar entre valores |
| **Atomic** | 0 | 0/1 | 0/1 | Se R²=1, então R³=1 |

## 🔧 Notação de Histórico

### 📝 Elementos Básicos
- **W^i**: i-ésima operação de escrita
- **R^i**: Leitura que retorna valor de W^i
- **→**: Relação de precedência
- **ν^i**: Valor único escrito por W^i

### 🎯 Ordem de Escrita
- **Safe/Regular**: Ordem trivial (um escritor)
- **Atomic**: Linearização order
- **Indexação**: W⁰, W¹, W², ...

## 🎯 Questão Fundamental

**Pergunta**: Qualquer estrutura de dados implementada com registradores mais poderosos pode ser implementada com os mais fracos?

**Resposta**: Sim! Construções mostram equivalência computacional entre todos os tipos de registradores.

## 🔍 Implicações Práticas

### ✅ Vantagens
- **Flexibilidade**: Algoritmos funcionam em qualquer arquitetura
- **Portabilidade**: Independência de primitivas de hardware
- **Teoria**: Base sólida para algoritmos concorrentes

### ⚠️ Limitações
- **Ineficiência**: Construções teóricas não otimizadas
- **Timestamps**: Crescimento ilimitado em implementações
- **Complexidade**: Overhead significativo em sistemas reais

## 🎯 Conclusão

O espaço de registradores define **hierarquia clara** de capacidades, desde primitivas básicas até construções complexas. A **equivalência computacional** garante que algoritmos funcionem independentemente das primitivas disponíveis, estabelecendo **fundamentos universais** para computação concorrente. 