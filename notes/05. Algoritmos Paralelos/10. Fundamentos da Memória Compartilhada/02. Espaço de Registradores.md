# ğŸ“Š EspaÃ§o de Registradores

## ğŸ¯ VisÃ£o Geral

**Registradores** sÃ£o objetos fundamentais que encapsulam valores observÃ¡veis por `read()` e modificÃ¡veis por `write()`. Diferem em **tamanho**, **nÃºmero de leitores/escritores** e **propriedades de consistÃªncia**.

## ğŸ”¢ ClassificaÃ§Ãµes de Registradores

### ğŸ“‹ Tipos por Capacidade
| Tipo | ğŸ¯ DefiniÃ§Ã£o | ğŸ“ Exemplo |
|------|--------------|------------|
| **Boolean** | Valores true/false | Flags de estado |
| **M-valued** | Valores 0 a M-1 | Contadores limitados |
| **Integer** | Valores inteiros | Contadores gerais |

### ğŸ‘¥ Tipos por Acesso
| AbreviaÃ§Ã£o | ğŸ¯ Significado | âš¡ CaracterÃ­stica |
|------------|----------------|-------------------|
| **SRSW** | Single-Reader, Single-Writer | Um leitor, um escritor |
| **MRSW** | Multi-Reader, Single-Writer | MÃºltiplos leitores, um escritor |
| **MRMW** | Multi-Reader, Multi-Writer | MÃºltiplos leitores e escritores |

## ğŸ›¡ï¸ Propriedades de ConsistÃªncia

### ğŸ“Š Hierarquia de ConsistÃªncia
```
Safe < Regular < Atomic
```

### ğŸ”’ Safe Registers
- **Comportamento**: Leitura sem sobreposiÃ§Ã£o retorna Ãºltimo valor escrito
- **SobreposiÃ§Ã£o**: Pode retornar qualquer valor no intervalo permitido
- **âš ï¸ Paradoxo**: "Safe" mas na verdade muito inseguro

### ğŸ”„ Regular Registers
- **Comportamento**: Leitura pode "piscar" entre valores antigo e novo
- **RestriÃ§Ã£o**: SÃ³ retorna valores escritos por alguma operaÃ§Ã£o `write()`
- **Propriedade**: Quiescently consistent

### âš¡ Atomic Registers
- **Comportamento**: LinearizÃ¡vel - equivalente a execuÃ§Ã£o sequencial
- **Garantia**: Cada `read()` retorna "Ãºltimo" valor escrito
- **PadrÃ£o**: Modelo padrÃ£o de computaÃ§Ã£o concorrente

## ğŸ“ˆ CondiÃ§Ãµes MatemÃ¡ticas

### ğŸ”¢ CondiÃ§Ãµes para Regular Registers
```
(4.1.1) Nunca R^i â†’ W^i (nÃ£o lÃª do futuro)
(4.1.2) Nunca W^i â†’ W^j â†’ R^i (nÃ£o lÃª do passado distante)
```

### âš¡ CondiÃ§Ã£o Adicional para Atomic
```
(4.1.3) Se R^i â†’ R^j entÃ£o i â‰¤ j (ordem de leitura preservada)
```

## ğŸ¨ Diagrama do EspaÃ§o de Registradores

```mermaid
graph TD
    subgraph "DimensÃ£o 1: Tamanho"
        ğŸ”¢[Boolean] --> ğŸ“Š[M-valued] --> ğŸ”¢[Integer]
    end
    
    subgraph "DimensÃ£o 2: Acesso"
        ğŸ‘¤[SRSW] --> ğŸ‘¥[MRSW] --> ğŸ‘¥[MRMW]
    end
    
    subgraph "DimensÃ£o 3: ConsistÃªncia"
        âš ï¸[Safe] --> ğŸ”„[Regular] --> âš¡[Atomic]
    end
    
    ğŸ”¢ -.-> ğŸ‘¤
    ğŸ“Š -.-> ğŸ‘¥
    âš¡ -.-> ğŸ”¢
```

## ğŸ“Š Exemplo de ExecuÃ§Ã£o

### ğŸ• CenÃ¡rio de Teste
```
Tempo: RÂ¹ â†’ W(1) â†’ RÂ² â†’ RÂ³
```

### ğŸ“‹ Comportamentos por Tipo
| Tipo | RÂ¹ | RÂ² | RÂ³ | ğŸ“ Justificativa |
|------|----|----|----|------------------|
| **Safe** | 0 | ? | ? | RÂ², RÂ³ sobrepÃµem W(1) |
| **Regular** | 0 | 0/1 | 0/1 | Pode piscar entre valores |
| **Atomic** | 0 | 0/1 | 0/1 | Se RÂ²=1, entÃ£o RÂ³=1 |

## ğŸ”§ NotaÃ§Ã£o de HistÃ³rico

### ğŸ“ Elementos BÃ¡sicos
- **W^i**: i-Ã©sima operaÃ§Ã£o de escrita
- **R^i**: Leitura que retorna valor de W^i
- **â†’**: RelaÃ§Ã£o de precedÃªncia
- **Î½^i**: Valor Ãºnico escrito por W^i

### ğŸ¯ Ordem de Escrita
- **Safe/Regular**: Ordem trivial (um escritor)
- **Atomic**: LinearizaÃ§Ã£o order
- **IndexaÃ§Ã£o**: Wâ°, WÂ¹, WÂ², ...

## ğŸ¯ QuestÃ£o Fundamental

**Pergunta**: Qualquer estrutura de dados implementada com registradores mais poderosos pode ser implementada com os mais fracos?

**Resposta**: Sim! ConstruÃ§Ãµes mostram equivalÃªncia computacional entre todos os tipos de registradores.

## ğŸ” ImplicaÃ§Ãµes PrÃ¡ticas

### âœ… Vantagens
- **Flexibilidade**: Algoritmos funcionam em qualquer arquitetura
- **Portabilidade**: IndependÃªncia de primitivas de hardware
- **Teoria**: Base sÃ³lida para algoritmos concorrentes

### âš ï¸ LimitaÃ§Ãµes
- **IneficiÃªncia**: ConstruÃ§Ãµes teÃ³ricas nÃ£o otimizadas
- **Timestamps**: Crescimento ilimitado em implementaÃ§Ãµes
- **Complexidade**: Overhead significativo em sistemas reais

## ğŸ¯ ConclusÃ£o

O espaÃ§o de registradores define **hierarquia clara** de capacidades, desde primitivas bÃ¡sicas atÃ© construÃ§Ãµes complexas. A **equivalÃªncia computacional** garante que algoritmos funcionem independentemente das primitivas disponÃ­veis, estabelecendo **fundamentos universais** para computaÃ§Ã£o concorrente. 