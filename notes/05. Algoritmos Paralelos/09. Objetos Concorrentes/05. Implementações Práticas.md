# ğŸ”§ ImplementaÃ§Ãµes PrÃ¡ticas

## ğŸ”’ Lock-Based FIFO Queue

### ğŸ“‹ ImplementaÃ§Ã£o
```java
public class LockBasedQueue<T> {
    private final T[] items;
    private int head, tail;
    private final Lock lock = new ReentrantLock();
    
    public void enq(T item) {
        lock.lock();
        try {
            if (tail - head == items.length) 
                throw new FullException();
            items[tail % items.length] = item;
            tail++;
        } finally {
            lock.unlock();
        }
    }
    
    public T deq() {
        lock.lock();
        try {
            if (head == tail) 
                throw new EmptyException();
            T item = items[head % items.length];
            head++;
            return item;
        } finally {
            lock.unlock();
        }
    }
}
```

### ğŸ¯ Linearization Points
- **enq()**: `lock.lock()` (inÃ­cio da critical section)
- **deq()**: `lock.lock()` (inÃ­cio da critical section)

## ğŸš€ Single-Enqueuer/Single-Dequeuer Queue

### ğŸ“‹ ImplementaÃ§Ã£o
```java
public class SingleQueue<T> {
    private final T[] items;
    private int head, tail;
    
    public void enq(T item) {
        items[tail % items.length] = item;
        tail++;
    }
    
    public T deq() {
        if (head == tail) 
            throw new EmptyException();
        T item = items[head % items.length];
        head++;
        return item;
    }
}
```

### ğŸ¯ Linearization Points
- **enq()**: AtribuiÃ§Ã£o `items[tail] = item`
- **deq()**: `throw EmptyException` OU atribuiÃ§Ã£o `head++`

## âš›ï¸ Atomic Counter

### ğŸ“‹ ImplementaÃ§Ã£o
```java
public class AtomicCounter {
    private final AtomicInteger count = new AtomicInteger(0);
    
    public int getAndIncrement() {
        while (true) {
            int current = count.get();
            if (count.compareAndSet(current, current + 1))
                return current;
        }
    }
    
    public int get() {
        return count.get();
    }
}
```

### ğŸ¯ Linearization Points
- **get()**: `count.get()`
- **getAndIncrement()**: `count.compareAndSet()` bem-sucedido

## ğŸ“Š ComparaÃ§Ã£o de ImplementaÃ§Ãµes

| ImplementaÃ§Ã£o | ğŸ¯ LinearizaÃ§Ã£o | âš¡ Performance | ğŸ”’ Bloqueio |
|---------------|-----------------|---------------|-------------|
| **Lock-Based** | âœ… Simples | ğŸŒ Lenta | ğŸ”’ Bloqueante |
| **Single Queue** | âš¡ DinÃ¢mica | ğŸš€ RÃ¡pida | ğŸš« Wait-free |
| **Atomic Counter** | âš›ï¸ AtÃ´mica | ğŸ“Š MÃ©dia | ğŸš« Lock-free |

## ğŸ¨ Diagrama: Linearization Points

```mermaid
timeline
    title Linearization Points
    A enq(x) : A enqueia x
    B enq(y) : B enqueia y
    C deq() : C dequeia
    Note : Pontos de linearizaÃ§Ã£o
    Note : Lock-based: inÃ­cio do lock
    Note : Single: atribuiÃ§Ã£o/throw
    Note : Atomic: CAS bem-sucedido
```

## ğŸ”§ PadrÃµes de ImplementaÃ§Ã£o

### ğŸ¯ Lock-Based
- **Vantagem**: Simples de implementar
- **Desvantagem**: Bloqueante
- **Uso**: OperaÃ§Ãµes complexas, baixa concorrÃªncia

### ğŸš€ Non-Blocking
- **Vantagem**: Alta performance
- **Desvantagem**: Complexo de implementar
- **Uso**: OperaÃ§Ãµes simples, alta concorrÃªncia

### âš›ï¸ Atomic
- **Vantagem**: Balanceado
- **Desvantagem**: Limitado a operaÃ§Ãµes simples
- **Uso**: Contadores, flags, referÃªncias

## ğŸ¯ Escolha da ImplementaÃ§Ã£o

### ğŸ“‹ CritÃ©rios
| CritÃ©rio | ğŸ”’ Lock-Based | ğŸš€ Non-Blocking | âš›ï¸ Atomic |
|----------|---------------|-----------------|-----------|
| **Simplicidade** | âœ… Alta | âŒ Baixa | ğŸ“Š MÃ©dia |
| **Performance** | ğŸŒ Baixa | ğŸš€ Alta | ğŸ“Š MÃ©dia |
| **ConcorrÃªncia** | ğŸ”’ Limitada | âš¡ Alta | ğŸ“Š MÃ©dia |
| **Flexibilidade** | âœ… Alta | âŒ Baixa | âš ï¸ Limitada |

### ğŸ¯ RecomendaÃ§Ãµes
- **Prototipagem**: Lock-based
- **ProduÃ§Ã£o crÃ­tica**: Non-blocking
- **OperaÃ§Ãµes simples**: Atomic
- **Sistemas legados**: Lock-based 