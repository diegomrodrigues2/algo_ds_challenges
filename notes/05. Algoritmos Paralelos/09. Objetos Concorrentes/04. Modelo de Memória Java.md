# â˜• Modelo de MemÃ³ria Java

## ğŸ” Por que nÃ£o Linearizabilidade?

### âš ï¸ Problema
- **Compiladores reordenam** reads/writes para otimizaÃ§Ã£o
- **Exemplo**: Register allocation, common subexpression elimination
- **ConsequÃªncia**: Sequential consistency violada

### ğŸ¯ SoluÃ§Ã£o
- **Relaxed memory model** com regras especÃ­ficas
- **Fundamental Property**: Se programa SC segue regras, execuÃ§Ã£o Ã© SC
- **Trade-off**: Performance vs correÃ§Ã£o

## ğŸ”’ Locks e Synchronized Blocks

### ğŸ“‹ Comportamento
- **Acquire lock**: Invalida working memory
- **Release lock**: Escreve mudanÃ§as para shared memory
- **Resultado**: Reads/writes protegidos sÃ£o linearizÃ¡veis

### ğŸ¨ Diagrama: SincronizaÃ§Ã£o
```mermaid
sequenceDiagram
    participant T as ğŸ‘¤ Thread
    participant L as ğŸ”’ Lock
    participant M as ğŸ’¾ Memory
    
    T->>L: acquire() ğŸ”“
    Note over T: Invalida cache
    T->>M: read/write ğŸ“
    T->>L: release() ğŸ”’
    Note over M: Propaga mudanÃ§as
```

## âš¡ Volatile Fields

### ğŸ“‹ Propriedades
- **Read**: Como acquire lock (invalida cache)
- **Write**: Como release lock (propaga imediatamente)
- **LimitaÃ§Ã£o**: NÃ£o sÃ£o atÃ´micos para operaÃ§Ãµes compostas

### âš ï¸ Exemplo ProblemÃ¡tico
```java
volatile int x;
x++; // NÃ£o Ã© atÃ´mico!
// Equivale a: temp = x; temp++; x = temp;
```

### âœ… Uso Correto
```java
volatile boolean flag; // Um thread escreve, outros leem
volatile AtomicInteger counter; // OperaÃ§Ãµes atÃ´micas
```

## ğŸ›¡ï¸ Final Fields

### ğŸ“‹ Regras
- **InicializaÃ§Ã£o**: No construtor
- **Visibilidade**: Sem sincronizaÃ§Ã£o (se regras seguidas)
- **RestriÃ§Ã£o**: `this` nÃ£o pode escapar do construtor

### âœ… Exemplo Correto
```java
public class SafeObject {
    final int x = 42; // Sempre visÃ­vel como 42
    int y = 100;      // Pode nÃ£o ser visÃ­vel
}
```

### âŒ Exemplo Incorreto
```java
public class UnsafeObject {
    final int x;
    
    public UnsafeObject(EventSource source) {
        source.register(this); // this escapa!
        this.x = 42;          // x pode nÃ£o ser 42
    }
}
```

## ğŸ“Š Atomic Classes

### ğŸ“‹ java.util.concurrent.atomic
- **AtomicReference<T>**: ReferÃªncia atÃ´mica
- **AtomicInteger**: Inteiro atÃ´mico
- **MÃ©todos**: `get()`, `set()`, `compareAndSet()`

### ğŸ¨ Diagrama: OperaÃ§Ãµes AtÃ´micas
```mermaid
sequenceDiagram
    participant T as ğŸ‘¤ Thread
    participant A as âš›ï¸ AtomicInteger
    
    T->>A: get() ğŸ‘€
    A-->>T: valor atual
    T->>A: compareAndSet(esperado, novo) ğŸ”„
    A-->>T: true/false
```

## ğŸ”§ Regras para Sequential Consistency

### ğŸ“‹ CondiÃ§Ãµes
1. **Todos os reads/writes** sÃ£o volatile, OU
2. **Todos os reads/writes** protegidos pelo mesmo lock

### ğŸ¯ Exemplo PrÃ¡tico
```java
class ThreadSafeCounter {
    private volatile int count = 0;
    
    public void increment() {
        count++; // NÃ£o Ã© atÃ´mico!
    }
    
    public synchronized void safeIncrement() {
        count++; // AtÃ´mico e SC
    }
}
```

## ğŸ“Š ComparaÃ§Ã£o de SincronizaÃ§Ã£o

| MÃ©todo | ğŸ¯ Atomicidade | âš¡ Performance | ğŸ§  Simplicidade |
|--------|----------------|---------------|-----------------|
| **Synchronized** | âœ… Completa | ğŸŒ Lenta | âœ… Simples |
| **Volatile** | âŒ Parcial | ğŸ“Š MÃ©dia | âš ï¸ Cuidado |
| **Atomic** | âœ… Completa | ğŸ“Š MÃ©dia | âœ… Simples |
| **Final** | âœ… ImutÃ¡vel | ğŸš€ RÃ¡pida | âœ… Simples |

## ğŸ¯ Boas PrÃ¡ticas

### âœ… RecomendaÃ§Ãµes
- **Imutabilidade**: Use final fields quando possÃ­vel
- **Atomic classes**: Para contadores e flags
- **Synchronized**: Para operaÃ§Ãµes complexas
- **Volatile**: Apenas para flags simples

### âŒ Evitar
- **Double-checked locking**: Sempre incorreto
- **Volatile para operaÃ§Ãµes compostas**: Use atomic
- **Escape de this no construtor**: Quebra final fields 