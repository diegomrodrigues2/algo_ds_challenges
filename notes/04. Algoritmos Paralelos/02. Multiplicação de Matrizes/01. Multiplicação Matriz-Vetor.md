# ğŸ”¢ MultiplicaÃ§Ã£o Matriz-Vetor Paralela

## ğŸ¯ Problema
Calcular **y = Ax** onde A Ã© uma matriz nÃ—n e x Ã© um vetor n-dimensional, usando paralelismo para acelerar o cÃ¡lculo.

## ğŸ”§ Algoritmo BÃ¡sico

### ğŸ“ P-MAT-VEC
```python
def P-MAT-VEC(A, x, y, n):
    parallel for i = 1 to n:           # Paraleliza linhas
        for j = 1 to n:                # Loop interno serial
            y[i] = y[i] + A[i][j] * x[j]
```

### ğŸ¯ EstratÃ©gia
- **Loop externo paralelo**: Cada linha calculada independentemente
- **Loop interno serial**: Produto interno de cada linha
- **Sem races**: Cada y[i] modificado por apenas uma thread

## ğŸ“Š AnÃ¡lise de Performance

### ğŸ” Work Analysis
- **Serial projection**: Î˜(nÂ²) - mesmo que algoritmo serial
- **Work**: Tâ‚(n) = Î˜(nÂ²)
- **Overhead**: Recursive spawning nÃ£o afeta assintoticamente

### â±ï¸ Span Analysis
- **Loop control**: Î˜(log n) para parallel for
- **Inner loop**: Î˜(n) para cada iteraÃ§Ã£o
- **Total span**: Tâ‚(n) = Î˜(log n) + Î˜(n) = Î˜(n)

### ğŸš€ Parallelism
```
Parallelism = Tâ‚(n)/Tâ‚(n) = Î˜(nÂ²)/Î˜(n) = Î˜(n)
```

## ğŸ”„ ImplementaÃ§Ã£o com Recursive Spawning

### ğŸ“ P-MAT-VEC-RECURSIVE
```python
def P-MAT-VEC-RECURSIVE(A, x, y, n, i, iâ‚€):
    if i == iâ‚€:                        # Base case: uma iteraÃ§Ã£o
        for j = 1 to n:
            y[i] = y[i] + A[i][j] * x[j]
    else:
        mid = (i + iâ‚€) // 2            # Divide ao meio
        spawn P-MAT-VEC-RECURSIVE(A, x, y, n, i, mid)
        P-MAT-VEC-RECURSIVE(A, x, y, n, mid + 1, iâ‚€)
        sync
```

### ğŸŒ³ Ãrvore de ExecuÃ§Ã£o
- **Binary tree**: Cada nÃ³ divide o trabalho ao meio
- **Leaves**: Executam o loop serial
- **Internal nodes**: Apenas divisÃ£o e sincronizaÃ§Ã£o

## âš ï¸ VersÃ£o Incorreta

### âŒ P-MAT-VEC-WRONG
```python
def P-MAT-VEC-WRONG(A, x, y, n):
    parallel for i = 1 to n:
        parallel for j = 1 to n:       # âŒ RACE CONDITION!
            y[i] = y[i] + A[i][j] * x[j]
```

### ğŸ Problema
- **Race condition**: MÃºltiplas threads escrevem em y[i]
- **NÃ£o-determinÃ­stico**: Resultado pode variar entre execuÃ§Ãµes
- **Incorreto**: Mesmo que span seja Î˜(log n)

## ğŸ¯ OtimizaÃ§Ãµes

### ğŸ“ˆ Coarsening
```python
def P-MAT-VEC-COARSE(A, x, y, n, grain_size):
    parallel for i = 1 to n:
        for j = 1 to n:
            y[i] = y[i] + A[i][j] * x[j]
        # Processa mÃºltiplas linhas por thread
```

### âš–ï¸ Trade-offs
| Aspecto | Granularidade Fina | Granularidade Grossa |
|---------|-------------------|---------------------|
| **Parallelism** | ğŸš€ Alta | ğŸ“‰ Reduzida |
| **Overhead** | ğŸ“ˆ Alto | ğŸ“‰ Baixo |
| **Load Balance** | âš–ï¸ Melhor | âš–ï¸ Pior |

## ğŸ” Casos de Uso

### ğŸ“Š Matrizes Esparsas
- **Estrutura especial**: Aproveitar padrÃµes de zeros
- **Compressed formats**: CSR, CSC para eficiÃªncia
- **Parallelism**: Ainda Î˜(n) mas com menos work

### ğŸ¯ Matrizes de Blocos
- **Block-wise**: Dividir em submatrizes
- **Cache-friendly**: Melhor localidade de dados
- **Hierarchical**: Paralelismo em mÃºltiplos nÃ­veis

## ğŸ“ˆ ComparaÃ§Ã£o de Performance

| Algoritmo | Work | Span | Parallelism |
|-----------|------|------|-------------|
| **Serial** | Î˜(nÂ²) | Î˜(nÂ²) | 1 |
| **P-MAT-VEC** | Î˜(nÂ²) | Î˜(n) | Î˜(n) |
| **P-MAT-VEC-WRONG** | Î˜(nÂ²) | Î˜(log n) | Î˜(nÂ²/log n) |

## ğŸ¯ LiÃ§Ãµes Aprendidas

### âœ… Boas PrÃ¡ticas
- **Identificar independÃªncia**: Linhas podem ser paralelas
- **Evitar races**: Cada saÃ­da modificada por uma thread
- **Balancear granularidade**: Overhead vs. parallelism

### âŒ Armadilhas
- **Paralelizar loops aninhados**: Pode criar races
- **Ignorar dependÃªncias**: Resultado incorreto
- **Over-parallelization**: Overhead domina benefÃ­cio 