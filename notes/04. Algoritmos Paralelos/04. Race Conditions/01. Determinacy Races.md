# ğŸ Race Conditions e Determinismo

## ğŸ¯ Conceito Central
**Determinacy races** ocorrem quando duas instruÃ§Ãµes paralelas acessam a mesma localizaÃ§Ã£o de memÃ³ria e pelo menos uma modifica o valor, causando comportamento nÃ£o-determinÃ­stico.

## ğŸ” Tipos de Races

### ğŸ Determinacy Race
```python
# âŒ INCORRETO - Race condition
x = 0
parallel for i = 1 to 2:
    x = x + 1  # MÃºltiplas threads escrevem em x
print(x)  # Pode imprimir 1 ou 2!
```

### ğŸ¯ Race vs. NÃ£o-Race
| SituaÃ§Ã£o | Tipo | Comportamento |
|----------|------|---------------|
| **Duas leituras** | âœ… NÃ£o-race | DeterminÃ­stico |
| **Uma leitura, uma escrita** | âŒ Race | NÃ£o-determinÃ­stico |
| **Duas escritas** | âŒ Race | NÃ£o-determinÃ­stico |

## ğŸ”§ Exemplo Detalhado

### ğŸ“ RACE-EXAMPLE
```python
def RACE-EXAMPLE():
    x = 0
    parallel for i = 1 to 2:
        x = x + 1
    print(x)
```

### ğŸ§  ExecuÃ§Ã£o Interna
Cada `x = x + 1` Ã© composto de:
1. **Load**: `r = x` (carrega valor da memÃ³ria)
2. **Increment**: `r = r + 1` (incrementa no registrador)
3. **Store**: `x = r` (armazena de volta na memÃ³ria)

### â±ï¸ SequÃªncia de ExecuÃ§Ã£o
```
Thread 1: râ‚ = x (râ‚ = 0)
Thread 2: râ‚‚ = x (râ‚‚ = 0)
Thread 1: râ‚ = râ‚ + 1 (râ‚ = 1)
Thread 2: râ‚‚ = râ‚‚ + 1 (râ‚‚ = 1)
Thread 1: x = râ‚ (x = 1)
Thread 2: x = râ‚‚ (x = 1)  # âŒ Sobrescreve!
```

## âš ï¸ Exemplo Real: P-MAT-VEC-WRONG

### âŒ VersÃ£o Incorreta
```python
def P-MAT-VEC-WRONG(A, x, y, n):
    parallel for i = 1 to n:
        parallel for j = 1 to n:       # âŒ RACE!
            y[i] = y[i] + A[i][j] * x[j]
```

### ğŸ Problema
- **MÃºltiplas threads**: Todas escrevem em `y[i]`
- **NÃ£o-determinÃ­stico**: Resultado varia entre execuÃ§Ãµes
- **Incorreto**: Mesmo que span seja Î˜(log n)

### âœ… VersÃ£o Correta
```python
def P-MAT-VEC(A, x, y, n):
    parallel for i = 1 to n:           # âœ… Cada thread tem seu i
        for j = 1 to n:
            y[i] = y[i] + A[i][j] * x[j]
```

## ğŸ¯ DetecÃ§Ã£o de Races

### ğŸ” Regras BÃ¡sicas
1. **Mutualmente nÃ£o-interferentes**: Strands paralelos nÃ£o compartilham escrita
2. **Apenas leitura**: Dados compartilhados sÃ³ para leitura
3. **IndependÃªncia**: Cada saÃ­da modificada por uma thread

### ğŸ“Š AnÃ¡lise de DependÃªncias
```python
# âœ… CORRETO - Sem races
parallel for i = 1 to n:
    result[i] = compute(A[i])  # Cada i Ã© independente

# âŒ INCORRETO - Race condition
parallel for i = 1 to n:
    shared_counter = shared_counter + 1  # Acesso concorrente
```

## ğŸ›¡ï¸ EstratÃ©gias de PrevenÃ§Ã£o

### ğŸ”’ Mutual Exclusion
```python
# Usando locks (nÃ£o recomendado para fork-join)
lock = Lock()
parallel for i = 1 to n:
    with lock:
        shared_counter += 1
```

### ğŸ“¦ Local Variables
```python
# âœ… CORRETO - VariÃ¡veis locais
parallel for i = 1 to n:
    local_sum = 0
    for j = 1 to n:
        local_sum += A[i][j] * x[j]
    y[i] = local_sum
```

### ğŸ”„ Reduction Patterns
```python
# âœ… CORRETO - Reduction paralelo
def P-REDUCE(A, n):
    if n == 1:
        return A[1]
    else:
        mid = n // 2
        left = spawn P-REDUCE(A[1..mid], mid)
        right = P-REDUCE(A[mid+1..n], n-mid)
        sync
        return left + right  # Combina resultados
```

## ğŸ® ConcorrÃªncia Estruturada

### ğŸ“‹ PrincÃ­pios
- **Fork-join**: Controle de paralelismo explÃ­cito
- **Sync points**: SincronizaÃ§Ã£o determinÃ­stica
- **No shared state**: Evita estado compartilhado

### ğŸ”„ PadrÃµes Seguros
```python
# âœ… PadrÃ£o Map
parallel for i = 1 to n:
    output[i] = f(input[i])

# âœ… PadrÃ£o Reduce
result = P-REDUCE(array, n)

# âœ… PadrÃ£o Divide-and-Conquer
spawn left_result = P-SOLVE(left_half)
right_result = P-SOLVE(right_half)
sync
return COMBINE(left_result, right_result)
```

## ğŸ§ª Ferramentas de DetecÃ§Ã£o

### ğŸ” Race Detection Tools
- **Static analysis**: Detecta races em tempo de compilaÃ§Ã£o
- **Dynamic analysis**: Detecta races durante execuÃ§Ã£o
- **Valgrind/Helgrind**: Ferramentas populares

### ğŸ“Š Exemplo de Uso
```bash
# Compilar com flags de detecÃ§Ã£o
gcc -fsanitize=thread -g race_example.c

# Executar com Valgrind
valgrind --tool=helgrind ./race_example
```

## ğŸ¯ Casos Especiais

### ğŸ”„ Benign Races
```python
# âœ… Race benigno - mesmo valor
parallel for i = 1 to n:
    shared_flag = True  # Todas escrevem o mesmo valor
```

### ğŸ² Intentional Non-determinism
```python
# âœ… NÃ£o-determinismo intencional
parallel for i = 1 to n:
    if random() > 0.5:
        result[i] = strategy_A()
    else:
        result[i] = strategy_B()
```

## ğŸ“ˆ Impacto na Performance

### âš–ï¸ Trade-offs
| Aspecto | CÃ³digo DeterminÃ­stico | CÃ³digo NÃ£o-determinÃ­stico |
|---------|----------------------|---------------------------|
| **Debugging** | ğŸŸ¢ FÃ¡cil | ğŸ”´ DifÃ­cil |
| **Testing** | ğŸŸ¢ ReproduzÃ­vel | ğŸ”´ NÃ£o-reproduzÃ­vel |
| **Performance** | ğŸ“‰ Pode ser menor | ğŸ“ˆ Pode ser maior |
| **Complexity** | ğŸŸ¢ Simples | ğŸ”´ Complexa |

## ğŸ¯ LiÃ§Ãµes Aprendidas

### âœ… Boas PrÃ¡ticas
- **Design determinÃ­stico**: Prefira algoritmos determinÃ­sticos
- **AnÃ¡lise cuidadosa**: Identifique dependÃªncias antes de paralelizar
- **Ferramentas**: Use detectores de race automaticamente

### âŒ Armadilhas
- **Paralelizar loops aninhados**: Pode criar races inesperadas
- **Ignorar dependÃªncias**: Resultado incorreto
- **Assumir atomicidade**: OperaÃ§Ãµes nÃ£o sÃ£o atÃ´micas por padrÃ£o 