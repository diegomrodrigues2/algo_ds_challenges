# 🏁 Race Conditions e Determinismo

## 🎯 Conceito Central
**Determinacy races** ocorrem quando duas instruções paralelas acessam a mesma localização de memória e pelo menos uma modifica o valor, causando comportamento não-determinístico.

## 🔍 Tipos de Races

### 🏁 Determinacy Race
```python
# ❌ INCORRETO - Race condition
x = 0
parallel for i = 1 to 2:
    x = x + 1  # Múltiplas threads escrevem em x
print(x)  # Pode imprimir 1 ou 2!
```

### 🎯 Race vs. Não-Race
| Situação | Tipo | Comportamento |
|----------|------|---------------|
| **Duas leituras** | ✅ Não-race | Determinístico |
| **Uma leitura, uma escrita** | ❌ Race | Não-determinístico |
| **Duas escritas** | ❌ Race | Não-determinístico |

## 🔧 Exemplo Detalhado

### 📝 RACE-EXAMPLE
```python
def RACE-EXAMPLE():
    x = 0
    parallel for i = 1 to 2:
        x = x + 1
    print(x)
```

### 🧠 Execução Interna
Cada `x = x + 1` é composto de:
1. **Load**: `r = x` (carrega valor da memória)
2. **Increment**: `r = r + 1` (incrementa no registrador)
3. **Store**: `x = r` (armazena de volta na memória)

### ⏱️ Sequência de Execução
```
Thread 1: r₁ = x (r₁ = 0)
Thread 2: r₂ = x (r₂ = 0)
Thread 1: r₁ = r₁ + 1 (r₁ = 1)
Thread 2: r₂ = r₂ + 1 (r₂ = 1)
Thread 1: x = r₁ (x = 1)
Thread 2: x = r₂ (x = 1)  # ❌ Sobrescreve!
```

## ⚠️ Exemplo Real: P-MAT-VEC-WRONG

### ❌ Versão Incorreta
```python
def P-MAT-VEC-WRONG(A, x, y, n):
    parallel for i = 1 to n:
        parallel for j = 1 to n:       # ❌ RACE!
            y[i] = y[i] + A[i][j] * x[j]
```

### 🏁 Problema
- **Múltiplas threads**: Todas escrevem em `y[i]`
- **Não-determinístico**: Resultado varia entre execuções
- **Incorreto**: Mesmo que span seja Θ(log n)

### ✅ Versão Correta
```python
def P-MAT-VEC(A, x, y, n):
    parallel for i = 1 to n:           # ✅ Cada thread tem seu i
        for j = 1 to n:
            y[i] = y[i] + A[i][j] * x[j]
```

## 🎯 Detecção de Races

### 🔍 Regras Básicas
1. **Mutualmente não-interferentes**: Strands paralelos não compartilham escrita
2. **Apenas leitura**: Dados compartilhados só para leitura
3. **Independência**: Cada saída modificada por uma thread

### 📊 Análise de Dependências
```python
# ✅ CORRETO - Sem races
parallel for i = 1 to n:
    result[i] = compute(A[i])  # Cada i é independente

# ❌ INCORRETO - Race condition
parallel for i = 1 to n:
    shared_counter = shared_counter + 1  # Acesso concorrente
```

## 🛡️ Estratégias de Prevenção

### 🔒 Mutual Exclusion
```python
# Usando locks (não recomendado para fork-join)
lock = Lock()
parallel for i = 1 to n:
    with lock:
        shared_counter += 1
```

### 📦 Local Variables
```python
# ✅ CORRETO - Variáveis locais
parallel for i = 1 to n:
    local_sum = 0
    for j = 1 to n:
        local_sum += A[i][j] * x[j]
    y[i] = local_sum
```

### 🔄 Reduction Patterns
```python
# ✅ CORRETO - Reduction paralelo
def P-REDUCE(A, n):
    if n == 1:
        return A[1]
    else:
        mid = n // 2
        left = spawn P-REDUCE(A[1..mid], mid)
        right = P-REDUCE(A[mid+1..n], n-mid)
        sync
        return left + right  # Combina resultados
```

## 🎮 Concorrência Estruturada

### 📋 Princípios
- **Fork-join**: Controle de paralelismo explícito
- **Sync points**: Sincronização determinística
- **No shared state**: Evita estado compartilhado

### 🔄 Padrões Seguros
```python
# ✅ Padrão Map
parallel for i = 1 to n:
    output[i] = f(input[i])

# ✅ Padrão Reduce
result = P-REDUCE(array, n)

# ✅ Padrão Divide-and-Conquer
spawn left_result = P-SOLVE(left_half)
right_result = P-SOLVE(right_half)
sync
return COMBINE(left_result, right_result)
```

## 🧪 Ferramentas de Detecção

### 🔍 Race Detection Tools
- **Static analysis**: Detecta races em tempo de compilação
- **Dynamic analysis**: Detecta races durante execução
- **Valgrind/Helgrind**: Ferramentas populares

### 📊 Exemplo de Uso
```bash
# Compilar com flags de detecção
gcc -fsanitize=thread -g race_example.c

# Executar com Valgrind
valgrind --tool=helgrind ./race_example
```

## 🎯 Casos Especiais

### 🔄 Benign Races
```python
# ✅ Race benigno - mesmo valor
parallel for i = 1 to n:
    shared_flag = True  # Todas escrevem o mesmo valor
```

### 🎲 Intentional Non-determinism
```python
# ✅ Não-determinismo intencional
parallel for i = 1 to n:
    if random() > 0.5:
        result[i] = strategy_A()
    else:
        result[i] = strategy_B()
```

## 📈 Impacto na Performance

### ⚖️ Trade-offs
| Aspecto | Código Determinístico | Código Não-determinístico |
|---------|----------------------|---------------------------|
| **Debugging** | 🟢 Fácil | 🔴 Difícil |
| **Testing** | 🟢 Reproduzível | 🔴 Não-reproduzível |
| **Performance** | 📉 Pode ser menor | 📈 Pode ser maior |
| **Complexity** | 🟢 Simples | 🔴 Complexa |

## 🎯 Lições Aprendidas

### ✅ Boas Práticas
- **Design determinístico**: Prefira algoritmos determinísticos
- **Análise cuidadosa**: Identifique dependências antes de paralelizar
- **Ferramentas**: Use detectores de race automaticamente

### ❌ Armadilhas
- **Paralelizar loops aninhados**: Pode criar races inesperadas
- **Ignorar dependências**: Resultado incorreto
- **Assumir atomicidade**: Operações não são atômicas por padrão 