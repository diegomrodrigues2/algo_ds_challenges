# 🔄 Modelo Fork-Join

## 🎯 Conceito Central
**Fork-join** é o modelo mais básico e bem compreendido de algoritmos paralelos baseados em tarefas, permitindo expressar paralelismo de forma limpa usando extensões linguísticas simples ao código serial.

## 🔧 Palavras-Chave Paralelas

### 📤 Spawn
```python
x = spawn P-FIB(n-1)  # Executa em paralelo
y = P-FIB(n-2)        # Continua executando
```
- **Fork**: Permite que uma subrotina execute em paralelo
- **Parent continua**: Não espera o child terminar
- **Cria árvore**: Subcomputações aninhadas em paralelo

### 🔗 Sync
```python
sync  # Espera todos os spawns terminarem
return x + y
```
- **Join**: Sincronização explícita
- **Garante**: Valores dos children estão prontos
- **Implicit**: Todo return tem sync automático

### 🔄 Parallel Loops
```python
parallel for i = 1 to n:
    # Iterações executam simultaneamente
```
- **Iterações paralelas**: Múltiplas iterações simultâneas
- **Sem races**: Cada iteração independente
- **Recursive spawning**: Implementação interna

## 📊 Modelo de Execução

### 🕸️ Trace (DAG)
- **Vértices**: Strands (cadeias de instruções)
- **Arestas**: Dependências entre strands
- **Série**: Caminho direcionado entre strands
- **Paralelo**: Sem caminho entre strands

### 📈 Métricas de Performance

| Métrica | Definição | Fórmula |
|---------|-----------|---------|
| **Work (T₁)** | Tempo total em 1 processador | Soma de todos os strands |
| **Span (T₁)** | Tempo com ∞ processadores | Caminho crítico no DAG |
| **Parallelism** | Razão work/span | T₁/T₁ |

### 🎯 Lei do Work e Span
```
Tₚ ≥ max(T₁/P, T₁)
```
- **Work Law**: Tₚ ≥ T₁/P
- **Span Law**: Tₚ ≥ T₁
- **Speedup**: T₁/Tₚ ≤ P

## 🧮 Análise de Algoritmos

### 📐 Composição Série-Paralelo
| Composição | Work | Span |
|------------|------|------|
| **Série** | T₁(A) + T₁(B) | T₁(A) + T₁(B) |
| **Paralelo** | T₁(A) + T₁(B) | max(T₁(A), T₁(B)) |

### 🔍 Exemplo: P-FIB(n)
```python
def P-FIB(n):
    if n ≤ 1: return n
    x = spawn P-FIB(n-1)
    y = P-FIB(n-2)
    sync
    return x + y
```

**Análise:**
- **Work**: T₁(n) = Θ(φⁿ) (mesmo que serial)
- **Span**: T₁(n) = Θ(n) (recurrence: T₁(n) = T₁(n-1) + Θ(1))
- **Parallelism**: Θ(φⁿ/n) (cresce dramaticamente)

## 🎮 Escalonamento

### 🎯 Greedy Scheduler
- **Complete step**: P strands prontos → usa todos os processadores
- **Incomplete step**: < P strands prontos → alguns processadores ociosos

### 📊 Teorema do Greedy
```
Tₚ ≤ T₁/P + T₁
```
- **Fator 2**: Dentro de 2x do ótimo
- **Linear speedup**: Quando P ≪ T₁/T₁
- **Slackness**: (T₁/T₁)/P > 1 para boa performance

## ⚠️ Race Conditions

### 🏁 Determinacy Races
```python
# ❌ INCORRETO - Race condition
parallel for i = 1 to 2:
    x = x + 1  # Acesso concorrente à mesma variável
```

### ✅ Código Determinístico
- **Mutualmente não-interferentes**: Strands paralelos não compartilham escrita
- **Apenas leitura**: Dados compartilhados só para leitura
- **Sem races**: Comportamento determinístico garantido

## 🎯 Vantagens do Modelo

| Aspecto | ✅ Vantagem |
|---------|-------------|
| **Simplicidade** | Extensão natural do código serial |
| **Análise** | Work/span analysis matemática |
| **Escalabilidade** | Funciona em qualquer número de processadores |
| **Implementação** | Suportado por frameworks modernos | 