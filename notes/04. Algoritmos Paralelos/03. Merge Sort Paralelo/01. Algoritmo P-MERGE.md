# ğŸ”„ P-MERGE: Merge Paralelo

## ğŸ¯ Problema
Mesclar dois subarrays ordenados **A[pâ‚..râ‚]** e **A[pâ‚‚..râ‚‚]** em um array de saÃ­da **B[pâ‚ƒ..râ‚ƒ]** de forma paralela, mantendo a ordem e minimizando o span.

## ğŸ”§ EstratÃ©gia Divide-and-Conquer

### ğŸ¯ Ideia Central
- **Pivot**: Escolher elemento mediano do subarray maior
- **Binary search**: Encontrar ponto de divisÃ£o no subarray menor
- **RecursÃ£o paralela**: Mesclar partes menores e maiores separadamente

### ğŸ“ DivisÃ£o Inteligente
```
A[pâ‚..râ‚]: [xâ‚, xâ‚‚, ..., x, ..., xâ‚™]  # x Ã© o pivot (mediano)
A[pâ‚‚..râ‚‚]: [yâ‚, yâ‚‚, ..., yâ‚˜]         # Buscar onde x se encaixa

Resultado: x divide os elementos em â‰¤ x e â‰¥ x
```

## ğŸ” Algoritmo de Busca BinÃ¡ria

### ğŸ“ FIND-SPLIT-POINT
```python
def FIND-SPLIT-POINT(A, p, r, x):
    low = p
    high = r + 1
    while low < high:
        mid = (low + high) // 2
        if x <= A[mid]:
            high = mid
        else:
            low = mid + 1
    return low
```

### â±ï¸ AnÃ¡lise
- **Work**: Î˜(log n) - busca binÃ¡ria
- **Span**: Î˜(log n) - sem paralelismo interno

## ğŸ”„ Algoritmo Principal

### ğŸ“ P-MERGE-AUX
```python
def P-MERGE-AUX(A, pâ‚, râ‚, pâ‚‚, râ‚‚, B, pâ‚ƒ):
    # Base case: ambos vazios
    if pâ‚ > râ‚ and pâ‚‚ > râ‚‚:
        return
    
    # Garantir que primeiro subarray Ã© maior
    if râ‚ - pâ‚ < râ‚‚ - pâ‚‚:
        exchange pâ‚ with pâ‚‚
        exchange râ‚ with râ‚‚
    
    # Escolher pivot do subarray maior
    qâ‚ = (pâ‚ + râ‚) // 2
    x = A[qâ‚]
    
    # Encontrar ponto de divisÃ£o no subarray menor
    qâ‚‚ = FIND-SPLIT-POINT(A, pâ‚‚, râ‚‚, x)
    
    # Calcular posiÃ§Ã£o do pivot na saÃ­da
    qâ‚ƒ = pâ‚ƒ + (qâ‚ - pâ‚) + (qâ‚‚ - pâ‚‚)
    B[qâ‚ƒ] = x
    
    # RecursÃ£o paralela
    spawn P-MERGE-AUX(A, pâ‚, qâ‚-1, pâ‚‚, qâ‚‚-1, B, pâ‚ƒ)      # â‰¤ x
    spawn P-MERGE-AUX(A, qâ‚+1, râ‚, qâ‚‚, râ‚‚, B, qâ‚ƒ+1)      # â‰¥ x
    sync
```

### ğŸ“ P-MERGE (Wrapper)
```python
def P-MERGE(A, p, q, r):
    let B[p..r] be a new array
    P-MERGE-AUX(A, p, q, q+1, r, B, p)
    parallel for i = p to r:
        A[i] = B[i]
```

## ğŸ“Š AnÃ¡lise de Performance

### ğŸ” Work Analysis
```
Tâ‚(n) = Tâ‚(Î±n) + Tâ‚((1-Î±)n) + Î˜(log n)
       = Î˜(n)  # Linear work
```

**Prova por substituiÃ§Ã£o:**
- **HipÃ³tese**: Tâ‚(n) â‰¤ câ‚n + câ‚‚ log n
- **SubstituiÃ§Ã£o**: Tâ‚(n) â‰¤ câ‚n + câ‚‚ log n + Î˜(log n)
- **Resultado**: Tâ‚(n) = Î˜(n)

### â±ï¸ Span Analysis
```
Tâ‚(n) = Tâ‚(3n/4) + Î˜(log n)
       = Î˜(logÂ² n)  # Master theorem case 2
```

**Garantia de balanceamento:**
- **Pivot mediano**: Garante que nenhuma parte tem > 3n/4 elementos
- **RecursÃ£o limitada**: MÃ¡ximo Î˜(log n) nÃ­veis

### ğŸš€ Parallelism
```
Parallelism = Tâ‚(n)/Tâ‚(n) = Î˜(n/logÂ² n)
```

## ğŸ¯ Garantias de Balanceamento

### ğŸ“ AnÃ¡lise do Pivot
```
nâ‚ = râ‚ - pâ‚ + 1  # Tamanho do subarray maior
nâ‚‚ = râ‚‚ - pâ‚‚ + 1  # Tamanho do subarray menor

ApÃ³s divisÃ£o:
- Parte â‰¤ x: â‰¤ nâ‚/2 + nâ‚‚ elementos
- Parte â‰¥ x: â‰¤ nâ‚/2 + nâ‚‚ elementos

Como nâ‚‚ â‰¤ nâ‚ (por swap):
- MÃ¡ximo: nâ‚/2 + nâ‚ = 3nâ‚/2 â‰¤ 3n/4 (onde n = nâ‚ + nâ‚‚)
```

## ğŸ”„ Merge Sort Paralelo Completo

### ğŸ“ P-MERGE-SORT
```python
def P-MERGE-SORT(A, p, r):
    if p >= r:
        return
    
    q = (p + r) // 2
    
    # Ordenar metades em paralelo
    spawn P-MERGE-SORT(A, p, q)
    spawn P-MERGE-SORT(A, q+1, r)
    sync
    
    # Mesclar usando P-MERGE
    P-MERGE(A, p, q, r)
```

### ğŸ“Š AnÃ¡lise Completa
- **Work**: Tâ‚(n) = 2Tâ‚(n/2) + Î˜(n) = Î˜(n log n)
- **Span**: Tâ‚(n) = Tâ‚(n/2) + Î˜(logÂ² n) = Î˜(logÂ³ n)
- **Parallelism**: Î˜(n log n)/Î˜(logÂ³ n) = Î˜(n/logÂ² n)

## âš ï¸ VersÃ£o IngÃªnua (P-NAIVE-MERGE-SORT)

### âŒ Problema
```python
def P-NAIVE-MERGE-SORT(A, p, r):
    if p >= r:
        return
    
    q = (p + r) // 2
    
    spawn P-NAIVE-MERGE-SORT(A, p, q)
    spawn P-NAIVE-MERGE-SORT(A, q+1, r)
    sync
    
    MERGE(A, p, q, r)  # âŒ Merge serial!
```

### ğŸ“‰ Performance Ruim
- **Work**: Î˜(n log n)
- **Span**: Tâ‚(n) = Tâ‚(n/2) + Î˜(n) = Î˜(n)
- **Parallelism**: Î˜(log n) - muito baixo!

## ğŸ¯ OtimizaÃ§Ãµes

### ğŸ“ˆ Coarsening
```python
def P-MERGE-COARSE(A, p, q, r, threshold):
    if r - p + 1 <= threshold:
        SERIAL-MERGE(A, p, q, r)
        return
    # ... resto do algoritmo P-MERGE
```

### ğŸ”„ OtimizaÃ§Ãµes de Cache
- **Memory access pattern**: Sequencial na saÃ­da
- **Binary search**: Localizado no subarray menor
- **Recursive structure**: Cache-friendly

## ğŸ“ˆ ComparaÃ§Ã£o de Performance

| Algoritmo | Work | Span | Parallelism |
|-----------|------|------|-------------|
| **Serial Merge Sort** | Î˜(n log n) | Î˜(n log n) | 1 |
| **P-NAIVE-MERGE-SORT** | Î˜(n log n) | Î˜(n) | Î˜(log n) |
| **P-MERGE-SORT** | Î˜(n log n) | Î˜(logÂ³ n) | Î˜(n/logÂ² n) |

## ğŸ¯ LiÃ§Ãµes Aprendidas

### âœ… Boas PrÃ¡ticas
- **Pivot inteligente**: Mediano garante balanceamento
- **Binary search eficiente**: Î˜(log n) para encontrar divisÃ£o
- **RecursÃ£o paralela**: Duas partes independentes

### âŒ Armadilhas
- **Merge serial**: Bottleneck principal
- **Pivot ruim**: Pode causar desbalanceamento
- **Overhead**: Pode dominar para arrays pequenos 