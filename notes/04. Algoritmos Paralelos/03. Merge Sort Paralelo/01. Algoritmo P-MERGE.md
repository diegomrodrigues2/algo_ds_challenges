# 🔄 P-MERGE: Merge Paralelo

## 🎯 Problema
Mesclar dois subarrays ordenados **A[p₁..r₁]** e **A[p₂..r₂]** em um array de saída **B[p₃..r₃]** de forma paralela, mantendo a ordem e minimizando o span.

## 🔧 Estratégia Divide-and-Conquer

### 🎯 Ideia Central
- **Pivot**: Escolher elemento mediano do subarray maior
- **Binary search**: Encontrar ponto de divisão no subarray menor
- **Recursão paralela**: Mesclar partes menores e maiores separadamente

### 📐 Divisão Inteligente
```
A[p₁..r₁]: [x₁, x₂, ..., x, ..., xₙ]  # x é o pivot (mediano)
A[p₂..r₂]: [y₁, y₂, ..., yₘ]         # Buscar onde x se encaixa

Resultado: x divide os elementos em ≤ x e ≥ x
```

## 🔍 Algoritmo de Busca Binária

### 📝 FIND-SPLIT-POINT
```python
def FIND-SPLIT-POINT(A, p, r, x):
    low = p
    high = r + 1
    while low < high:
        mid = (low + high) // 2
        if x <= A[mid]:
            high = mid
        else:
            low = mid + 1
    return low
```

### ⏱️ Análise
- **Work**: Θ(log n) - busca binária
- **Span**: Θ(log n) - sem paralelismo interno

## 🔄 Algoritmo Principal

### 📝 P-MERGE-AUX
```python
def P-MERGE-AUX(A, p₁, r₁, p₂, r₂, B, p₃):
    # Base case: ambos vazios
    if p₁ > r₁ and p₂ > r₂:
        return
    
    # Garantir que primeiro subarray é maior
    if r₁ - p₁ < r₂ - p₂:
        exchange p₁ with p₂
        exchange r₁ with r₂
    
    # Escolher pivot do subarray maior
    q₁ = (p₁ + r₁) // 2
    x = A[q₁]
    
    # Encontrar ponto de divisão no subarray menor
    q₂ = FIND-SPLIT-POINT(A, p₂, r₂, x)
    
    # Calcular posição do pivot na saída
    q₃ = p₃ + (q₁ - p₁) + (q₂ - p₂)
    B[q₃] = x
    
    # Recursão paralela
    spawn P-MERGE-AUX(A, p₁, q₁-1, p₂, q₂-1, B, p₃)      # ≤ x
    spawn P-MERGE-AUX(A, q₁+1, r₁, q₂, r₂, B, q₃+1)      # ≥ x
    sync
```

### 📝 P-MERGE (Wrapper)
```python
def P-MERGE(A, p, q, r):
    let B[p..r] be a new array
    P-MERGE-AUX(A, p, q, q+1, r, B, p)
    parallel for i = p to r:
        A[i] = B[i]
```

## 📊 Análise de Performance

### 🔍 Work Analysis
```
T₁(n) = T₁(αn) + T₁((1-α)n) + Θ(log n)
       = Θ(n)  # Linear work
```

**Prova por substituição:**
- **Hipótese**: T₁(n) ≤ c₁n + c₂ log n
- **Substituição**: T₁(n) ≤ c₁n + c₂ log n + Θ(log n)
- **Resultado**: T₁(n) = Θ(n)

### ⏱️ Span Analysis
```
T₁(n) = T₁(3n/4) + Θ(log n)
       = Θ(log² n)  # Master theorem case 2
```

**Garantia de balanceamento:**
- **Pivot mediano**: Garante que nenhuma parte tem > 3n/4 elementos
- **Recursão limitada**: Máximo Θ(log n) níveis

### 🚀 Parallelism
```
Parallelism = T₁(n)/T₁(n) = Θ(n/log² n)
```

## 🎯 Garantias de Balanceamento

### 📐 Análise do Pivot
```
n₁ = r₁ - p₁ + 1  # Tamanho do subarray maior
n₂ = r₂ - p₂ + 1  # Tamanho do subarray menor

Após divisão:
- Parte ≤ x: ≤ n₁/2 + n₂ elementos
- Parte ≥ x: ≤ n₁/2 + n₂ elementos

Como n₂ ≤ n₁ (por swap):
- Máximo: n₁/2 + n₁ = 3n₁/2 ≤ 3n/4 (onde n = n₁ + n₂)
```

## 🔄 Merge Sort Paralelo Completo

### 📝 P-MERGE-SORT
```python
def P-MERGE-SORT(A, p, r):
    if p >= r:
        return
    
    q = (p + r) // 2
    
    # Ordenar metades em paralelo
    spawn P-MERGE-SORT(A, p, q)
    spawn P-MERGE-SORT(A, q+1, r)
    sync
    
    # Mesclar usando P-MERGE
    P-MERGE(A, p, q, r)
```

### 📊 Análise Completa
- **Work**: T₁(n) = 2T₁(n/2) + Θ(n) = Θ(n log n)
- **Span**: T₁(n) = T₁(n/2) + Θ(log² n) = Θ(log³ n)
- **Parallelism**: Θ(n log n)/Θ(log³ n) = Θ(n/log² n)

## ⚠️ Versão Ingênua (P-NAIVE-MERGE-SORT)

### ❌ Problema
```python
def P-NAIVE-MERGE-SORT(A, p, r):
    if p >= r:
        return
    
    q = (p + r) // 2
    
    spawn P-NAIVE-MERGE-SORT(A, p, q)
    spawn P-NAIVE-MERGE-SORT(A, q+1, r)
    sync
    
    MERGE(A, p, q, r)  # ❌ Merge serial!
```

### 📉 Performance Ruim
- **Work**: Θ(n log n)
- **Span**: T₁(n) = T₁(n/2) + Θ(n) = Θ(n)
- **Parallelism**: Θ(log n) - muito baixo!

## 🎯 Otimizações

### 📈 Coarsening
```python
def P-MERGE-COARSE(A, p, q, r, threshold):
    if r - p + 1 <= threshold:
        SERIAL-MERGE(A, p, q, r)
        return
    # ... resto do algoritmo P-MERGE
```

### 🔄 Otimizações de Cache
- **Memory access pattern**: Sequencial na saída
- **Binary search**: Localizado no subarray menor
- **Recursive structure**: Cache-friendly

## 📈 Comparação de Performance

| Algoritmo | Work | Span | Parallelism |
|-----------|------|------|-------------|
| **Serial Merge Sort** | Θ(n log n) | Θ(n log n) | 1 |
| **P-NAIVE-MERGE-SORT** | Θ(n log n) | Θ(n) | Θ(log n) |
| **P-MERGE-SORT** | Θ(n log n) | Θ(log³ n) | Θ(n/log² n) |

## 🎯 Lições Aprendidas

### ✅ Boas Práticas
- **Pivot inteligente**: Mediano garante balanceamento
- **Binary search eficiente**: Θ(log n) para encontrar divisão
- **Recursão paralela**: Duas partes independentes

### ❌ Armadilhas
- **Merge serial**: Bottleneck principal
- **Pivot ruim**: Pode causar desbalanceamento
- **Overhead**: Pode dominar para arrays pequenos 