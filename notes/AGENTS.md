### Instru√ß√µes para o Agente

## üéØ Objetivo
Criar resumos did√°ticos e visuais de algoritmos e estrutura de dados que sejam **f√°ceis de entender** e **visualmente atraentes**, priorizando clareza conceitual mas mantendo o alto n√≠vel t√©cnico e te√≥rico de forma coesa e **extremamente concisa**

## üìè Limita√ß√µes de Tamanho
- **üìÑ Tamanho m√°ximo**: 1-3 p√°ginas por documento
- **üéØ Priorize**: Conceitos essenciais sobre detalhes extensos
- **‚úÇÔ∏è Elimine**: Redund√¢ncias e exemplos excessivos
- **üî• Foque**: No que √© cr√≠tico para entendimento

## üìù Formato dos Documentos

### 1. Estrutura Visual Compacta
- **Use emojis** para representar conceitos, atores e componentes
- **T√≠tulos concisos** com emojis descritivos
- **Defini√ß√µes em 1-2 frases** mantendo detalhes essenciais
- **Tabelas compactas** para compara√ß√µes r√°pidas
- **Diagramas simples**

### 2. Diretrizes de Escrita Concisa
- ‚úÖ **M√°ximo 3 par√°grafos** por se√ß√£o
- ‚úÖ **Frases curtas** e diretas
- ‚úÖ **Bullet points** em vez de texto corrido
- ‚úÖ **Elimine pre√¢mbulos** - v√° direto ao ponto
- ‚úÖ **Use analogias curtas** (1 frase m√°ximo)

### 3. Elementos Visuais Obrigat√≥rios

#### üìä Tabelas Compactas
| Aspecto | ‚úÖ Vantagem | ‚ùå Desvantagem |
|---------|-------------|----------------|
| Performance | üöÄ R√°pido | üíæ Usa mem√≥ria |
| Consist√™ncia | üõ°Ô∏è Garantida | ‚è∞ Mais lento |

#### üé® Diagramas Mermaid
- **Use diagramas simples** que facilitem a compreens√£o
- **Evite**: `graph` muito extensos, tente mant√™-los concisos
- **Nunca use**: Mapas mentais
- **Represente atores e componentes com emojis**:
  - üë§ Usu√°rio/Cliente
  - üîß Sistema/Processo
  - üì¶ Dados/Objetos
  - ‚ö° Opera√ß√µes/A√ß√µes
  - üîÑ Estados/Transi√ß√µes


## üìÅ Organiza√ß√£o de Arquivos

```
01. Nome do Super-t√≥pico/
    01. Nome do T√≥pico/
        01. Nome do Sub-t√≥pico.md
        02. Nome do Sub-t√≥pico.md
        03. Nome do Sub-t√≥pico.md
        ...
    02. Nome do T√≥pico/
        01. Nome do Sub-t√≥pico.md
        02. Nome do Sub-t√≥pico.md
        03. Nome do Sub-t√≥pico.md
        ...
02. Outro super-t√≥pico/
    01. Nome do T√≥pico/
        ...
```

## üîß Uso da Nota√ß√£o

- **Consulte sempre** o NOTATION.md para s√≠mbolos padronizados
- **Use nota√ß√£o apenas quando necess√°rio** para clareza
- **Prefira descri√ß√µes textuais** com emojis a f√≥rmulas complexas
- **Atualize NOTATION.md** quando introduzir novos conceitos

## üìê Regras de Concis√£o
- **üö´ M√°ximo 1000 palavras** por documento
- **‚è∞ Leitura em 3-5 minutos**
- **üéØ Uma ideia central** por se√ß√£o

## üìù F√≥rmulas Matem√°ticas
- **Use sintaxe LaTeX** para todas as f√≥rmulas matem√°ticas
- **Exemplo**: `$f(x) = \frac{1}{k} \sum_{i \in N_k(x_0)} y_i$`
- **Prefira**: F√≥rmulas inline com `$...$` para express√µes simples
- **Use**: `$$...$$` para f√≥rmulas em bloco quando necess√°rio

## üéÆ Implementa√ß√µes Espec√≠ficas

### Jogo da Velha Generalizado com Minimax

#### üéØ Vis√£o Geral
Implementa√ß√£o do algoritmo Minimax para Jogo da Velha generalizado (n√ón), demonstrando aplica√ß√£o formal do backtracking em √°rvores de jogo.

#### üîó V√≠nculos Conceituais
- **Erickson, "Algorithms"**: Cap√≠tulo 2, Se√ß√£o 2.2, "Game Trees"
- **GitHub Reference**: [t-ROY-coder/Tic-Tac-Toe-Game](https://github.com/t-ROY-coder/Tic-Tac-Toe-Game)
- **Teoria**: [Erickson sobre √Årvores de Jogo](https://jeffe.cs.illinois.edu/teaching/algorithms/book/02-backtracking.pdf)

#### üß† An√°lise de Especialista
O algoritmo Minimax √© backtracking aplicado a jogos de dois jogadores com informa√ß√£o perfeita:
- **Maximizador**: Escolhe movimento que leva ao melhor resultado
- **Minimizador**: Escolhe movimento que leva ao pior resultado para o maximizador
- **Backtracking**: Retrocede valores das folhas para determinar movimento √≥timo

#### ‚öôÔ∏è Estrutura da Implementa√ß√£o
```python
class TicTacToeBoard:
    def __init__(self, size: int = 3):  # Tabuleiro n√ón
    def make_move(self, row: int, col: int) -> bool:  # Movimento
    def get_available_moves(self) -> List[Tuple[int, int]]:  # Movimentos dispon√≠veis
    def is_terminal_state(self) -> bool:  # Estado terminal
    def get_utility(self) -> int:  # Valor de utilidade

def minimax(board, depth, alpha, beta, maximizing) -> Tuple[int, Optional[Tuple[int, int]]]:
    # Algoritmo Minimax com poda Alpha-Beta
```

#### üöÄ Funcionalidades Principais
1. **Algoritmo Minimax com Poda Alpha-Beta**: Explora√ß√£o completa para tabuleiros pequenos
2. **Jogo da Velha Generalizado**: Suporta tabuleiros n√ón
3. **An√°lise de Complexidade**: `analyze_minimax_complexity(size)`
4. **Simula√ß√£o de Jogos √ìtimos**: `play_optimal_game(size, max_depth)`

#### üìä Complexidade e Limita√ß√µes
- **Tempo**: O(b^d) onde b √© fator de ramifica√ß√£o, d √© profundidade
- **Espa√ßo**: O(d) para profundidade da pilha de recurs√£o
- **Limita√ß√µes**: Praticamente vi√°vel at√© tabuleiros 4√ó4

#### üéØ Aplica√ß√µes Pr√°ticas
- **Jogos de Tabuleiro**: Xadrez, Damas, Go
- **IA Competitiva**: Algoritmo fundamental para IAs fortes
- **Teoria dos Jogos**: An√°lise de estrat√©gias √≥timas
- **Educa√ß√£o em IA**: Exemplo cl√°ssico de busca em √°rvores

#### ‚ö° Otimiza√ß√µes Implementadas
1. **Poda Alpha-Beta**: Reduz n√≥s explorados em at√© 50%
2. **Busca em Profundidade Limitada**: Controle de tempo de execu√ß√£o
3. **Memoiza√ß√£o**: Cache de estados para evitar rec√°lculos

#### üß™ Testes e Valida√ß√£o
- **Testes Unit√°rios**: Funcionalidade b√°sica, algoritmo Minimax, casos extremos
- **Testes de Performance**: Benchmark para diferentes tamanhos de tabuleiro
- **An√°lise de Complexidade**: Valida√ß√£o das estimativas te√≥ricas

### Segmenta√ß√£o de Texto com Memoiza√ß√£o

#### üéØ Vis√£o Geral
Implementa√ß√£o do problema da Segmenta√ß√£o de Texto (Word Break) usando memoiza√ß√£o, demonstrando a transi√ß√£o de backtracking exponencial O(2^n) para programa√ß√£o din√¢mica O(n¬≤).

#### üîó V√≠nculos Conceituais
- **Erickson, "Algorithms"**: Cap√≠tulo 3, Se√ß√£o 3.3, "Interpunctio Verborum Redux"
- **GeeksforGeeks**: [Word Break Problem](https://www.geeksforgeeks.org/dsa/word-break-problem-dp-32/)
- **Tutorial Horizon**: [The Word Break Problem](https://tutorialhorizon.com/algorithms/the-word-break-problem/)

#### üß† An√°lise de Especialista
A transi√ß√£o do backtracking O(2^n) para programa√ß√£o din√¢mica O(n¬≤) √© a quintess√™ncia da PD:
- **Estado (i)**: "O sufixo text[i..n] pode ser segmentado?"
- **Memoiza√ß√£o**: Cache para evitar rec√°lculos exponenciais
- **Subproblemas Sobrepostos**: M√∫ltiplos caminhos para o mesmo estado

#### ‚öôÔ∏è Estrutura da Implementa√ß√£o
```python
def text_segmentation_memoization(text: str, dictionary: Set[str]) -> Optional[List[str]]:
    """
    Resolve Segmenta√ß√£o de Texto usando memoiza√ß√£o.
    
    Args:
        text: String sem espa√ßos para segmentar
        dictionary: Conjunto de palavras v√°lidas
        
    Returns:
        Lista de palavras se a segmenta√ß√£o for poss√≠vel, None caso contr√°rio
    """
    # Cache para memoiza√ß√£o
    memo = {}
    
    def can_segment(start: int) -> Optional[List[str]]:
        # Verifica se resultado j√° est√° no cache
        if start in memo:
            return memo[start]
        
        # Casos base
        if start == len(text):
            return []
        
        # Tenta todos os prefixos poss√≠veis
        for end in range(start + 1, len(text) + 1):
            prefix = text[start:end]
            if prefix in dictionary:
                remaining = can_segment(end)
                if remaining is not None:
                    result = [prefix] + remaining
                    memo[start] = result
                    return result
        
        # Nenhuma segmenta√ß√£o encontrada
        memo[start] = None
        return None
    
    return can_segment(0)
```

#### üöÄ Funcionalidades Principais
1. **Memoiza√ß√£o Top-Down**: Cache para evitar rec√°lculos
2. **Transi√ß√£o de Backtracking**: Otimiza√ß√£o de solu√ß√£o recursiva
3. **Complexidade Quadr√°tica**: O(n¬≤) onde n √© o tamanho da string
4. **Identifica√ß√£o de Estado**: √çndice inicial do sufixo

#### üìä Complexidade e Limita√ß√µes
- **Tempo**: O(n¬≤) quadr√°tico
- **Espa√ßo**: O(n) para cache de memoiza√ß√£o
- **Vantagem**: Reduz complexidade exponencial para quadr√°tica
- **Limita√ß√£o**: Ainda pode ser lento para strings muito longas

#### üéØ Aplica√ß√µes Pr√°ticas
- **Processamento de Texto**: Segmenta√ß√£o de texto sem espa√ßos
- **Compiladores**: An√°lise l√©xica e parsing
- **IA e NLP**: Processamento de linguagem natural
- **Sistemas de Busca**: Indexa√ß√£o e recupera√ß√£o de texto

#### ‚ö° Otimiza√ß√µes Implementadas
1. **Cache de Memoiza√ß√£o**: Evita rec√°lculos de subproblemas
2. **Identifica√ß√£o de Estado**: √çndice inicial como chave √∫nica
3. **Pruning Inteligente**: Para quando chega ao final da string
4. **Transi√ß√£o Suave**: Mant√©m estrutura recursiva original

#### üß™ Testes e Valida√ß√£o
- **Testes Unit√°rios**: Casos b√°sicos, casos extremos, casos de borda
- **Testes de Performance**: Compara√ß√£o com backtracking puro
- **An√°lise de Complexidade**: Valida√ß√£o da redu√ß√£o de complexidade
- **Casos de Stress**: Testes com strings longas

### LIS com Memoiza√ß√£o

#### üéØ Vis√£o Geral
Implementa√ß√£o do problema da Subsequ√™ncia Crescente Mais Longa (LIS) usando memoiza√ß√£o com a formula√ß√£o LISbigger(i, j), demonstrando a transi√ß√£o de backtracking exponencial O(2^n) para programa√ß√£o din√¢mica O(n¬≤).

#### üîó V√≠nculos Conceituais
- **Erickson, "Algorithms"**: Cap√≠tulo 3, Se√ß√£o 3.6, "First Recurrence: Is This Next?"
- **GeeksforGeeks**: [LIS with DP](https://www.geeksforgeeks.org/dsa/longest-increasing-subsequence-dp-3/)
- **Formula√ß√£o LISbigger**: Estado bidimensional (current_index, previous_index)

#### üß† An√°lise de Especialista
A transi√ß√£o do backtracking O(2^n) para programa√ß√£o din√¢mica O(n¬≤) usando LISbigger(i, j):
- **Estado (i, j)**: "LIS come√ßando em i com elemento anterior em j"
- **Memoiza√ß√£o**: Cache 2D para evitar rec√°lculos exponenciais
- **Formula√ß√£o de Erickson**: Base te√≥rica para recurs√£o inteligente

#### ‚öôÔ∏è Estrutura da Implementa√ß√£o
```python
def lis_memoization(arr: List[int]) -> int:
    """
    Resolve LIS usando memoiza√ß√£o com formula√ß√£o LISbigger(i, j).
    
    Args:
        arr: Lista de n√∫meros inteiros
        
    Returns:
        Comprimento da subsequ√™ncia crescente mais longa
    """
    # Cache para memoiza√ß√£o
    memo = {}
    
    def lis_bigger(i: int, prev_idx: int) -> int:
        # Verifica se resultado j√° est√° no cache
        if (i, prev_idx) in memo:
            return memo[(i, prev_idx)]
        
        # Caso base
        if i == len(arr):
            return 0
        
        # Op√ß√£o 1: N√£o incluir elemento atual
        result = lis_bigger(i + 1, prev_idx)
        
        # Op√ß√£o 2: Incluir elemento atual (se poss√≠vel)
        if prev_idx == -1 or arr[i] > arr[prev_idx]:
            result = max(result, 1 + lis_bigger(i + 1, i))
        
        memo[(i, prev_idx)] = result
        return result
    
    return lis_bigger(0, -1)
```

#### üöÄ Funcionalidades Principais
1. **Memoiza√ß√£o Bidimensional**: Cache para estados (i, j)
2. **Formula√ß√£o LISbigger**: Implementa√ß√£o direta da recorr√™ncia de Erickson
3. **Complexidade Quadr√°tica**: O(n¬≤) tempo e espa√ßo
4. **Decis√£o Bin√°ria**: Para cada elemento, incluir ou n√£o na subsequ√™ncia

#### üìä Complexidade e Limita√ß√µes
- **Tempo**: O(n¬≤) quadr√°tico
- **Espa√ßo**: O(n¬≤) para cache de memoiza√ß√£o
- **Vantagem**: Reduz complexidade exponencial para quadr√°tica
- **Limita√ß√£o**: Uso de mem√≥ria proporcional a n¬≤

#### üéØ Aplica√ß√µes Pr√°ticas
- **An√°lise de Sequ√™ncias**: Encontrar tend√™ncias de crescimento
- **Mercado Financeiro**: Per√≠odos de alta em pre√ßos de a√ß√µes
- **Progresso Acad√™mico**: Sequ√™ncias de melhoria em notas
- **Otimiza√ß√£o**: Sequ√™ncias de melhoria cont√≠nua

#### ‚ö° Otimiza√ß√µes Implementadas
1. **Cache Bidimensional**: Evita rec√°lculos de pares (i, j)
2. **Decis√£o Eficiente**: Considera incluir/n√£o incluir cada elemento
3. **Estado Compacto**: Par (√≠ndice_atual, √≠ndice_anterior)
4. **Base para O(n log n)**: Funda√ß√£o para otimiza√ß√£o com busca bin√°ria

#### üß™ Testes e Valida√ß√£o
- **Testes Unit√°rios**: Casos b√°sicos, arrays ordenados/reversos, elementos duplicados
- **Testes de Performance**: Compara√ß√£o com diferentes abordagens
- **An√°lise de Complexidade**: Valida√ß√£o da redu√ß√£o de O(2^n) para O(n¬≤)
- **Casos Reais**: Aplica√ß√µes em an√°lise de dados sequenciais

### Soma de Subconjuntos com Memoiza√ß√£o

#### üéØ Vis√£o Geral
Implementa√ß√£o do problema da Soma de Subconjuntos usando memoiza√ß√£o, demonstrando a transi√ß√£o de backtracking exponencial para programa√ß√£o din√¢mica eficiente.

#### üîó V√≠nculos Conceituais
- **Erickson, "Algorithms"**: Cap√≠tulo 3, Se√ß√£o 3.1, "Memo(r)ization"
- **Teoria**: [Erickson sobre Programa√ß√£o Din√¢mica](https://jeffe.cs.illinois.edu/teaching/algorithms/book/03-dynprog.pdf)
- **Implementa√ß√£o**: [GeeksforGeeks - Subset Sum DP](https://www.geeksforgeeks.org/dsa/subset-sum-problem-dp-25/)
- **Compara√ß√£o**: [Memoiza√ß√£o vs Tabula√ß√£o](https://www.geeksforgeeks.org/dsa/tabulation-vs-memoization/)

#### üß† An√°lise de Especialista
A transi√ß√£o do backtracking O(2^n) para programa√ß√£o din√¢mica O(n¬∑T) √© a quintess√™ncia da PD:
- **Estado (i, t)**: "Existe subconjunto de X[i..n] que soma t?"
- **Memoiza√ß√£o**: Cache para evitar rec√°lculos exponenciais
- **Recurs√£o Inteligente**: PD como otimiza√ß√£o de algoritmos recursivos

#### ‚öôÔ∏è Estrutura da Implementa√ß√£o
```python
def subset_sum_memoization(nums: List[int], target: int) -> bool:
    """
    Resolve Soma de Subconjuntos usando memoiza√ß√£o.
    
    Args:
        nums: Lista de n√∫meros inteiros
        target: Valor alvo a ser alcan√ßado
        
    Returns:
        True se existe subconjunto que soma target, False caso contr√°rio
    """
    # Cache para memoiza√ß√£o
    memo = {}
    
    def dp(i: int, t: int) -> bool:
        # Verifica se resultado j√° est√° no cache
        if (i, t) in memo:
            return memo[(i, t)]
        
        # Casos base
        if t == 0:
            return True
        if i >= len(nums) or t < 0:
            return False
        
        # Recurs√£o com memoiza√ß√£o
        result = dp(i + 1, t - nums[i]) or dp(i + 1, t)
        memo[(i, t)] = result
        return result
    
    return dp(0, target)
```

#### üöÄ Funcionalidades Principais
1. **Memoiza√ß√£o Top-Down**: Cache para evitar rec√°lculos
2. **Transi√ß√£o de Backtracking**: Otimiza√ß√£o de solu√ß√£o recursiva
3. **Complexidade Pseudo-Polinomial**: O(n¬∑T) onde T √© o valor alvo
4. **Identifica√ß√£o de Estado**: Par (i, t) representa subproblema √∫nico

#### üìä Complexidade e Limita√ß√µes
- **Tempo**: O(n¬∑T) pseudo-polinomial
- **Espa√ßo**: O(n¬∑T) para cache de memoiza√ß√£o
- **Vantagem**: Reduz complexidade exponencial para pseudo-polinomial
- **Limita√ß√£o**: Ainda pode ser lento para valores de target muito grandes

#### üéØ Aplica√ß√µes Pr√°ticas
- **Problemas de Otimiza√ß√£o**: Aloca√ß√£o de recursos, balanceamento de carga
- **Teoria da Computa√ß√£o**: Exemplo cl√°ssico de NP-completeness
- **Educa√ß√£o em PD**: Demonstra transi√ß√£o de for√ßa bruta para efici√™ncia
- **Base para Outros Problemas**: Knapsack, Partition, Coin Change

#### ‚ö° Otimiza√ß√µes Implementadas
1. **Cache de Memoiza√ß√£o**: Evita rec√°lculos de subproblemas
2. **Identifica√ß√£o de Estado**: Par (i, t) como chave √∫nica
3. **Pruning Inteligente**: Para quando t < 0 ou t == 0
4. **Transi√ß√£o Suave**: Mant√©m estrutura recursiva original

#### üß™ Testes e Valida√ß√£o
- **Testes Unit√°rios**: Casos b√°sicos, casos extremos, casos de borda
- **Testes de Performance**: Compara√ß√£o com backtracking puro
- **An√°lise de Complexidade**: Valida√ß√£o da redu√ß√£o de complexidade
- **Casos de Stress**: Testes com valores grandes de target
