# 🔪 Problema do Corte de Barras (Rod Cutting)

## 🎯 Definição
Dada uma barra de comprimento `n` e preços `p[i]` para barras de comprimento `i`, encontre a forma de cortar que maximize o lucro total.

## 📊 Exemplo Prático
```
Comprimento: 4
Preços: [0, 1, 5, 8, 9]
Solução: 2 + 2 = 5 + 5 = 10 (lucro máximo)
```

## 🧩 Relação de Recorrência

### 📈 Fórmula Principal
```
dp[n] = max(p[i] + dp[n-i]) para i = 1 até n
```

### 🔄 Interpretação
- **Decisão**: Fazer ou não fazer corte no ponto `i`
- **Subproblema**: Lucro máximo para barra de comprimento `n-i`
- **Sobreposição**: Múltiplos caminhos levam ao mesmo subproblema

## 💻 Implementações

### 🔄 Recursiva (Top-Down)
```python
def rod_cutting_recursive(prices, n):
    if n <= 0: return 0
    max_profit = 0
    for i in range(1, n + 1):
        max_profit = max(max_profit, prices[i] + rod_cutting_recursive(prices, n - i))
    return max_profit
```

### 🚀 Programação Dinâmica (Bottom-Up)
```python
def rod_cutting_dp(prices, n):
    dp = [0] * (n + 1)
    for i in range(1, n + 1):
        for j in range(1, i + 1):
            dp[i] = max(dp[i], prices[j] + dp[i - j])
    return dp[n]
```

## 📊 Análise de Complexidade

| Implementação | ⏰ Tempo | 💾 Espaço | 🔄 Recursões |
|---------------|----------|-----------|--------------|
| **Recursiva** | O(2^n) | O(n) | Muitas |
| **Memoização** | O(n²) | O(n) | Reduzidas |
| **Bottom-Up** | O(n²) | O(n) | Zero |

## 🎯 Variações do Problema

### 🔢 Com Restrições
- **Cortes Limitados**: Máximo de `k` cortes
- **Custos de Corte**: Cada corte tem custo fixo
- **Comprimentos Fixos**: Apenas certos comprimentos permitidos

### 📈 Otimizações
- **Espaço**: Usar apenas array 1D
- **Tempo**: Early termination para preços decrescentes
- **Memoização**: Cache de resultados intermediários

## 🚀 Aplicações Reais
- **Manufatura**: Corte de barras de metal/madeira
- **Logística**: Otimização de carregamento
- **Financeiro**: Maximização de retorno em investimentos
- **Produção**: Planejamento de estoque

## 💡 Dicas de Resolução
1. **Identificar**: Subproblemas sobrepostos
2. **Formular**: Relação de recorrência clara
3. **Implementar**: Bottom-up para eficiência
4. **Otimizar**: Reduzir uso de memória quando possível 