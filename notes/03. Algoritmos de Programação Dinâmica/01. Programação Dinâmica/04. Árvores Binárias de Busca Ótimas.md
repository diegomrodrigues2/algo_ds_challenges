# 🌳 Árvores Binárias de Busca Ótimas (Optimal BST)

## 🎯 Definição do Problema
Dado um conjunto de chaves `k₁, k₂, ..., kₙ` com probabilidades de busca `p₁, p₂, ..., pₙ`, construir uma árvore binária de busca que minimize o custo médio de busca.

## 📊 Conceitos Fundamentais

### 🔑 Custo de Busca
- **Custo de um nó**: `profundidade(nó) × probabilidade(nó)`
- **Custo total**: Soma dos custos de todos os nós
- **Objetivo**: Minimizar custo médio esperado

### 🌲 Estrutura da Árvore
```
     kᵣ (raiz)
    /        \
   T₁        T₂
  /  \      /  \
kᵢ   kⱼ   kₘ   kₙ
```

### 📈 Relação de Recorrência
```
dp[i][j] = min(dp[i][r-1] + dp[r+1][j] + sum(p[i:j+1])) para r = i até j
```

## 🧩 Algoritmo de Programação Dinâmica

### 📊 Estrutura da Tabela
- **Dimensões**: `dp[n+1][n+1]`
- **dp[i][j]**: Custo mínimo da árvore com chaves `kᵢ` até `kⱼ`
- **root[i][j]**: Índice da raiz da árvore ótima

### 🔄 Preenchimento da Tabela
```python
# Para cada tamanho de subárvore
for length in range(1, n+1):
    # Para cada posição inicial
    for i in range(n-length+1):
        j = i + length - 1
        # Tentar cada chave como raiz
        for r in range(i, j+1):
            cost = dp[i][r-1] + dp[r+1][j] + sum_probabilities[i][j]
            if cost < dp[i][j]:
                dp[i][j] = cost
                root[i][j] = r
```

## 💻 Implementação Detalhada

### 🔧 Estruturas de Dados
```python
class OptimalBST:
    def __init__(self, keys, probabilities):
        self.keys = keys
        self.probabilities = probabilities
        self.n = len(keys)
        self.dp = [[0] * (self.n+1) for _ in range(self.n+1)]
        self.root = [[0] * (self.n+1) for _ in range(self.n+1)]
        self.sum_prob = self._compute_sum_probabilities()
```

### 📊 Cálculo de Probabilidades Acumuladas
```python
def _compute_sum_probabilities(self):
    """Calcula soma de probabilidades para cada intervalo"""
    sum_prob = [[0] * (self.n+1) for _ in range(self.n+1)]
    
    for i in range(self.n):
        sum_prob[i][i] = self.probabilities[i]
        for j in range(i+1, self.n):
            sum_prob[i][j] = sum_prob[i][j-1] + self.probabilities[j]
    
    return sum_prob
```

### 🎯 Construção da Árvore
```python
def construct_tree(self, i, j):
    """Constrói árvore recursivamente a partir da tabela root"""
    if i > j:
        return None
    
    r = self.root[i][j]
    node = TreeNode(self.keys[r])
    node.left = self.construct_tree(i, r-1)
    node.right = self.construct_tree(r+1, j)
    
    return node
```

## 📊 Análise de Complexidade

### ⏰ Complexidade Temporal
- **Preenchimento da tabela**: O(n³)
- **Cálculo de probabilidades**: O(n²)
- **Construção da árvore**: O(n)
- **Total**: O(n³)

### 💾 Complexidade Espacial
- **Tabela dp**: O(n²)
- **Tabela root**: O(n²)
- **Tabela sum_prob**: O(n²)
- **Total**: O(n²)

## 🎯 Otimizações Possíveis

### 🔧 Otimização de Knuth
```python
# Propriedade de monotonicidade
# root[i][j-1] ≤ root[i][j] ≤ root[i+1][j]

for length in range(1, n+1):
    for i in range(n-length+1):
        j = i + length - 1
        # Limitar busca da raiz
        start = root[i][j-1] if j > i else i
        end = root[i+1][j] if i < j else j
        
        for r in range(start, end+1):
            cost = dp[i][r-1] + dp[r+1][j] + sum_prob[i][j]
            if cost < dp[i][j]:
                dp[i][j] = cost
                root[i][j] = r
```

### ⚡ Otimização de Espaço
```python
# Usar apenas duas linhas da tabela
dp_prev = [0] * (n+1)
dp_curr = [0] * (n+1)

for length in range(1, n+1):
    for i in range(n-length+1):
        j = i + length - 1
        # Calcular dp_curr[i] usando dp_prev
        # Trocar arrays no final
```

## 🔍 Casos Especiais

### 📈 Probabilidades Iguais
- **Comportamento**: Árvore balanceada é ótima
- **Custo**: O(log n) por busca
- **Implementação**: Mais simples

### 📉 Probabilidades Extremas
- **Alta concentração**: Árvore degenerada pode ser ótima
- **Baixa dispersão**: Árvore balanceada é preferível
- **Análise**: Depende da distribuição específica

## 🎓 Aplicações Práticas

### 🔍 Sistemas de Busca
- **Dicionários**: Palavras com frequências conhecidas
- **Bancos de dados**: Índices com padrões de acesso
- **Compiladores**: Símbolos com frequências de uso

### 📊 Análise de Performance
- **Cache**: Otimização de acesso a memória
- **Networking**: Roteamento com padrões de tráfego
- **Machine Learning**: Árvores de decisão ótimas

## 💡 Dicas de Implementação

### 🎯 Identificação do Problema
- **Entrada**: Chaves ordenadas + probabilidades
- **Saída**: Estrutura de árvore ótima
- **Objetivo**: Minimizar custo esperado

### 🔧 Estruturas Auxiliares
- **Tabela de custos**: Para memoização
- **Tabela de raízes**: Para reconstrução
- **Soma de probabilidades**: Para cálculo eficiente

### ⚡ Otimizações Importantes
- **Ordem de preenchimento**: Diagonal por diagonal
- **Limites de busca**: Propriedade de monotonicidade
- **Estruturas de dados**: Arrays vs matrizes 