# ğŸŒ³ Ãrvores BinÃ¡rias de Busca Ã“timas (Optimal BST)

## ğŸ¯ DefiniÃ§Ã£o do Problema
Dado um conjunto de chaves `kâ‚, kâ‚‚, ..., kâ‚™` com probabilidades de busca `pâ‚, pâ‚‚, ..., pâ‚™`, construir uma Ã¡rvore binÃ¡ria de busca que minimize o custo mÃ©dio de busca.

## ğŸ“Š Conceitos Fundamentais

### ğŸ”‘ Custo de Busca
- **Custo de um nÃ³**: `profundidade(nÃ³) Ã— probabilidade(nÃ³)`
- **Custo total**: Soma dos custos de todos os nÃ³s
- **Objetivo**: Minimizar custo mÃ©dio esperado

### ğŸŒ² Estrutura da Ãrvore
```
     káµ£ (raiz)
    /        \
   Tâ‚        Tâ‚‚
  /  \      /  \
káµ¢   kâ±¼   kâ‚˜   kâ‚™
```

### ğŸ“ˆ RelaÃ§Ã£o de RecorrÃªncia
```
dp[i][j] = min(dp[i][r-1] + dp[r+1][j] + sum(p[i:j+1])) para r = i atÃ© j
```

## ğŸ§© Algoritmo de ProgramaÃ§Ã£o DinÃ¢mica

### ğŸ“Š Estrutura da Tabela
- **DimensÃµes**: `dp[n+1][n+1]`
- **dp[i][j]**: Custo mÃ­nimo da Ã¡rvore com chaves `káµ¢` atÃ© `kâ±¼`
- **root[i][j]**: Ãndice da raiz da Ã¡rvore Ã³tima

### ğŸ”„ Preenchimento da Tabela
```python
# Para cada tamanho de subÃ¡rvore
for length in range(1, n+1):
    # Para cada posiÃ§Ã£o inicial
    for i in range(n-length+1):
        j = i + length - 1
        # Tentar cada chave como raiz
        for r in range(i, j+1):
            cost = dp[i][r-1] + dp[r+1][j] + sum_probabilities[i][j]
            if cost < dp[i][j]:
                dp[i][j] = cost
                root[i][j] = r
```

## ğŸ’» ImplementaÃ§Ã£o Detalhada

### ğŸ”§ Estruturas de Dados
```python
class OptimalBST:
    def __init__(self, keys, probabilities):
        self.keys = keys
        self.probabilities = probabilities
        self.n = len(keys)
        self.dp = [[0] * (self.n+1) for _ in range(self.n+1)]
        self.root = [[0] * (self.n+1) for _ in range(self.n+1)]
        self.sum_prob = self._compute_sum_probabilities()
```

### ğŸ“Š CÃ¡lculo de Probabilidades Acumuladas
```python
def _compute_sum_probabilities(self):
    """Calcula soma de probabilidades para cada intervalo"""
    sum_prob = [[0] * (self.n+1) for _ in range(self.n+1)]
    
    for i in range(self.n):
        sum_prob[i][i] = self.probabilities[i]
        for j in range(i+1, self.n):
            sum_prob[i][j] = sum_prob[i][j-1] + self.probabilities[j]
    
    return sum_prob
```

### ğŸ¯ ConstruÃ§Ã£o da Ãrvore
```python
def construct_tree(self, i, j):
    """ConstrÃ³i Ã¡rvore recursivamente a partir da tabela root"""
    if i > j:
        return None
    
    r = self.root[i][j]
    node = TreeNode(self.keys[r])
    node.left = self.construct_tree(i, r-1)
    node.right = self.construct_tree(r+1, j)
    
    return node
```

## ğŸ“Š AnÃ¡lise de Complexidade

### â° Complexidade Temporal
- **Preenchimento da tabela**: O(nÂ³)
- **CÃ¡lculo de probabilidades**: O(nÂ²)
- **ConstruÃ§Ã£o da Ã¡rvore**: O(n)
- **Total**: O(nÂ³)

### ğŸ’¾ Complexidade Espacial
- **Tabela dp**: O(nÂ²)
- **Tabela root**: O(nÂ²)
- **Tabela sum_prob**: O(nÂ²)
- **Total**: O(nÂ²)

## ğŸ¯ OtimizaÃ§Ãµes PossÃ­veis

### ğŸ”§ OtimizaÃ§Ã£o de Knuth
```python
# Propriedade de monotonicidade
# root[i][j-1] â‰¤ root[i][j] â‰¤ root[i+1][j]

for length in range(1, n+1):
    for i in range(n-length+1):
        j = i + length - 1
        # Limitar busca da raiz
        start = root[i][j-1] if j > i else i
        end = root[i+1][j] if i < j else j
        
        for r in range(start, end+1):
            cost = dp[i][r-1] + dp[r+1][j] + sum_prob[i][j]
            if cost < dp[i][j]:
                dp[i][j] = cost
                root[i][j] = r
```

### âš¡ OtimizaÃ§Ã£o de EspaÃ§o
```python
# Usar apenas duas linhas da tabela
dp_prev = [0] * (n+1)
dp_curr = [0] * (n+1)

for length in range(1, n+1):
    for i in range(n-length+1):
        j = i + length - 1
        # Calcular dp_curr[i] usando dp_prev
        # Trocar arrays no final
```

## ğŸ” Casos Especiais

### ğŸ“ˆ Probabilidades Iguais
- **Comportamento**: Ãrvore balanceada Ã© Ã³tima
- **Custo**: O(log n) por busca
- **ImplementaÃ§Ã£o**: Mais simples

### ğŸ“‰ Probabilidades Extremas
- **Alta concentraÃ§Ã£o**: Ãrvore degenerada pode ser Ã³tima
- **Baixa dispersÃ£o**: Ãrvore balanceada Ã© preferÃ­vel
- **AnÃ¡lise**: Depende da distribuiÃ§Ã£o especÃ­fica

## ğŸ“ AplicaÃ§Ãµes PrÃ¡ticas

### ğŸ” Sistemas de Busca
- **DicionÃ¡rios**: Palavras com frequÃªncias conhecidas
- **Bancos de dados**: Ãndices com padrÃµes de acesso
- **Compiladores**: SÃ­mbolos com frequÃªncias de uso

### ğŸ“Š AnÃ¡lise de Performance
- **Cache**: OtimizaÃ§Ã£o de acesso a memÃ³ria
- **Networking**: Roteamento com padrÃµes de trÃ¡fego
- **Machine Learning**: Ãrvores de decisÃ£o Ã³timas

## ğŸ’¡ Dicas de ImplementaÃ§Ã£o

### ğŸ¯ IdentificaÃ§Ã£o do Problema
- **Entrada**: Chaves ordenadas + probabilidades
- **SaÃ­da**: Estrutura de Ã¡rvore Ã³tima
- **Objetivo**: Minimizar custo esperado

### ğŸ”§ Estruturas Auxiliares
- **Tabela de custos**: Para memoizaÃ§Ã£o
- **Tabela de raÃ­zes**: Para reconstruÃ§Ã£o
- **Soma de probabilidades**: Para cÃ¡lculo eficiente

### âš¡ OtimizaÃ§Ãµes Importantes
- **Ordem de preenchimento**: Diagonal por diagonal
- **Limites de busca**: Propriedade de monotonicidade
- **Estruturas de dados**: Arrays vs matrizes 