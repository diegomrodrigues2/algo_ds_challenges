# ğŸ” Depth-First Search (DFS)

## ğŸ¯ O que Ã© DFS?

**Depth-First Search** Ã© um algoritmo de exploraÃ§Ã£o de grafos que **prioriza a profundidade** sobre a largura. Explora um caminho atÃ© o final antes de voltar e tentar outro.

### ğŸŒŸ **EstratÃ©gia Central**
```
"VÃ¡ o mais fundo possÃ­vel, depois volte e tente outro caminho"
```

## ğŸ”„ Como Funciona

### ğŸ“Š **Processo de ExploraÃ§Ã£o**
1. **ğŸ¯ Escolha um vÃ©rtice inicial**
2. **ğŸ” Visite um vizinho nÃ£o visitado**
3. **â¬‡ï¸ VÃ¡ para esse vizinho** (recursÃ£o)
4. **â†©ï¸ Quando nÃ£o hÃ¡ mais opÃ§Ãµes, volte** (backtrack)
5. **ğŸ”„ Repita atÃ© visitar todos**

### ğŸ¨ **Analogia Simples**
> **Labirinto**: Como explorar um labirinto - sempre vire Ã  direita atÃ© nÃ£o poder mais, depois volte e tente outra direÃ§Ã£o.

## âš¡ Complexidade e Propriedades

### ğŸ“ˆ **AnÃ¡lise de Complexidade**
| Aspecto | Complexidade | ExplicaÃ§Ã£o |
|---------|--------------|------------|
| **â° Tempo** | O(V + E) | Visita cada vÃ©rtice e aresta uma vez |
| **ğŸ’¾ EspaÃ§o** | O(V) | Altura mÃ¡xima da pilha de recursÃ£o |
| **ğŸ§  MemÃ³ria** | O(V) | Para grafo completo pode ser O(VÂ²) |

### ğŸ” **Propriedades Fundamentais**
- **ğŸ¯ Completo**: Visita todos os vÃ©rtices alcanÃ§Ã¡veis
- **ğŸ”„ SistemÃ¡tico**: NÃ£o repete vÃ©rtices (com controle adequado)
- **ğŸ“Š Eficiente**: Cada aresta Ã© processada no mÃ¡ximo duas vezes

## âœ… Vantagens vs âŒ Desvantagens

| Aspecto | âœ… Vantagem | âŒ Desvantagem |
|---------|-------------|----------------|
| **ğŸ§  MemÃ³ria** | O(V) - eficiente | Pode estourar pilha em grafos profundos |
| **ğŸ” ExploraÃ§Ã£o** | Encontra caminhos longos rapidamente | Pode "perder-se" em caminhos longos |
| **âš¡ Velocidade** | RÃ¡pido para grafos esparsos | Lento para encontrar caminhos curtos |
| **ğŸ”„ Backtracking** | Natural e intuitivo | Pode ser ineficiente |

## ğŸ¯ AplicaÃ§Ãµes PrÃ¡ticas

### ğŸ” **ExploraÃ§Ã£o e Descoberta**
- **ğŸ® Jogos**: IA para exploraÃ§Ã£o de mapas
- **ğŸ§© Labirintos**: ResoluÃ§Ã£o automÃ¡tica
- **ğŸŒ Web Crawling**: IndexaÃ§Ã£o de pÃ¡ginas

### ğŸ“Š **AnÃ¡lise de Grafos**
- **ğŸ”— Conectividade**: Componentes conectados
- **ğŸ“ˆ Topologia**: OrdenaÃ§Ã£o de dependÃªncias
- **ğŸ¨ ColoraÃ§Ã£o**: Grafos bipartidos

### ğŸ—ï¸ **Sistemas Reais**
- **ğŸ”§ Compiladores**: AnÃ¡lise de dependÃªncias
- **ğŸ“¦ Build Systems**: OrdenaÃ§Ã£o de tarefas
- **ğŸŒ Redes**: AnÃ¡lise de conectividade

## ğŸ”„ Estados dos VÃ©rtices

### ğŸ¨ **Sistema de Cores**
- **ğŸŸ¢ Branco**: VÃ©rtice nÃ£o visitado
- **ğŸŸ¡ Cinza**: VÃ©rtice em processamento (na pilha)
- **âš« Preto**: VÃ©rtice completamente processado

### ğŸ“Š **TransiÃ§Ãµes**
```
ğŸŸ¢ Branco â†’ ğŸŸ¡ Cinza (quando visitado)
ğŸŸ¡ Cinza â†’ âš« Preto (quando processado)
```

## ğŸ¯ ComparaÃ§Ã£o com BFS

| Aspecto | ğŸ” DFS | ğŸ“Š BFS |
|---------|--------|--------|
| **ğŸ“Š Estrutura** | Pilha (LIFO) | Fila (FIFO) |
| **ğŸ¯ EstratÃ©gia** | Profundidade | Largura |
| **ğŸ’¾ MemÃ³ria** | O(V) | O(V) |
| **ğŸ” Melhor para** | Caminhos longos | Caminhos curtos |
| **ğŸ® AplicaÃ§Ã£o** | Backtracking | NavegaÃ§Ã£o |

## ğŸ’¡ Dicas de ImplementaÃ§Ã£o

### ğŸ¯ **Pontos-Chave**
- **ğŸ”„ Use recursÃ£o** para simplicidade
- **ğŸ“Š Mantenha controle** de vÃ©rtices visitados
- **âš¡ Considere iterativo** para grafos muito profundos
- **ğŸ¨ Use cores** para detecÃ§Ã£o de ciclos

### ğŸ”§ **OtimizaÃ§Ãµes**
- **ğŸ“Š Early termination**: Pare quando encontrar o objetivo
- **ğŸ¯ HeurÃ­sticas**: Direcione a busca com conhecimento do domÃ­nio
- **ğŸ’¾ MemoizaÃ§Ã£o**: Evite recÃ¡lculos em subproblemas 