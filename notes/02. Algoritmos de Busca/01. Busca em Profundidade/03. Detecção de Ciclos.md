# 🔍 Detecção de Ciclos com DFS

## 🎯 O que é Detecção de Ciclos?

**Detecção de ciclos** é o processo de identificar se um grafo contém **ciclos** (caminhos que voltam ao ponto inicial). DFS é especialmente eficiente para essa tarefa.

### 🌟 **Conceito Central**
```
Ciclo: A → B → C → A (caminho que retorna ao início)
```

## 🔄 Como DFS Detecta Ciclos

### 📊 **Estratégia Fundamental**
DFS detecta ciclos através do **sistema de cores** dos vértices:
- **🟢 Branco**: Não visitado
- **🟡 Cinza**: Em processamento (na pilha de recursão)
- **⚫ Preto**: Processado completamente

### 🎯 **Regra de Detecção**
```
Se encontrar um vértice CINZA durante a busca → CICLO DETECTADO
```

## 🎨 Sistema de Cores Detalhado

### 📊 **Estados e Transições**
| Estado | Significado | Quando Ocorre |
|--------|-------------|---------------|
| **🟢 Branco** | Não visitado | Estado inicial de todos os vértices |
| **🟡 Cinza** | Em processamento | Vértice na pilha de recursão |
| **⚫ Preto** | Processado | Vértice completamente explorado |

### 🔄 **Fluxo de Transições**
```
🟢 Branco → 🟡 Cinza (quando DFS entra no vértice)
🟡 Cinza → ⚫ Preto (quando DFS sai do vértice)
```

## 📝 Implementação Básica

### 🔍 **Detecção em Grafos Direcionados**
```python
def has_cycle(grafo):
    cores = {vertice: 'branco' for vertice in grafo}
    
    def dfs_detect_cycle(vertice):
        cores[vertice] = 'cinza'  # Entrando no vértice
        
        for vizinho in grafo[vertice]:
            if cores[vizinho] == 'cinza':
                return True  # Ciclo detectado!
            elif cores[vizinho] == 'branco':
                if dfs_detect_cycle(vizinho):
                    return True
        
        cores[vertice] = 'preto'  # Saindo do vértice
        return False
    
    # Testa todos os vértices (para grafos desconectados)
    for vertice in grafo:
        if cores[vertice] == 'branco':
            if dfs_detect_cycle(vertice):
                return True
    
    return False
```

### 🔍 **Detecção em Grafos Não-Direcionados**
```python
def has_cycle_undirected(grafo):
    visitados = set()
    
    def dfs_detect_cycle(vertice, pai):
        visitados.add(vertice)
        
        for vizinho in grafo[vertice]:
            if vizinho not in visitados:
                if dfs_detect_cycle(vizinho, vertice):
                    return True
            elif vizinho != pai:  # Evita voltar pelo mesmo caminho
                return True  # Ciclo detectado
        
        return False
    
    for vertice in grafo:
        if vertice not in visitados:
            if dfs_detect_cycle(vertice, None):
                return True
    
    return False
```

## 📊 Tipos de Ciclos

### 🔄 **Ciclos em Grafos Direcionados**
- **🔄 Self-loop**: A → A
- **🔄 Ciclo simples**: A → B → C → A
- **🔄 Ciclo complexo**: A → B → C → D → B

### 🔄 **Ciclos em Grafos Não-Direcionados**
- **🔄 Ciclo simples**: A — B — C — A
- **🔄 Ciclo com cruzamentos**: A — B — C — D — A

## 🎯 Aplicações da Detecção de Ciclos

### 📊 **Ordenação Topológica**
- **🎯 Objetivo**: Ordenar vértices respeitando dependências
- **❌ Problema**: Ciclos impedem ordenação
- **✅ Solução**: Detectar ciclos primeiro

### 🔧 **Sistemas de Build**
- **📦 Dependências**: A depende de B, B depende de C
- **❌ Ciclo**: A → B → C → A (impossível de resolver)
- **✅ Detecção**: Identificar dependências circulares

### 🏗️ **Análise de Dependências**
- **📚 Cursos**: Pré-requisitos acadêmicos
- **💼 Projetos**: Tarefas que dependem umas das outras
- **🔗 Redes**: Conexões que formam loops

## ⚡ Complexidade e Performance

### 📈 **Análise de Complexidade**
| Aspecto | Complexidade | Explicação |
|---------|--------------|------------|
| **⏰ Tempo** | O(V + E) | Visita cada vértice e aresta uma vez |
| **💾 Espaço** | O(V) | Pilha de recursão + cores |
| **🧠 Memória** | O(V) | Para armazenar estados dos vértices |

### 🔧 **Otimizações**
- **⚡ Early termination**: Pare no primeiro ciclo encontrado
- **💾 Union-Find**: Para grafos não-direcionados
- **📊 Tarjan's algorithm**: Para componentes fortemente conectados

## 🎯 Variações Importantes

### 🔍 **Contagem de Ciclos**
```python
def count_cycles(grafo):
    cores = {vertice: 'branco' for vertice in grafo}
    ciclos = 0
    
    def dfs_count_cycles(vertice):
        nonlocal ciclos
        cores[vertice] = 'cinza'
        
        for vizinho in grafo[vertice]:
            if cores[vizinho] == 'cinza':
                ciclos += 1
            elif cores[vizinho] == 'branco':
                dfs_count_cycles(vizinho)
        
        cores[vertice] = 'preto'
    
    for vertice in grafo:
        if cores[vertice] == 'branco':
            dfs_count_cycles(vertice)
    
    return ciclos
```

### 🔍 **Encontrar Ciclos**
```python
def find_cycle(grafo):
    cores = {vertice: 'branco' for vertice in grafo}
    caminho = []
    
    def dfs_find_cycle(vertice):
        cores[vertice] = 'cinza'
        caminho.append(vertice)
        
        for vizinho in grafo[vertice]:
            if cores[vizinho] == 'cinza':
                # Encontrou ciclo, retorna o caminho
                idx = caminho.index(vizinho)
                return caminho[idx:] + [vizinho]
            elif cores[vizinho] == 'branco':
                resultado = dfs_find_cycle(vizinho)
                if resultado:
                    return resultado
        
        cores[vertice] = 'preto'
        caminho.pop()
        return None
    
    for vertice in grafo:
        if cores[vertice] == 'branco':
            ciclo = dfs_find_cycle(vertice)
            if ciclo:
                return ciclo
    
    return None
```

## 💡 Dicas de Implementação

### 🎯 **Pontos-Chave**
- **🎨 Use cores**: Sistema de 3 estados é fundamental
- **🔄 Considere direção**: Grafos direcionados vs não-direcionados
- **⚡ Early termination**: Pare no primeiro ciclo
- **📊 Grafos desconectados**: Teste todos os componentes

### 🔧 **Casos Especiais**
- **🔄 Self-loops**: Ciclos de tamanho 1
- **📊 Grafos vazios**: Sem vértices
- **🔗 Grafos desconectados**: Múltiplos componentes
- **🎯 Grafos bipartidos**: Sem ciclos ímpares 