# ðŸŽ¨ AplicaÃ§Ãµes AvanÃ§adas do DFS

## ðŸŽ¯ VisÃ£o Geral

DFS Ã© fundamental para **muitos algoritmos avanÃ§ados** de grafos. Sua capacidade de explorar profundamente torna-o ideal para problemas complexos de conectividade e dependÃªncia.

## ðŸ“Š OrdenaÃ§Ã£o TopolÃ³gica

### ðŸŒŸ **O que Ã©?**
**OrdenaÃ§Ã£o topolÃ³gica** Ã© uma ordenaÃ§Ã£o linear dos vÃ©rtices de um DAG (Directed Acyclic Graph) onde cada vÃ©rtice vem **antes** de todos os seus sucessores.

### ðŸŽ¯ **AplicaÃ§Ã£o PrÃ¡tica**
```
PrÃ©-requisitos: CÃ¡lculo â†’ Ãlgebra â†’ Geometria
Ordem: Geometria â†’ Ãlgebra â†’ CÃ¡lculo
```

### ðŸ“ **ImplementaÃ§Ã£o com DFS**
```python
def topological_sort(grafo):
    visitados = set()
    pilha = []
    
    def dfs_topological(vertice):
        visitados.add(vertice)
        
        for vizinho in grafo[vertice]:
            if vizinho not in visitados:
                dfs_topological(vizinho)
        
        pilha.append(vertice)  # Adiciona no final (LIFO)
    
    for vertice in grafo:
        if vertice not in visitados:
            dfs_topological(vertice)
    
    return pilha[::-1]  # Inverte para ordem correta
```

### âœ… **Vantagens do DFS**
- **ðŸŽ¯ Simplicidade**: ImplementaÃ§Ã£o direta
- **ðŸ“Š EficiÃªncia**: O(V + E) - linear
- **ðŸ”„ Natural**: Backtracking automÃ¡tico

## ðŸ”— Componentes Fortemente Conectados (SCC)

### ðŸŒŸ **O que sÃ£o?**
**SCCs** sÃ£o subgrafos onde cada vÃ©rtice pode alcanÃ§ar todos os outros vÃ©rtices do mesmo componente.

### ðŸŽ¯ **Algoritmo de Kosaraju**
```python
def kosaraju_scc(grafo):
    # Passo 1: DFS para ordenar por tempo de finalizaÃ§Ã£o
    visitados = set()
    ordem = []
    
    def dfs_ordem(vertice):
        visitados.add(vertice)
        for vizinho in grafo[vertice]:
            if vizinho not in visitados:
                dfs_ordem(vizinho)
        ordem.append(vertice)
    
    for vertice in grafo:
        if vertice not in visitados:
            dfs_ordem(vertice)
    
    # Passo 2: Grafo transposto
    grafo_t = {vertice: [] for vertice in grafo}
    for vertice in grafo:
        for vizinho in grafo[vertice]:
            grafo_t[vizinho].append(vertice)
    
    # Passo 3: DFS no grafo transposto
    visitados = set()
    sccs = []
    
    def dfs_scc(vertice, componente):
        visitados.add(vertice)
        componente.append(vertice)
        for vizinho in grafo_t[vertice]:
            if vizinho not in visitados:
                dfs_scc(vizinho, componente)
    
    for vertice in reversed(ordem):
        if vertice not in visitados:
            componente = []
            dfs_scc(vertice, componente)
            sccs.append(componente)
    
    return sccs
```

## ðŸŒ‰ Pontes e Pontos de ArticulaÃ§Ã£o

### ðŸŒŸ **DefiniÃ§Ãµes**
- **ðŸŒ‰ Ponte**: Aresta cuja remoÃ§Ã£o desconecta o grafo
- **ðŸŽ¯ Ponto de ArticulaÃ§Ã£o**: VÃ©rtice cuja remoÃ§Ã£o desconecta o grafo

### ðŸ“ **Algoritmo de Tarjan**
```python
def find_bridges(grafo):
    visitados = set()
    tempo = 0
    tempo_descoberta = {}
    tempo_menor = {}
    pontes = []
    
    def dfs_bridges(vertice, pai):
        nonlocal tempo
        visitados.add(vertice)
        tempo_descoberta[vertice] = tempo_menor[vertice] = tempo
        tempo += 1
        
        for vizinho in grafo[vertice]:
            if vizinho == pai:
                continue
            if vizinho not in visitados:
                dfs_bridges(vizinho, vertice)
                tempo_menor[vertice] = min(tempo_menor[vertice], tempo_menor[vizinho])
                
                # Verifica se Ã© ponte
                if tempo_menor[vizinho] > tempo_descoberta[vertice]:
                    pontes.append((vertice, vizinho))
            else:
                tempo_menor[vertice] = min(tempo_menor[vertice], tempo_descoberta[vizinho])
    
    for vertice in grafo:
        if vertice not in visitados:
            dfs_bridges(vertice, None)
    
    return pontes
```

## ðŸŽ¨ ColoraÃ§Ã£o de Grafos

### ðŸŒŸ **Problema**
Colorir vÃ©rtices de um grafo de forma que **vÃ©rtices adjacentes** tenham **cores diferentes**.

### ðŸ“ **ImplementaÃ§Ã£o com DFS**
```python
def graph_coloring(grafo, max_cores):
    cores = {}
    
    def is_safe(vertice, cor):
        for vizinho in grafo[vertice]:
            if cores.get(vizinho) == cor:
                return False
        return True
    
    def dfs_coloring(vertice):
        if vertice >= len(grafo):
            return True
        
        for cor in range(max_cores):
            if is_safe(vertice, cor):
                cores[vertice] = cor
                if dfs_coloring(vertice + 1):
                    return True
                cores[vertice] = None  # Backtrack
        
        return False
    
    if dfs_coloring(0):
        return cores
    return None
```

## ðŸ” Backtracking AvanÃ§ado

### ðŸŒŸ **Sudoku Solver**
```python
def solve_sudoku(board):
    def is_valid(board, row, col, num):
        # Verifica linha
        for x in range(9):
            if board[row][x] == num:
                return False
        
        # Verifica coluna
        for x in range(9):
            if board[x][col] == num:
                return False
        
        # Verifica caixa 3x3
        start_row, start_col = 3 * (row // 3), 3 * (col // 3)
        for i in range(3):
            for j in range(3):
                if board[i + start_row][j + start_col] == num:
                    return False
        
        return True
    
    def solve(board):
        for i in range(9):
            for j in range(9):
                if board[i][j] == 0:
                    for num in range(1, 10):
                        if is_valid(board, i, j, num):
                            board[i][j] = num
                            if solve(board):
                                return True
                            board[i][j] = 0  # Backtrack
                    return False
        return True
    
    solve(board)
    return board
```

## ðŸŽ® Problemas de ExploraÃ§Ã£o

### ðŸŒŸ **N-Queens**
```python
def solve_n_queens(n):
    def is_safe(board, row, col):
        # Verifica linha
        for j in range(col):
            if board[row][j] == 'Q':
                return False
        
        # Verifica diagonal superior esquerda
        for i, j in zip(range(row, -1, -1), range(col, -1, -1)):
            if board[i][j] == 'Q':
                return False
        
        # Verifica diagonal inferior esquerda
        for i, j in zip(range(row, n, 1), range(col, -1, -1)):
            if board[i][j] == 'Q':
                return False
        
        return True
    
    def solve_queens(board, col):
        if col >= n:
            return True
        
        for row in range(n):
            if is_safe(board, row, col):
                board[row][col] = 'Q'
                if solve_queens(board, col + 1):
                    return True
                board[row][col] = '.'  # Backtrack
        
        return False
    
    board = [['.' for _ in range(n)] for _ in range(n)]
    solve_queens(board, 0)
    return board
```

## âš¡ OtimizaÃ§Ãµes AvanÃ§adas

### ðŸ”§ **Iterative Deepening DFS**
```python
def iddfs(grafo, inicio, objetivo, max_depth):
    def dfs_limitada(vertice, profundidade, visitados):
        if profundidade == 0:
            return vertice == objetivo
        
        if vertice == objetivo:
            return True
        
        visitados.add(vertice)
        
        for vizinho in grafo[vertice]:
            if vizinho not in visitados:
                if dfs_limitada(vizinho, profundidade - 1, visitados):
                    return True
        
        return False
    
    for profundidade in range(max_depth + 1):
        if dfs_limitada(inicio, profundidade, set()):
            return profundidade
    
    return -1  # NÃ£o encontrado
```

### ðŸ”§ **DFS com MemoizaÃ§Ã£o**
```python
def dfs_memoizado(grafo, inicio, objetivo, memo=None):
    if memo is None:
        memo = {}
    
    if inicio in memo:
        return memo[inicio]
    
    if inicio == objetivo:
        memo[inicio] = True
        return True
    
    memo[inicio] = False
    for vizinho in grafo[inicio]:
        if dfs_memoizado(grafo, vizinho, objetivo, memo):
            memo[inicio] = True
            return True
    
    return False
```

## ðŸ’¡ Dicas de ImplementaÃ§Ã£o

### ðŸŽ¯ **Pontos-Chave**
- **ðŸ”„ Backtracking**: Natural em DFS recursivo
- **ðŸ“Š Estados**: Mantenha controle de estados visitados
- **âš¡ Early termination**: Pare quando encontrar soluÃ§Ã£o
- **ðŸ’¾ MemoizaÃ§Ã£o**: Cache resultados para evitar recÃ¡lculos

### ðŸ”§ **OtimizaÃ§Ãµes**
- **ðŸŽ¯ HeurÃ­sticas**: Direcione a busca com conhecimento do domÃ­nio
- **ðŸ“Š Bidirecional**: Busca de ambos os lados
- **ðŸ”„ Iterative deepening**: Combine com BFS
- **ðŸ’¾ MemÃ³ria**: Use estruturas eficientes para grandes grafos 