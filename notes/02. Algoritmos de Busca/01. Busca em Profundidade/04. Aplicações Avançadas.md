# 🎨 Aplicações Avançadas do DFS

## 🎯 Visão Geral

DFS é fundamental para **muitos algoritmos avançados** de grafos. Sua capacidade de explorar profundamente torna-o ideal para problemas complexos de conectividade e dependência.

## 📊 Ordenação Topológica

### 🌟 **O que é?**
**Ordenação topológica** é uma ordenação linear dos vértices de um DAG (Directed Acyclic Graph) onde cada vértice vem **antes** de todos os seus sucessores.

### 🎯 **Aplicação Prática**
```
Pré-requisitos: Cálculo → Álgebra → Geometria
Ordem: Geometria → Álgebra → Cálculo
```

### 📝 **Implementação com DFS**
```python
def topological_sort(grafo):
    visitados = set()
    pilha = []
    
    def dfs_topological(vertice):
        visitados.add(vertice)
        
        for vizinho in grafo[vertice]:
            if vizinho not in visitados:
                dfs_topological(vizinho)
        
        pilha.append(vertice)  # Adiciona no final (LIFO)
    
    for vertice in grafo:
        if vertice not in visitados:
            dfs_topological(vertice)
    
    return pilha[::-1]  # Inverte para ordem correta
```

### ✅ **Vantagens do DFS**
- **🎯 Simplicidade**: Implementação direta
- **📊 Eficiência**: O(V + E) - linear
- **🔄 Natural**: Backtracking automático

## 🔗 Componentes Fortemente Conectados (SCC)

### 🌟 **O que são?**
**SCCs** são subgrafos onde cada vértice pode alcançar todos os outros vértices do mesmo componente.

### 🎯 **Algoritmo de Kosaraju**
```python
def kosaraju_scc(grafo):
    # Passo 1: DFS para ordenar por tempo de finalização
    visitados = set()
    ordem = []
    
    def dfs_ordem(vertice):
        visitados.add(vertice)
        for vizinho in grafo[vertice]:
            if vizinho not in visitados:
                dfs_ordem(vizinho)
        ordem.append(vertice)
    
    for vertice in grafo:
        if vertice not in visitados:
            dfs_ordem(vertice)
    
    # Passo 2: Grafo transposto
    grafo_t = {vertice: [] for vertice in grafo}
    for vertice in grafo:
        for vizinho in grafo[vertice]:
            grafo_t[vizinho].append(vertice)
    
    # Passo 3: DFS no grafo transposto
    visitados = set()
    sccs = []
    
    def dfs_scc(vertice, componente):
        visitados.add(vertice)
        componente.append(vertice)
        for vizinho in grafo_t[vertice]:
            if vizinho not in visitados:
                dfs_scc(vizinho, componente)
    
    for vertice in reversed(ordem):
        if vertice not in visitados:
            componente = []
            dfs_scc(vertice, componente)
            sccs.append(componente)
    
    return sccs
```

## 🌉 Pontes e Pontos de Articulação

### 🌟 **Definições**
- **🌉 Ponte**: Aresta cuja remoção desconecta o grafo
- **🎯 Ponto de Articulação**: Vértice cuja remoção desconecta o grafo

### 📝 **Algoritmo de Tarjan**
```python
def find_bridges(grafo):
    visitados = set()
    tempo = 0
    tempo_descoberta = {}
    tempo_menor = {}
    pontes = []
    
    def dfs_bridges(vertice, pai):
        nonlocal tempo
        visitados.add(vertice)
        tempo_descoberta[vertice] = tempo_menor[vertice] = tempo
        tempo += 1
        
        for vizinho in grafo[vertice]:
            if vizinho == pai:
                continue
            if vizinho not in visitados:
                dfs_bridges(vizinho, vertice)
                tempo_menor[vertice] = min(tempo_menor[vertice], tempo_menor[vizinho])
                
                # Verifica se é ponte
                if tempo_menor[vizinho] > tempo_descoberta[vertice]:
                    pontes.append((vertice, vizinho))
            else:
                tempo_menor[vertice] = min(tempo_menor[vertice], tempo_descoberta[vizinho])
    
    for vertice in grafo:
        if vertice not in visitados:
            dfs_bridges(vertice, None)
    
    return pontes
```

## 🎨 Coloração de Grafos

### 🌟 **Problema**
Colorir vértices de um grafo de forma que **vértices adjacentes** tenham **cores diferentes**.

### 📝 **Implementação com DFS**
```python
def graph_coloring(grafo, max_cores):
    cores = {}
    
    def is_safe(vertice, cor):
        for vizinho in grafo[vertice]:
            if cores.get(vizinho) == cor:
                return False
        return True
    
    def dfs_coloring(vertice):
        if vertice >= len(grafo):
            return True
        
        for cor in range(max_cores):
            if is_safe(vertice, cor):
                cores[vertice] = cor
                if dfs_coloring(vertice + 1):
                    return True
                cores[vertice] = None  # Backtrack
        
        return False
    
    if dfs_coloring(0):
        return cores
    return None
```

## 🔍 Backtracking Avançado

### 🌟 **Sudoku Solver**
```python
def solve_sudoku(board):
    def is_valid(board, row, col, num):
        # Verifica linha
        for x in range(9):
            if board[row][x] == num:
                return False
        
        # Verifica coluna
        for x in range(9):
            if board[x][col] == num:
                return False
        
        # Verifica caixa 3x3
        start_row, start_col = 3 * (row // 3), 3 * (col // 3)
        for i in range(3):
            for j in range(3):
                if board[i + start_row][j + start_col] == num:
                    return False
        
        return True
    
    def solve(board):
        for i in range(9):
            for j in range(9):
                if board[i][j] == 0:
                    for num in range(1, 10):
                        if is_valid(board, i, j, num):
                            board[i][j] = num
                            if solve(board):
                                return True
                            board[i][j] = 0  # Backtrack
                    return False
        return True
    
    solve(board)
    return board
```

## 🎮 Problemas de Exploração

### 🌟 **N-Queens**
```python
def solve_n_queens(n):
    def is_safe(board, row, col):
        # Verifica linha
        for j in range(col):
            if board[row][j] == 'Q':
                return False
        
        # Verifica diagonal superior esquerda
        for i, j in zip(range(row, -1, -1), range(col, -1, -1)):
            if board[i][j] == 'Q':
                return False
        
        # Verifica diagonal inferior esquerda
        for i, j in zip(range(row, n, 1), range(col, -1, -1)):
            if board[i][j] == 'Q':
                return False
        
        return True
    
    def solve_queens(board, col):
        if col >= n:
            return True
        
        for row in range(n):
            if is_safe(board, row, col):
                board[row][col] = 'Q'
                if solve_queens(board, col + 1):
                    return True
                board[row][col] = '.'  # Backtrack
        
        return False
    
    board = [['.' for _ in range(n)] for _ in range(n)]
    solve_queens(board, 0)
    return board
```

## ⚡ Otimizações Avançadas

### 🔧 **Iterative Deepening DFS**
```python
def iddfs(grafo, inicio, objetivo, max_depth):
    def dfs_limitada(vertice, profundidade, visitados):
        if profundidade == 0:
            return vertice == objetivo
        
        if vertice == objetivo:
            return True
        
        visitados.add(vertice)
        
        for vizinho in grafo[vertice]:
            if vizinho not in visitados:
                if dfs_limitada(vizinho, profundidade - 1, visitados):
                    return True
        
        return False
    
    for profundidade in range(max_depth + 1):
        if dfs_limitada(inicio, profundidade, set()):
            return profundidade
    
    return -1  # Não encontrado
```

### 🔧 **DFS com Memoização**
```python
def dfs_memoizado(grafo, inicio, objetivo, memo=None):
    if memo is None:
        memo = {}
    
    if inicio in memo:
        return memo[inicio]
    
    if inicio == objetivo:
        memo[inicio] = True
        return True
    
    memo[inicio] = False
    for vizinho in grafo[inicio]:
        if dfs_memoizado(grafo, vizinho, objetivo, memo):
            memo[inicio] = True
            return True
    
    return False
```

## 💡 Dicas de Implementação

### 🎯 **Pontos-Chave**
- **🔄 Backtracking**: Natural em DFS recursivo
- **📊 Estados**: Mantenha controle de estados visitados
- **⚡ Early termination**: Pare quando encontrar solução
- **💾 Memoização**: Cache resultados para evitar recálculos

### 🔧 **Otimizações**
- **🎯 Heurísticas**: Direcione a busca com conhecimento do domínio
- **📊 Bidirecional**: Busca de ambos os lados
- **🔄 Iterative deepening**: Combine com BFS
- **💾 Memória**: Use estruturas eficientes para grandes grafos 