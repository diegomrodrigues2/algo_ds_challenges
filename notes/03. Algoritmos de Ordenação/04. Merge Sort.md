# 🔄 Merge Sort

## 🎯 Estratégia
**Divide-and-conquer**: Divide array ao meio, ordena recursivamente, combina resultados

### 🔄 Algoritmo
1. **Divide**: Array em duas metades
2. **Conquista**: Ordena cada metade recursivamente
3. **Combina**: Mescla as duas metades ordenadas

## 🔧 Implementação

### 📊 Merge Sort Principal
```python
def merge_sort(A, a, b):
    if b - a <= 1:
        return
    c = (a + b) // 2  # Ponto médio
    merge_sort(A, a, c)  # Ordena metade esquerda
    merge_sort(A, c, b)  # Ordena metade direita
    merge(A, a, c, b)    # Combina resultados
```

### 🔗 Merge (Two-Finger Algorithm)
```python
def merge(A, a, c, b):
    if c <= a or b <= c:
        return
    if A[c-1] <= A[c]:
        return  # Já ordenado
    
    # Escolhe maior elemento do final
    if A[c-1] > A[b-1]:
        A[c-1], A[b-1] = A[b-1], A[c-1]
        merge(A, a, c, b-1)
    else:
        merge(A, a, c-1, b)
```

## ⚡ Análise de Complexidade

### 📈 Merge
- **Recursão**: T(n) = T(n-1) + O(1)
- **Solução**: T(n) = O(n)
- **Intuição**: Cada elemento visitado uma vez

### 🎯 Merge Sort
- **Recursão**: T(n) = 2T(n/2) + O(n)
- **Solução**: T(n) = O(n log n)
- **Prova**: Substituição com T(n) = cn log n

## 🔍 Exemplo Visual
```
[7,1,5,6,2,4,9,3] → [7,1,5,6] [2,4,9,3]
                    ↓
                [1,5,6,7] [2,3,4,9]
                    ↓
                [1,2,3,4,5,6,7,9]
```

## ✅ Vantagens
- **Complexidade**: O(n log n) garantido
- **Estável**: Mantém ordem relativa
- **Previsível**: Performance consistente
- **Paralelizável**: Metades independentes

## ❌ Limitações
- **Espaço**: Requer O(n) espaço extra
- **Cache**: Não aproveita localidade
- **Overhead**: Recursão para arrays pequenos
- **Complexidade**: Mais difícil de implementar

## 🎯 Casos de Uso
- **Arrays grandes**: n > 1000 elementos
- **Estabilidade necessária**: Ordem relativa importante
- **Performance garantida**: Quando O(n log n) é essencial
- **Implementações de linguagens**: Python, Java, C++

## 💡 Insights Teóricos
- **Divide-and-conquer**: Padrão fundamental
- **Recorrência**: T(n) = aT(n/b) + f(n)
- **Master Theorem**: Solução automática para recorrências
- **Two-finger**: Técnica eficiente para merge
- **Logaritmo**: Resultado natural de divisão binária

## 🔧 Otimizações
- **Insertion sort**: Para subarrays pequenos (n < 10)
- **Merge in-place**: Evita espaço extra
- **Bottom-up**: Versão iterativa
- **Natural merge**: Aproveita ordenação parcial 