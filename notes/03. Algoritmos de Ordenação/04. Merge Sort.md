# ğŸ”„ Merge Sort

## ğŸ¯ EstratÃ©gia
**Divide-and-conquer**: Divide array ao meio, ordena recursivamente, combina resultados

### ğŸ”„ Algoritmo
1. **Divide**: Array em duas metades
2. **Conquista**: Ordena cada metade recursivamente
3. **Combina**: Mescla as duas metades ordenadas

## ğŸ”§ ImplementaÃ§Ã£o

### ğŸ“Š Merge Sort Principal
```python
def merge_sort(A, a, b):
    if b - a <= 1:
        return
    c = (a + b) // 2  # Ponto mÃ©dio
    merge_sort(A, a, c)  # Ordena metade esquerda
    merge_sort(A, c, b)  # Ordena metade direita
    merge(A, a, c, b)    # Combina resultados
```

### ğŸ”— Merge (Two-Finger Algorithm)
```python
def merge(A, a, c, b):
    if c <= a or b <= c:
        return
    if A[c-1] <= A[c]:
        return  # JÃ¡ ordenado
    
    # Escolhe maior elemento do final
    if A[c-1] > A[b-1]:
        A[c-1], A[b-1] = A[b-1], A[c-1]
        merge(A, a, c, b-1)
    else:
        merge(A, a, c-1, b)
```

## âš¡ AnÃ¡lise de Complexidade

### ğŸ“ˆ Merge
- **RecursÃ£o**: T(n) = T(n-1) + O(1)
- **SoluÃ§Ã£o**: T(n) = O(n)
- **IntuiÃ§Ã£o**: Cada elemento visitado uma vez

### ğŸ¯ Merge Sort
- **RecursÃ£o**: T(n) = 2T(n/2) + O(n)
- **SoluÃ§Ã£o**: T(n) = O(n log n)
- **Prova**: SubstituiÃ§Ã£o com T(n) = cn log n

## ğŸ” Exemplo Visual
```
[7,1,5,6,2,4,9,3] â†’ [7,1,5,6] [2,4,9,3]
                    â†“
                [1,5,6,7] [2,3,4,9]
                    â†“
                [1,2,3,4,5,6,7,9]
```

## âœ… Vantagens
- **Complexidade**: O(n log n) garantido
- **EstÃ¡vel**: MantÃ©m ordem relativa
- **PrevisÃ­vel**: Performance consistente
- **ParalelizÃ¡vel**: Metades independentes

## âŒ LimitaÃ§Ãµes
- **EspaÃ§o**: Requer O(n) espaÃ§o extra
- **Cache**: NÃ£o aproveita localidade
- **Overhead**: RecursÃ£o para arrays pequenos
- **Complexidade**: Mais difÃ­cil de implementar

## ğŸ¯ Casos de Uso
- **Arrays grandes**: n > 1000 elementos
- **Estabilidade necessÃ¡ria**: Ordem relativa importante
- **Performance garantida**: Quando O(n log n) Ã© essencial
- **ImplementaÃ§Ãµes de linguagens**: Python, Java, C++

## ğŸ’¡ Insights TeÃ³ricos
- **Divide-and-conquer**: PadrÃ£o fundamental
- **RecorrÃªncia**: T(n) = aT(n/b) + f(n)
- **Master Theorem**: SoluÃ§Ã£o automÃ¡tica para recorrÃªncias
- **Two-finger**: TÃ©cnica eficiente para merge
- **Logaritmo**: Resultado natural de divisÃ£o binÃ¡ria

## ğŸ”§ OtimizaÃ§Ãµes
- **Insertion sort**: Para subarrays pequenos (n < 10)
- **Merge in-place**: Evita espaÃ§o extra
- **Bottom-up**: VersÃ£o iterativa
- **Natural merge**: Aproveita ordenaÃ§Ã£o parcial 