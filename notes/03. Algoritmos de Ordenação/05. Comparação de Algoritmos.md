# ⚖️ Comparação de Algoritmos de Ordenação

## 📊 Tabela de Complexidade

| Algoritmo | Pior Caso | Melhor Caso | Caso Médio | Espaço | Estável |
|-----------|-----------|-------------|------------|--------|---------|
| **Permutation Sort** | O(n!·n) | O(n!·n) | O(n!·n) | O(1) | ❌ |
| **Selection Sort** | O(n²) | O(n²) | O(n²) | O(1) | ✅ |
| **Insertion Sort** | O(n²) | O(n) | O(n²) | O(1) | ✅ |
| **Merge Sort** | O(n log n) | O(n log n) | O(n log n) | O(n) | ✅ |

## 🎯 Características dos Algoritmos

### 🔄 Permutation Sort
- **Estratégia**: Testa todas as permutações possíveis
- **Complexidade**: O(n!·n) - exponencial
- **Uso**: Apenas educacional, nunca prático
- **Correção**: Trivial de provar

### 🎯 Selection Sort
- **Estratégia**: Seleciona maior elemento e coloca no final
- **Complexidade**: O(n²) sempre
- **Vantagem**: Mínimo de trocas (n-1)
- **Implementação**: Recursiva ou iterativa

### 📝 Insertion Sort
- **Estratégia**: Insere cada elemento na posição correta
- **Complexidade**: O(n²) pior caso, O(n) melhor caso
- **Vantagem**: Eficiente para arrays quase ordenados
- **Uso**: Subarrays pequenos em algoritmos híbridos

### 🔄 Merge Sort
- **Estratégia**: Divide-and-conquer com merge
- **Complexidade**: O(n log n) sempre
- **Vantagem**: Performance garantida e estável
- **Implementação**: Recursiva com two-finger merge

## 🔄 Trade-offs Fundamentais

### ⚡ Velocidade vs Simplicidade
- **Simples**: Selection/Insertion Sort
- **Rápido**: Merge Sort
- **Híbrido**: Timsort (Python), Introsort (C++)

### 💾 Espaço vs Tempo
- **In-place**: Selection, Insertion Sort
- **Extra space**: Merge Sort
- **Trade-off**: Localidade vs complexidade

### 🎯 Estabilidade vs Performance
- **Estável**: Insertion, Merge Sort
- **Não-estável**: Selection Sort
- **Importância**: Para objetos com chaves iguais

## 🚀 Aplicações Práticas

### 📱 Implementações de Linguagens
- **Python**: Timsort (merge + insertion)
- **Java**: Dual-pivot quicksort
- **C++**: Introsort (quick + heap + insertion)
- **C**: qsort (quicksort)

### 🎯 Escolha do Algoritmo
- **n < 50**: Insertion Sort
- **50 < n < 1000**: Quick Sort
- **n > 1000**: Merge Sort ou híbrido
- **Estabilidade necessária**: Merge Sort

## 💡 Insights Teóricos

### 📈 Limite Inferior
- **Comparação**: Ω(n log n) para algoritmos baseados em comparação
- **Prova**: Árvore de decisão com n! folhas
- **Conclusão**: Merge Sort é ótimo

### 🔄 Recorrências
- **Selection**: T(n) = T(n-1) + O(n) → O(n²)
- **Merge**: T(n) = 2T(n/2) + O(n) → O(n log n)
- **Método**: Substituição ou Master Theorem

### 🎯 Padrões de Design
- **Iterativo**: Selection, Insertion
- **Recursivo**: Merge Sort
- **Divide-and-conquer**: Merge Sort
- **Greedy**: Selection Sort

## 🔧 Otimizações Modernas
- **Híbridos**: Combinação de algoritmos
- **Adaptativos**: Aproveitam ordenação parcial
- **Paralelos**: Merge Sort naturalmente paralelizável
- **Cache-friendly**: Consideram hierarquia de memória 