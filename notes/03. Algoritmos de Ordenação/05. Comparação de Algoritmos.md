# âš–ï¸ ComparaÃ§Ã£o de Algoritmos de OrdenaÃ§Ã£o

## ğŸ“Š Tabela de Complexidade

| Algoritmo | Pior Caso | Melhor Caso | Caso MÃ©dio | EspaÃ§o | EstÃ¡vel |
|-----------|-----------|-------------|------------|--------|---------|
| **Permutation Sort** | O(n!Â·n) | O(n!Â·n) | O(n!Â·n) | O(1) | âŒ |
| **Selection Sort** | O(nÂ²) | O(nÂ²) | O(nÂ²) | O(1) | âœ… |
| **Insertion Sort** | O(nÂ²) | O(n) | O(nÂ²) | O(1) | âœ… |
| **Merge Sort** | O(n log n) | O(n log n) | O(n log n) | O(n) | âœ… |

## ğŸ¯ CaracterÃ­sticas dos Algoritmos

### ğŸ”„ Permutation Sort
- **EstratÃ©gia**: Testa todas as permutaÃ§Ãµes possÃ­veis
- **Complexidade**: O(n!Â·n) - exponencial
- **Uso**: Apenas educacional, nunca prÃ¡tico
- **CorreÃ§Ã£o**: Trivial de provar

### ğŸ¯ Selection Sort
- **EstratÃ©gia**: Seleciona maior elemento e coloca no final
- **Complexidade**: O(nÂ²) sempre
- **Vantagem**: MÃ­nimo de trocas (n-1)
- **ImplementaÃ§Ã£o**: Recursiva ou iterativa

### ğŸ“ Insertion Sort
- **EstratÃ©gia**: Insere cada elemento na posiÃ§Ã£o correta
- **Complexidade**: O(nÂ²) pior caso, O(n) melhor caso
- **Vantagem**: Eficiente para arrays quase ordenados
- **Uso**: Subarrays pequenos em algoritmos hÃ­bridos

### ğŸ”„ Merge Sort
- **EstratÃ©gia**: Divide-and-conquer com merge
- **Complexidade**: O(n log n) sempre
- **Vantagem**: Performance garantida e estÃ¡vel
- **ImplementaÃ§Ã£o**: Recursiva com two-finger merge

## ğŸ”„ Trade-offs Fundamentais

### âš¡ Velocidade vs Simplicidade
- **Simples**: Selection/Insertion Sort
- **RÃ¡pido**: Merge Sort
- **HÃ­brido**: Timsort (Python), Introsort (C++)

### ğŸ’¾ EspaÃ§o vs Tempo
- **In-place**: Selection, Insertion Sort
- **Extra space**: Merge Sort
- **Trade-off**: Localidade vs complexidade

### ğŸ¯ Estabilidade vs Performance
- **EstÃ¡vel**: Insertion, Merge Sort
- **NÃ£o-estÃ¡vel**: Selection Sort
- **ImportÃ¢ncia**: Para objetos com chaves iguais

## ğŸš€ AplicaÃ§Ãµes PrÃ¡ticas

### ğŸ“± ImplementaÃ§Ãµes de Linguagens
- **Python**: Timsort (merge + insertion)
- **Java**: Dual-pivot quicksort
- **C++**: Introsort (quick + heap + insertion)
- **C**: qsort (quicksort)

### ğŸ¯ Escolha do Algoritmo
- **n < 50**: Insertion Sort
- **50 < n < 1000**: Quick Sort
- **n > 1000**: Merge Sort ou hÃ­brido
- **Estabilidade necessÃ¡ria**: Merge Sort

## ğŸ’¡ Insights TeÃ³ricos

### ğŸ“ˆ Limite Inferior
- **ComparaÃ§Ã£o**: Î©(n log n) para algoritmos baseados em comparaÃ§Ã£o
- **Prova**: Ãrvore de decisÃ£o com n! folhas
- **ConclusÃ£o**: Merge Sort Ã© Ã³timo

### ğŸ”„ RecorrÃªncias
- **Selection**: T(n) = T(n-1) + O(n) â†’ O(nÂ²)
- **Merge**: T(n) = 2T(n/2) + O(n) â†’ O(n log n)
- **MÃ©todo**: SubstituiÃ§Ã£o ou Master Theorem

### ğŸ¯ PadrÃµes de Design
- **Iterativo**: Selection, Insertion
- **Recursivo**: Merge Sort
- **Divide-and-conquer**: Merge Sort
- **Greedy**: Selection Sort

## ğŸ”§ OtimizaÃ§Ãµes Modernas
- **HÃ­bridos**: CombinaÃ§Ã£o de algoritmos
- **Adaptativos**: Aproveitam ordenaÃ§Ã£o parcial
- **Paralelos**: Merge Sort naturalmente paralelizÃ¡vel
- **Cache-friendly**: Consideram hierarquia de memÃ³ria 