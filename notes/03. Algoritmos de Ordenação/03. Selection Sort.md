# 🎯 Selection Sort

## 🎯 Estratégia
**Seleciona** o maior elemento e o coloca na posição correta, repetindo até ordenar

### 🔄 Algoritmo
1. **Encontra** o maior elemento no array não ordenado
2. **Troca** com o último elemento não ordenado
3. **Repete** para o subarray restante

## 🔧 Implementação Recursiva

### 📊 Prefix Max
```python
def prefix_max(A, i):
    if i == 0:
        return 0
    j = prefix_max(A, i-1)
    if A[i] > A[j]:
        return i
    return j
```

### 🎯 Selection Sort
```python
def selection_sort(A, i):
    if i == 0:
        return
    j = prefix_max(A, i)  # Encontra maior
    A[i], A[j] = A[j], A[i]  # Troca
    selection_sort(A, i-1)  # Recursão
```

## ⚡ Análise de Complexidade

### 📈 Prefix Max
- **Recursão**: T(n) = T(n-1) + O(1)
- **Solução**: T(n) = O(n)
- **Prova**: Substituição com T(n) = cn

### 🎯 Selection Sort
- **Recursão**: T(n) = T(n-1) + O(n)
- **Solução**: T(n) = O(n²)
- **Prova**: Soma aritmética 1+2+...+n = n(n+1)/2

## 🔍 Exemplo Visual
```
[8, 2, 4, 9, 3] → [8, 2, 4, 3, 9] → [3, 2, 4, 8, 9] → [2, 3, 4, 8, 9]
     ↑                    ↑                    ↑
   Maior 9              Maior 8              Maior 4
```

## ✅ Vantagens
- **Simplicidade**: Fácil de entender e implementar
- **In-place**: Não requer espaço extra
- **Estável**: Mantém ordem relativa de elementos iguais
- **Minimal swaps**: Apenas n-1 trocas

## ❌ Limitações
- **Complexidade**: O(n²) sempre
- **Ineficiente**: Não aproveita ordenação parcial
- **Comparações**: Sempre n²/2 comparações

## 🎯 Casos de Uso
- **Educacional**: Primeiro algoritmo de ordenação
- **Arrays pequenos**: n < 50 elementos
- **Implementação simples**: Quando simplicidade é prioridade
- **Minimal swaps**: Quando trocas são custosas

## 💡 Insights Teóricos
- **Recursão**: Estrutura natural para análise
- **Indução**: Prova de correção por indução
- **Substituição**: Método para resolver recorrências
- **Soma aritmética**: Padrão comum em algoritmos quadráticos 