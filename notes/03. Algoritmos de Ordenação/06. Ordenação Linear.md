# 🚀 Ordenação Linear

## 🎯 Quebrando o Limite Inferior

### 📊 Comparação vs Acesso Aleatório
- **Modelo de Comparação**: Ω(n log n) - limite fundamental
- **Modelo de Acesso Aleatório**: O(n) - possível com restrições
- **Chave**: Usar propriedades dos dados, não apenas comparações

### 🔑 Premissas para Ordenação Linear
- **Chaves Únicas**: Evitar colisões
- **Chaves Inteiras**: Permitir indexação direta
- **Faixa Limitada**: u = O(n) ou u = n^c

## 🎯 Direct Access Array Sort

### ⚡ Algoritmo Básico
```
1. Criar array de tamanho u
2. Para cada item x: array[x.key] = x
3. Percorrer array retornando itens em ordem
```

### 📈 Complexidade
| Operação | Tempo | Espaço |
|----------|-------|--------|
| Construção | O(n) | O(u) |
| Leitura | O(u) | - |
| **Total** | **O(n + u)** | **O(u)** |

### ✅ Vantagens
- 🚀 **Simples**: Implementação direta
- ⚡ **Rápido**: O(n) quando u = O(n)
- 🎯 **Determinístico**: Sem aleatoriedade

### ❌ Limitações
- 💾 **Espaço**: O(u) pode ser enorme
- 🔢 **Chaves Únicas**: Não suporta duplicatas
- 📏 **Faixa Limitada**: u deve ser pequeno

## 🔢 Counting Sort

### 🎯 Extensão para Duplicatas
- **Estrutura**: Array de listas encadeadas
- **Colisões**: Múltiplos itens por chave
- **Estabilidade**: Mantém ordem relativa

### ⚙️ Funcionamento
```
1. Criar array de listas de tamanho u
2. Para cada item x: adicionar à lista[x.key]
3. Percorrer arrays retornando itens em ordem
```

### 📊 Complexidade
| Aspecto | Tempo | Espaço |
|---------|-------|--------|
| Inserção | O(1) amortizado | O(n) |
| Leitura | O(n) | - |
| **Total** | **O(n + u)** | **O(n + u)** |

### 🎯 Aplicações
- 📊 **Dados com Duplicatas**: Chaves repetidas
- 🔢 **Chaves Pequenas**: u = O(n)
- 🎨 **Ordenação Estável**: Preserva ordem original

## 🔢 Radix Sort

### 🎯 Ordenação por Dígitos
- **Decomposição**: Quebrar números grandes em dígitos
- **Base n**: Cada dígito ∈ [0, n-1]
- **Ordenação Estável**: Dígito menos significativo primeiro

### ⚙️ Algoritmo
```
1. Decompor cada número em log_n(u) dígitos
2. Para cada dígito (menos → mais significativo):
   - Aplicar counting sort no dígito
3. Resultado final ordenado
```

### 📈 Complexidade
| Componente | Tempo |
|------------|-------|
| Decomposição | O(n × log_n(u)) |
| Ordenação por Dígito | O(n) |
| **Total** | **O(n × log_n(u))** |

### 🎯 Quando é Linear?
- **u ≤ n^c**: Para constante c
- **log_n(u) ≤ c**: Número constante de dígitos
- **Resultado**: O(n) quando u é polinomial

## 📊 Comparação de Algoritmos

| Algoritmo | Tempo | Espaço | Estável | Restrições |
|-----------|-------|--------|---------|------------|
| **Direct Access** | O(n + u) | O(u) | ✅ | Chaves únicas, u pequeno |
| **Counting Sort** | O(n + u) | O(n + u) | ✅ | u pequeno |
| **Radix Sort** | O(n × log_n(u)) | O(n + u) | ✅ | u polinomial |

## 🎯 Casos de Uso

### ✅ Ideal para Radix Sort
- 🔢 **IDs de Usuário**: Números pequenos
- 📅 **Timestamps**: Datas em formato compacto
- 🎨 **Cores RGB**: Valores de 0-255
- 📊 **Scores**: Pontuações limitadas

### ❌ Não Recomendado
- 🔢 **Números Grandes**: u exponencial
- 📝 **Strings**: Sem ordem numérica natural
- 🎯 **Chaves Complexas**: Objetos compostos
- 🔄 **Dados Dinâmicos**: Inserções frequentes

## 💡 Insights Fundamentais

### 🚀 Por que Funciona?
- **Acesso Aleatório**: O(1) para indexação
- **Propriedades dos Dados**: Estrutura conhecida
- **Decomposição**: Quebrar problemas grandes

### 🎯 Trade-offs
- **Espaço vs Tempo**: Mais espaço, menos tempo
- **Flexibilidade vs Performance**: Restrições específicas
- **Simplicidade vs Eficiência**: Algoritmos especializados

### 🔬 Limitações Teóricas
- **Modelo de Computação**: Depende de acesso aleatório
- **Tamanho das Chaves**: Limitado por memória
- **Distribuição**: Pode não ser uniforme 