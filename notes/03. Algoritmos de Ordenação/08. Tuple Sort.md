# 🎯 Tuple Sort

## 🎯 Conceito Fundamental

### 📊 Ordenação por Múltiplas Chaves
- **Estratégia**: Ordenar por múltiplas colunas com prioridade
- **Analogia**: Planilha Excel com múltiplas colunas
- **Estabilidade**: Ordem relativa preservada entre itens iguais
- **Priorização**: Colunas mais importantes têm precedência

### 🔑 Premissas
- **Estrutura de Dados**: Tuplas com múltiplos campos
- **Ordem de Prioridade**: Definição clara de importância das colunas
- **Algoritmo Estável**: Necessário para preservar trabalho anterior

## ⚙️ Algoritmo Detalhado

### 📝 Estratégia Fundamental
```
TupleSort(tuples, priorities):
    // priorities = [col1, col2, col3, ...] em ordem de importância
    for i = len(priorities)-1 downto 0:
        column = priorities[i]
        tuples = StableSort(tuples, column)
    return tuples
```

### 🔧 Pseudocódigo Completo
```
TupleSort(A, priorities):
    // A = array de tuplas
    // priorities = array com índices das colunas em ordem de importância
    
    for i = len(priorities)-1 downto 0:
        col = priorities[i]
        A = CountingSort(A, col)  // ou qualquer algoritmo estável
    return A

CountingSort(A, column):
    n = length(A)
    max_val = max(A[j][column] for j = 0 to n-1)
    
    count = array[0...max_val] inicializado com 0
    output = array[0...n]
    
    // Contar frequência
    for j = 0 to n-1:
        val = A[j][column]
        count[val]++
    
    // Acumular
    for i = 1 to max_val:
        count[i] += count[i-1]
    
    // Construir output estável
    for j = n-1 downto 0:
        val = A[j][column]
        output[count[val]-1] = A[j]
        count[val]--
    
    return output
```

## 📈 Análise de Complexidade

### ⏱️ Tempo de Execução
| Componente | Tempo | Justificativa |
|------------|-------|---------------|
| **Iterações** | O(k) | k = número de colunas |
| **Stable Sort** | O(n + u) | counting sort por coluna |
| **Total** | **O(k × (n + u))** | k iterações de stable sort |

### 💾 Espaço
- **Counting Sort**: O(n + u) por iteração
- **Reutilização**: Mesmo espaço pode ser reutilizado
- **Total**: **O(n + u)** - espaço linear

### 🎯 Otimizações
- **Early Termination**: Parar se array já ordenado
- **In-place**: Modificar array original
- **Adaptativo**: Escolher algoritmo baseado no tamanho da coluna

## 🔬 Implementação Prática

### 🐍 Python
```python
def tuple_sort(tuples, priorities):
    """
    Ordena tuplas por múltiplas colunas com prioridade
    
    Args:
        tuples: Lista de tuplas
        priorities: Lista de índices das colunas em ordem de importância
    
    Returns:
        Lista ordenada de tuplas
    """
    if not tuples or not priorities:
        return tuples
    
    # Ordenar da coluna menos importante para mais importante
    for col in reversed(priorities):
        tuples = counting_sort_by_column(tuples, col)
    
    return tuples

def counting_sort_by_column(tuples, column):
    """Ordenação estável por coluna específica"""
    if not tuples:
        return tuples
    
    n = len(tuples)
    
    # Encontrar máximo na coluna
    max_val = max(tuple_[column] for tuple_ in tuples)
    
    # Contar frequência
    count = [0] * (max_val + 1)
    for tuple_ in tuples:
        count[tuple_[column]] += 1
    
    # Acumular
    for i in range(1, max_val + 1):
        count[i] += count[i-1]
    
    # Construir output estável
    output = [None] * n
    for i in range(n-1, -1, -1):
        val = tuples[i][column]
        output[count[val]-1] = tuples[i]
        count[val] -= 1
    
    return output

# Exemplo de uso
def example_usage():
    # Dados: (idade, salário, departamento)
    employees = [
        (25, 50000, "TI"),
        (30, 60000, "RH"),
        (25, 55000, "TI"),
        (35, 70000, "TI"),
        (30, 65000, "RH")
    ]
    
    # Prioridade: departamento (2), idade (0), salário (1)
    priorities = [2, 0, 1]
    
    sorted_employees = tuple_sort(employees, priorities)
    return sorted_employees
```

## 📊 Exemplo Detalhado

### 🔢 Dados de Entrada
```
Tuplas: [(3,2), (0,3), (4,4), (4,2), (2,2)]
n = 5, base = 5
Prioridades: [1, 0] (coluna 1 mais importante)
```

### 📝 Passo a Passo

#### Passo 1: Ordenar por coluna menos importante (coluna 0)
```
Coluna 0: [3, 0, 4, 4, 2]
Ordenado: [(0,3), (2,2), (3,2), (4,4), (4,2)]
```

#### Passo 2: Ordenar por coluna mais importante (coluna 1)
```
Coluna 1: [3, 2, 2, 4, 2]
Resultado: [(2,2), (3,2), (4,2), (0,3), (4,4)]
```

## 🎯 Aplicações Práticas

### ✅ Casos Ideais
- **Planilhas Excel**: Ordenação por múltiplas colunas
- **Bancos de Dados**: ORDER BY múltiplas colunas
- **Sistemas de Arquivos**: Ordenação por nome, data, tamanho
- **Análise de Dados**: Estatísticas por múltiplos critérios
- **Radix Sort**: Implementação usando tuple sort

### ❌ Casos Não Recomendados
- **Muitas Colunas**: k muito grande (complexidade O(k × n))
- **Colunas Muito Grandes**: u muito grande (espaço O(u))
- **Ordenação Dinâmica**: Prioridades que mudam frequentemente

## 🔬 Relação com Radix Sort

### 📊 Radix Sort como Tuple Sort
```
RadixSort(A, n, u):
    // Decompor números em dígitos
    tuples = [(a//n, a%n) for a in A]  // base n
    
    // Tuple sort com prioridade: dígito mais significativo
    priorities = [1, 0]  // coluna 1 (MSD) mais importante
    sorted_tuples = TupleSort(tuples, priorities)
    
    // Reconstruir números
    return [t[0]*n + t[1] for t in sorted_tuples]
```

### 🎯 Vantagens da Abordagem
- **Conceito Unificado**: Radix sort é caso especial de tuple sort
- **Flexibilidade**: Prioridades configuráveis
- **Reutilização**: Mesmo algoritmo para diferentes problemas

## 💡 Insights Teóricos

### 🚀 Por que Funciona?
- **Estabilidade**: Preserva ordem de iterações anteriores
- **Priorização**: Colunas mais importantes têm precedência
- **Decomposição**: Problema complexo → problemas simples

### 🎯 Trade-offs
- **Flexibilidade vs Performance**: Mais colunas = mais tempo
- **Simplicidade vs Eficiência**: Algoritmo simples mas especializado
- **Espaço vs Tempo**: O(n + u) espaço para O(k × (n + u)) tempo

### 🔬 Limitações
- **Número de Colunas**: k afeta performance linearmente
- **Tamanho das Colunas**: u afeta espaço linearmente
- **Distribuição**: Performance depende da distribuição dos dados

## 📊 Comparação com Outros Algoritmos

| Aspecto | Tuple Sort | Merge Sort | Quick Sort |
|---------|------------|------------|------------|
| **Tempo** | O(k × (n + u)) | O(n log n) | O(n log n) |
| **Espaço** | O(n + u) | O(n) | O(log n) |
| **Estável** | ✅ | ✅ | ❌ |
| **Flexibilidade** | ✅ | ❌ | ❌ |
| **Restrições** | Colunas pequenas | Nenhuma | Nenhuma | 