# 📊 Problema de Ordenação

## 🎯 Definição
**Input**: Array A de n elementos com chaves comparáveis
**Output**: Array B ordenado (A[i] ≤ A[i+1] para todo i)

## 🔧 Tipos de Algoritmos

### 🗑️ Destructive vs Non-destructive
- **Destructive**: Modifica array original A
- **Non-destructive**: Cria novo array B ordenado

### 💾 In-place vs Extra Space
- **In-place**: Usa apenas O(1) espaço extra
- **Extra space**: Requer espaço adicional O(n)

## ⚡ Complexidade Teórica

### 📈 Limite Inferior
- **Comparação**: Qualquer algoritmo baseado em comparação
- **Limite**: Ω(n log n) no pior caso
- **Prova**: Árvore de decisão com n! folhas

### 🎯 Algoritmos Ótimos
- **Merge Sort**: O(n log n) garantido
- **Heap Sort**: O(n log n) in-place
- **Quick Sort**: O(n log n) esperado

## 🔄 Motivação para Sets

### 📊 Arrays Não Ordenados
| Operação | Complexidade | Descrição |
|----------|-------------|-----------|
| `build()` | O(n) | Simples inserção |
| `find(k)` | O(n) | Busca linear |
| `insert(x)` | O(1) | Inserção no final |
| `delete(k)` | O(n) | Busca + remoção |

### 📈 Arrays Ordenados
| Operação | Complexidade | Descrição |
|----------|-------------|-----------|
| `build()` | O(n log n) | Ordenação necessária |
| `find(k)` | O(log n) | Busca binária |
| `insert(x)` | O(n) | Deslocamento necessário |
| `delete(k)` | O(n) | Deslocamento necessário |

## 💡 Trade-off Fundamental
- **Build**: Ordenados são mais lentos O(n log n) vs O(n)
- **Find**: Ordenados são mais rápidos O(log n) vs O(n)
- **Insert/Delete**: Ordenados são mais lentos O(n) vs O(1)

## 🎯 Quando Ordenar?
- **Muitas buscas**: Vale a pena ordenar uma vez
- **Poucas buscas**: Array não ordenado é melhor
- **Operações mistas**: Estruturas híbridas (trees, hash)

## 🚀 Aplicações Práticas
- **Bancos de dados**: Índices ordenados para range queries
- **Sistemas de arquivos**: Organização por nome/data
- **Análise de dados**: Estatísticas ordenadas
- **Interfaces gráficas**: Listas ordenadas para usuário 