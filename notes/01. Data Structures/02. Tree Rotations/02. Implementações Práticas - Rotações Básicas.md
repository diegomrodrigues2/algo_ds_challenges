# 🚀 Implementações Práticas: Rotações Básicas

## 🎯 Objetivo

Implementar as **operações atômicas fundamentais** que permitem reestruturar árvores binárias preservando a propriedade BST.

## 📝 Desafio 1: Rotação à Esquerda (`rotate_left.py`)

### 🎯 Estratégia de Implementação

**Algoritmo:**
1. **Identificar** novo nó raiz (filho direito)
2. **Reorganizar** ponteiros
3. **Retornar** nova raiz

### 🔍 Pseudocódigo Detalhado

```python
def rotate_left(root):
    # Caso base: árvore vazia ou sem filho direito
    if root is None or root.right is None:
        return root
    
    # 1. Identificar novo nó raiz
    new_root = root.right
    
    # 2. Reorganizar ponteiros
    root.right = new_root.left
    new_root.left = root
    
    # 3. Retornar nova raiz
    return new_root
```

### 🔄 Visualização da Transformação

```
Antes:         Y           Depois:        X
              / \                        / \
             X   C                      A   Y
            / \                            / \
           A   B                          B   C

Passos:
1. new_root = Y.right (X)
2. Y.right = X.left (B)
3. X.left = Y
4. return X
```

### ⚡ Análise de Complexidade

| Aspecto | Complexidade | Explicação |
|---------|--------------|------------|
| **Tempo** | O(1) | Operação atômica |
| **Espaço** | O(1) | Apenas reorganização de ponteiros |
| **Propriedade BST** | ✅ Preservada | Invariante mantida |

### 🧪 Casos de Teste Essenciais

```python
# Árvore de teste
#       8
#      / \
#     3   10
#    / \    \
#   1   6    14
#      / \
#     4   7

# ✅ Rotação à esquerda na raiz
root = rotate_left(root)
# Resultado:
#       10
#      /  \
#     8    14
#    / \
#   3   9
#  / \
# 1   6
#    / \
#   4   7

# ✅ Rotação à esquerda em subárvore
root.left = rotate_left(root.left)
# Resultado:
#       10
#      /  \
#     6    14
#    / \
#   3   8
#  /   / \
# 1   7   9
#    /
#   4
```

## 📝 Desafio 2: Rotação à Direita (`rotate_right.py`)

### 🎯 Estratégia de Implementação

**Algoritmo:**
1. **Identificar** novo nó raiz (filho esquerdo)
2. **Reorganizar** ponteiros
3. **Retornar** nova raiz

### 🔍 Pseudocódigo Detalhado

```python
def rotate_right(root):
    # Caso base: árvore vazia ou sem filho esquerdo
    if root is None or root.left is None:
        return root
    
    # 1. Identificar novo nó raiz
    new_root = root.left
    
    # 2. Reorganizar ponteiros
    root.left = new_root.right
    new_root.right = root
    
    # 3. Retornar nova raiz
    return new_root
```

### 🔄 Visualização da Transformação

```
Antes:         Y           Depois:        X
              / \                        / \
             X   C                      A   Y
            / \                            / \
           A   B                          B   C

Passos:
1. new_root = Y.left (X)
2. Y.left = X.right (B)
3. X.right = Y
4. return X
```

### ⚡ Análise de Complexidade

| Aspecto | Complexidade | Explicação |
|---------|--------------|------------|
| **Tempo** | O(1) | Operação atômica |
| **Espaço** | O(1) | Apenas reorganização de ponteiros |
| **Propriedade BST** | ✅ Preservada | Invariante mantida |

### 🧪 Casos de Teste Essenciais

```python
# Árvore de teste
#       8
#      / \
#     3   10
#    / \    \
#   1   6    14
#      / \
#     4   7

# ✅ Rotação à direita na raiz
root = rotate_right(root)
# Resultado:
#       3
#      / \
#     1   8
#        / \
#       6   10
#      / \    \
#     4   7    14

# ✅ Rotação à direita em subárvore
root.right = rotate_right(root.right)
# Resultado:
#       3
#      / \
#     1   6
#        / \
#       4   8
#          / \
#         7   10
#              \
#              14
```

## 🔄 Padrões de Implementação

### 📊 Comparação de Abordagens

| Aspecto | Recursão | Iteração |
|---------|----------|----------|
| **Aplicabilidade** | ❌ Não aplicável | ✅ Natural |
| **Legibilidade** | 🔧 Mais complexa | 🎯 Mais clara |
| **Performance** | ⚡ O(1) | ⚡ O(1) |

### 🎯 Recomendação

**Para rotações:** Use **iteração** (mais natural e clara)

## 🚀 Aplicações Práticas

### 🔄 **Redução de Altura**

```python
# Árvore desbalanceada
#   1
#    \
#     2
#      \
#       3
#        \
#         4

# Aplicar rotação à esquerda na raiz
root = rotate_left(root)

# Resultado:
#   2
#  / \
# 1   3
#      \
#       4
```

### 🔄 **Preparação para Auto-Balanceamento**

```python
# Árvore que precisa de balanceamento
#       8
#      /
#     3
#    /
#   1

# Aplicar rotação à direita
root = rotate_right(root)

# Resultado:
#   3
#  / \
# 1   8
```

## 💡 Dicas de Implementação

### 🎯 Estrutura do Nó

```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
```

### 🔍 Verificação de Propriedade BST

```python
def is_bst_property(node, min_val=float('-inf'), max_val=float('inf')):
    if node is None:
        return True
    
    # Verifica propriedade atual
    if not (min_val < node.value < max_val):
        return False
    
    # Verifica subárvores
    return (is_bst_property(node.left, min_val, node.value) and
            is_bst_property(node.right, node.value, max_val))
```

### 🐛 Debugging

```python
def print_tree(root, level=0):
    if root is None:
        return
    
    print_tree(root.right, level + 1)
    print("  " * level + str(root.value))
    print_tree(root.left, level + 1)
```

## 🚀 Próximos Passos

Após dominar estas operações atômicas:

1. **Rotações Duplas** - Combinação de rotações simples
2. **AVL Trees** - Rotações baseadas em fator de balanceamento
3. **Red-Black Trees** - Rotações + recolorização
4. **Splay Trees** - Rotações para otimização de acesso

## 💡 Insights Fundamentais

### 🎯 1. Operações Atômicas
Rotações são **indivisíveis** - ou acontecem completamente ou não acontecem.

### 🔄 2. Preservação de Propriedades
A propriedade BST é **invariante** - mantida antes e depois da rotação.

### ⚡ 3. Eficiência Local
Rotações afetam apenas **3 nós** - operação extremamente eficiente.

**Lição:** As rotações são as **operações atômicas** que fundamentam todas as árvores auto-balanceadas! 