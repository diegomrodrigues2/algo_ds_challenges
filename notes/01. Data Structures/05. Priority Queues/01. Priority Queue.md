# 🎯 Priority Queue

## 🎯 O que é uma Priority Queue?

**Priority Queue** é uma estrutura de dados que mantém elementos ordenados por **prioridade**. Diferente de uma queue normal (FIFO), a priority queue remove sempre o elemento de **maior prioridade**.

### 🌟 **Propriedade Fundamental**
```
Priority Queue: Elementos com maior prioridade são removidos primeiro
- Min Priority Queue: Menor elemento tem maior prioridade
- Max Priority Queue: Maior elemento tem maior prioridade
```

## 🔄 Como Funciona

### 📊 **Analogia Simples**
> **Fila de Hospital**: Como uma fila de emergência - pacientes mais graves são atendidos primeiro, independente da ordem de chegada.

### 🎯 **Operações Principais**
1. **📤 Insert**: Adiciona elemento mantendo propriedade de heap
2. **📥 Extract Min/Max**: Remove elemento de maior prioridade
3. **👀 Peek Min/Max**: Visualiza elemento de maior prioridade
4. **📏 Size**: Retorna número de elementos
5. **🔍 Empty**: Verifica se está vazia

## 📊 Implementação com Heap

### 🎯 **Estrutura Básica**
```python
class MinPriorityQueue:
    def __init__(self):
        self._data = []
        self._size = 0
    
    def insert(self, value):
        # Adiciona no final e faz bubble-up
        self._data.append(value)
        self._size += 1
        self._bubble_up(self._size - 1)
    
    def extract_min(self):
        if self.is_empty():
            raise IndexError("Priority queue vazia")
        
        # Troca raiz com último elemento
        min_value = self._data[0]
        self._data[0] = self._data[self._size - 1]
        self._data.pop()
        self._size -= 1
        
        # Faz heapify se necessário
        if self._size > 0:
            self._heapify(0)
        
        return min_value
    
    def peek_min(self):
        if self.is_empty():
            raise IndexError("Priority queue vazia")
        return self._data[0]
    
    def size(self):
        return self._size
    
    def is_empty(self):
        return self._size == 0
```

### 🎨 **Representação Visual**
```
Min Heap: [1, 3, 2, 7, 4, 5]
          1
         / \
        3   2
       / \ / \
      7  4 5  _

Insert(0): [0, 1, 2, 3, 4, 5, 7]
           0
          / \
         1   2
        / \ / \
       3  4 5  7

Extract Min: [1, 3, 2, 7, 4, 5]
             1
            / \
           3   2
          / \ / \
         7  4 5  _
```

## ⚡ Complexidade das Operações

### 📈 **Análise de Complexidade**
| Operação | Complexidade | Explicação |
|----------|--------------|------------|
| **📤 Insert** | O(log n) | Bubble-up até a raiz |
| **📥 Extract Min/Max** | O(log n) | Heapify até as folhas |
| **👀 Peek Min/Max** | O(1) | Acesso à raiz |
| **📏 Size** | O(1) | Contador mantido |
| **🔍 Empty** | O(1) | Verificação de tamanho |
| **Build Heap** | O(n) | Heapify de baixo para cima |

### 🔍 **Por que O(log n)?**
- **📊 Altura do heap**: log₂(n) níveis
- **🔄 Bubble-up**: Máximo log₂(n) comparações
- **⚡ Heapify**: Máximo log₂(n) comparações
- **📏 Operações**: Proporcionais à altura

## ✅ Vantagens vs ❌ Desvantagens

| Aspecto | ✅ Vantagem | ❌ Desvantagem |
|---------|-------------|----------------|
| **⚡ Extract** | O(log n) - eficiente | Não O(1) como array ordenado |
| **📤 Insert** | O(log n) - eficiente | Não O(1) como lista |
| **💾 Memória** | Eficiente - array compacto | Não permite acesso aleatório |
| **🔄 Simplicidade** | Fácil de implementar | Propriedade de heap complexa |
| **📊 Flexibilidade** | Suporta prioridades dinâmicas | Não permite busca eficiente |

## 🎯 Aplicações Práticas

### 🔧 **Sistemas de Computação**
- **🎮 Game AI**: Pathfinding com A* algorithm
- **🌐 Networking**: Pacotes com prioridade
- **📊 Task Scheduler**: Processos com prioridade
- **🔧 Event Systems**: Eventos ordenados por tempo

### 📊 **Algoritmos**
- **🔍 Dijkstra's**: Menor caminho em grafos
- **🌳 Prim's**: Árvore geradora mínima
- **📝 Huffman**: Compressão de dados
- **🎯 Top-k**: K elementos mais importantes

### 🏗️ **Sistemas Reais**
- **🏥 Hospital**: Fila de emergência
- **🏦 Banco**: Clientes VIP
- **🎬 Cinema**: Filas prioritárias
- **🚗 Trânsito**: Veículos de emergência

## 🔄 Propriedades Matemáticas

### 📊 **Invariantes do Heap**
- **📏 Heap Property**: Pai ≤ filhos (min heap)
- **🔄 Complete Binary Tree**: Preenchido da esquerda para direita
- **📦 Array Representation**: Índices calculáveis
- **⚡ Height**: log₂(n) níveis

### 🎯 **Operações Válidas**
```
Insert → Mantém heap property
Extract → Mantém heap property
Peek → Não altera estrutura
```

## 💡 Dicas de Implementação

### 🎯 **Pontos-Chave**
- **📊 Use array**: Representação mais eficiente
- **🔄 Controle índices**: Pai = (i-1)//2, Filhos = 2i+1, 2i+2
- **⚡ Bubble-up/down**: Mantenha heap property
- **📏 Controle tamanho**: Mantenha contador atualizado

### 🔧 **Otimizações**
- **📊 Pre-allocation**: Defina tamanho inicial se conhecido
- **🔄 Lazy heapify**: Só quando necessário
- **⚡ Custom comparators**: Para prioridades complexas
- **📏 Capacity management**: Controlar crescimento

## 🎯 Comparação com Outras Estruturas

| Estrutura | Insert | Extract | Peek | Propriedade |
|-----------|--------|---------|------|-------------|
| **🎯 Priority Queue** | O(log n) | O(log n) | O(1) | Heap |
| **📊 Array Ordenado** | O(n) | O(1) | O(1) | Ordenado |
| **🔄 Lista Ordenada** | O(n) | O(1) | O(1) | Ordenado |
| **🌳 BST** | O(log n) | O(log n) | O(log n) | Árvore |

## 🔄 Variações Importantes

### 📊 **Max Priority Queue**
```python
class MaxPriorityQueue:
    def __init__(self):
        self._data = []
        self._size = 0
    
    def insert(self, value):
        self._data.append(value)
        self._size += 1
        self._bubble_up_max(self._size - 1)
    
    def extract_max(self):
        if self.is_empty():
            raise IndexError("Priority queue vazia")
        
        max_value = self._data[0]
        self._data[0] = self._data[self._size - 1]
        self._data.pop()
        self._size -= 1
        
        if self._size > 0:
            self._heapify_max(0)
        
        return max_value
    
    def _bubble_up_max(self, index):
        parent = (index - 1) // 2
        if parent >= 0 and self._data[parent] < self._data[index]:
            self._data[parent], self._data[index] = self._data[index], self._data[parent]
            self._bubble_up_max(parent)
    
    def _heapify_max(self, index):
        largest = index
        left = 2 * index + 1
        right = 2 * index + 2
        
        if left < self._size and self._data[left] > self._data[largest]:
            largest = left
        
        if right < self._size and self._data[right] > self._data[largest]:
            largest = right
        
        if largest != index:
            self._data[index], self._data[largest] = self._data[largest], self._data[index]
            self._heapify_max(largest)
```

### 🔄 **Priority Queue com Custom Comparator**
```python
class CustomPriorityQueue:
    def __init__(self, key_func=None):
        self._data = []
        self._size = 0
        self._key_func = key_func or (lambda x: x)
    
    def insert(self, value):
        self._data.append(value)
        self._size += 1
        self._bubble_up_custom(self._size - 1)
    
    def _bubble_up_custom(self, index):
        parent = (index - 1) // 2
        if parent >= 0 and self._key_func(self._data[parent]) > self._key_func(self._data[index]):
            self._data[parent], self._data[index] = self._data[index], self._data[parent]
            self._bubble_up_custom(parent)
    
    def _heapify_custom(self, index):
        smallest = index
        left = 2 * index + 1
        right = 2 * index + 2
        
        if left < self._size and self._key_func(self._data[left]) < self._key_func(self._data[smallest]):
            smallest = left
        
        if right < self._size and self._key_func(self._data[right]) < self._key_func(self._data[smallest]):
            smallest = right
        
        if smallest != index:
            self._data[index], self._data[smallest] = self._data[smallest], self._data[index]
            self._heapify_custom(smallest)
```

## 💡 Dicas de Debugging

### 🎯 **Problemas Comuns**
- **📊 Heap property violada**: Verifique bubble-up/down
- **🔄 Índices incorretos**: Valide cálculos de pai/filhos
- **⚡ Memory leaks**: Não limpar referências
- **📏 Size mismatch**: Contador desatualizado

### 🔧 **Soluções**
- **📊 Valide heap property**: Após cada operação
- **🔄 Use try/catch**: Para operações críticas
- **⚡ Validar entrada**: Verificar parâmetros
- **📏 Testar extremos**: Heap vazio, um elemento 