# ğŸ¯ Priority Queue

## ğŸ¯ O que Ã© uma Priority Queue?

**Priority Queue** Ã© uma estrutura de dados que mantÃ©m elementos ordenados por **prioridade**. Diferente de uma queue normal (FIFO), a priority queue remove sempre o elemento de **maior prioridade**.

### ğŸŒŸ **Propriedade Fundamental**
```
Priority Queue: Elementos com maior prioridade sÃ£o removidos primeiro
- Min Priority Queue: Menor elemento tem maior prioridade
- Max Priority Queue: Maior elemento tem maior prioridade
```

## ğŸ”„ Como Funciona

### ğŸ“Š **Analogia Simples**
> **Fila de Hospital**: Como uma fila de emergÃªncia - pacientes mais graves sÃ£o atendidos primeiro, independente da ordem de chegada.

### ğŸ¯ **OperaÃ§Ãµes Principais**
1. **ğŸ“¤ Insert**: Adiciona elemento mantendo propriedade de heap
2. **ğŸ“¥ Extract Min/Max**: Remove elemento de maior prioridade
3. **ğŸ‘€ Peek Min/Max**: Visualiza elemento de maior prioridade
4. **ğŸ“ Size**: Retorna nÃºmero de elementos
5. **ğŸ” Empty**: Verifica se estÃ¡ vazia

## ğŸ“Š ImplementaÃ§Ã£o com Heap

### ğŸ¯ **Estrutura BÃ¡sica**
```python
class MinPriorityQueue:
    def __init__(self):
        self._data = []
        self._size = 0
    
    def insert(self, value):
        # Adiciona no final e faz bubble-up
        self._data.append(value)
        self._size += 1
        self._bubble_up(self._size - 1)
    
    def extract_min(self):
        if self.is_empty():
            raise IndexError("Priority queue vazia")
        
        # Troca raiz com Ãºltimo elemento
        min_value = self._data[0]
        self._data[0] = self._data[self._size - 1]
        self._data.pop()
        self._size -= 1
        
        # Faz heapify se necessÃ¡rio
        if self._size > 0:
            self._heapify(0)
        
        return min_value
    
    def peek_min(self):
        if self.is_empty():
            raise IndexError("Priority queue vazia")
        return self._data[0]
    
    def size(self):
        return self._size
    
    def is_empty(self):
        return self._size == 0
```

### ğŸ¨ **RepresentaÃ§Ã£o Visual**
```
Min Heap: [1, 3, 2, 7, 4, 5]
          1
         / \
        3   2
       / \ / \
      7  4 5  _

Insert(0): [0, 1, 2, 3, 4, 5, 7]
           0
          / \
         1   2
        / \ / \
       3  4 5  7

Extract Min: [1, 3, 2, 7, 4, 5]
             1
            / \
           3   2
          / \ / \
         7  4 5  _
```

## âš¡ Complexidade das OperaÃ§Ãµes

### ğŸ“ˆ **AnÃ¡lise de Complexidade**
| OperaÃ§Ã£o | Complexidade | ExplicaÃ§Ã£o |
|----------|--------------|------------|
| **ğŸ“¤ Insert** | O(log n) | Bubble-up atÃ© a raiz |
| **ğŸ“¥ Extract Min/Max** | O(log n) | Heapify atÃ© as folhas |
| **ğŸ‘€ Peek Min/Max** | O(1) | Acesso Ã  raiz |
| **ğŸ“ Size** | O(1) | Contador mantido |
| **ğŸ” Empty** | O(1) | VerificaÃ§Ã£o de tamanho |
| **Build Heap** | O(n) | Heapify de baixo para cima |

### ğŸ” **Por que O(log n)?**
- **ğŸ“Š Altura do heap**: logâ‚‚(n) nÃ­veis
- **ğŸ”„ Bubble-up**: MÃ¡ximo logâ‚‚(n) comparaÃ§Ãµes
- **âš¡ Heapify**: MÃ¡ximo logâ‚‚(n) comparaÃ§Ãµes
- **ğŸ“ OperaÃ§Ãµes**: Proporcionais Ã  altura

## âœ… Vantagens vs âŒ Desvantagens

| Aspecto | âœ… Vantagem | âŒ Desvantagem |
|---------|-------------|----------------|
| **âš¡ Extract** | O(log n) - eficiente | NÃ£o O(1) como array ordenado |
| **ğŸ“¤ Insert** | O(log n) - eficiente | NÃ£o O(1) como lista |
| **ğŸ’¾ MemÃ³ria** | Eficiente - array compacto | NÃ£o permite acesso aleatÃ³rio |
| **ğŸ”„ Simplicidade** | FÃ¡cil de implementar | Propriedade de heap complexa |
| **ğŸ“Š Flexibilidade** | Suporta prioridades dinÃ¢micas | NÃ£o permite busca eficiente |

## ğŸ¯ AplicaÃ§Ãµes PrÃ¡ticas

### ğŸ”§ **Sistemas de ComputaÃ§Ã£o**
- **ğŸ® Game AI**: Pathfinding com A* algorithm
- **ğŸŒ Networking**: Pacotes com prioridade
- **ğŸ“Š Task Scheduler**: Processos com prioridade
- **ğŸ”§ Event Systems**: Eventos ordenados por tempo

### ğŸ“Š **Algoritmos**
- **ğŸ” Dijkstra's**: Menor caminho em grafos
- **ğŸŒ³ Prim's**: Ãrvore geradora mÃ­nima
- **ğŸ“ Huffman**: CompressÃ£o de dados
- **ğŸ¯ Top-k**: K elementos mais importantes

### ğŸ—ï¸ **Sistemas Reais**
- **ğŸ¥ Hospital**: Fila de emergÃªncia
- **ğŸ¦ Banco**: Clientes VIP
- **ğŸ¬ Cinema**: Filas prioritÃ¡rias
- **ğŸš— TrÃ¢nsito**: VeÃ­culos de emergÃªncia

## ğŸ”„ Propriedades MatemÃ¡ticas

### ğŸ“Š **Invariantes do Heap**
- **ğŸ“ Heap Property**: Pai â‰¤ filhos (min heap)
- **ğŸ”„ Complete Binary Tree**: Preenchido da esquerda para direita
- **ğŸ“¦ Array Representation**: Ãndices calculÃ¡veis
- **âš¡ Height**: logâ‚‚(n) nÃ­veis

### ğŸ¯ **OperaÃ§Ãµes VÃ¡lidas**
```
Insert â†’ MantÃ©m heap property
Extract â†’ MantÃ©m heap property
Peek â†’ NÃ£o altera estrutura
```

## ğŸ’¡ Dicas de ImplementaÃ§Ã£o

### ğŸ¯ **Pontos-Chave**
- **ğŸ“Š Use array**: RepresentaÃ§Ã£o mais eficiente
- **ğŸ”„ Controle Ã­ndices**: Pai = (i-1)//2, Filhos = 2i+1, 2i+2
- **âš¡ Bubble-up/down**: Mantenha heap property
- **ğŸ“ Controle tamanho**: Mantenha contador atualizado

### ğŸ”§ **OtimizaÃ§Ãµes**
- **ğŸ“Š Pre-allocation**: Defina tamanho inicial se conhecido
- **ğŸ”„ Lazy heapify**: SÃ³ quando necessÃ¡rio
- **âš¡ Custom comparators**: Para prioridades complexas
- **ğŸ“ Capacity management**: Controlar crescimento

## ğŸ¯ ComparaÃ§Ã£o com Outras Estruturas

| Estrutura | Insert | Extract | Peek | Propriedade |
|-----------|--------|---------|------|-------------|
| **ğŸ¯ Priority Queue** | O(log n) | O(log n) | O(1) | Heap |
| **ğŸ“Š Array Ordenado** | O(n) | O(1) | O(1) | Ordenado |
| **ğŸ”„ Lista Ordenada** | O(n) | O(1) | O(1) | Ordenado |
| **ğŸŒ³ BST** | O(log n) | O(log n) | O(log n) | Ãrvore |

## ğŸ”„ VariaÃ§Ãµes Importantes

### ğŸ“Š **Max Priority Queue**
```python
class MaxPriorityQueue:
    def __init__(self):
        self._data = []
        self._size = 0
    
    def insert(self, value):
        self._data.append(value)
        self._size += 1
        self._bubble_up_max(self._size - 1)
    
    def extract_max(self):
        if self.is_empty():
            raise IndexError("Priority queue vazia")
        
        max_value = self._data[0]
        self._data[0] = self._data[self._size - 1]
        self._data.pop()
        self._size -= 1
        
        if self._size > 0:
            self._heapify_max(0)
        
        return max_value
    
    def _bubble_up_max(self, index):
        parent = (index - 1) // 2
        if parent >= 0 and self._data[parent] < self._data[index]:
            self._data[parent], self._data[index] = self._data[index], self._data[parent]
            self._bubble_up_max(parent)
    
    def _heapify_max(self, index):
        largest = index
        left = 2 * index + 1
        right = 2 * index + 2
        
        if left < self._size and self._data[left] > self._data[largest]:
            largest = left
        
        if right < self._size and self._data[right] > self._data[largest]:
            largest = right
        
        if largest != index:
            self._data[index], self._data[largest] = self._data[largest], self._data[index]
            self._heapify_max(largest)
```

### ğŸ”„ **Priority Queue com Custom Comparator**
```python
class CustomPriorityQueue:
    def __init__(self, key_func=None):
        self._data = []
        self._size = 0
        self._key_func = key_func or (lambda x: x)
    
    def insert(self, value):
        self._data.append(value)
        self._size += 1
        self._bubble_up_custom(self._size - 1)
    
    def _bubble_up_custom(self, index):
        parent = (index - 1) // 2
        if parent >= 0 and self._key_func(self._data[parent]) > self._key_func(self._data[index]):
            self._data[parent], self._data[index] = self._data[index], self._data[parent]
            self._bubble_up_custom(parent)
    
    def _heapify_custom(self, index):
        smallest = index
        left = 2 * index + 1
        right = 2 * index + 2
        
        if left < self._size and self._key_func(self._data[left]) < self._key_func(self._data[smallest]):
            smallest = left
        
        if right < self._size and self._key_func(self._data[right]) < self._key_func(self._data[smallest]):
            smallest = right
        
        if smallest != index:
            self._data[index], self._data[smallest] = self._data[smallest], self._data[index]
            self._heapify_custom(smallest)
```

## ğŸ’¡ Dicas de Debugging

### ğŸ¯ **Problemas Comuns**
- **ğŸ“Š Heap property violada**: Verifique bubble-up/down
- **ğŸ”„ Ãndices incorretos**: Valide cÃ¡lculos de pai/filhos
- **âš¡ Memory leaks**: NÃ£o limpar referÃªncias
- **ğŸ“ Size mismatch**: Contador desatualizado

### ğŸ”§ **SoluÃ§Ãµes**
- **ğŸ“Š Valide heap property**: ApÃ³s cada operaÃ§Ã£o
- **ğŸ”„ Use try/catch**: Para operaÃ§Ãµes crÃ­ticas
- **âš¡ Validar entrada**: Verificar parÃ¢metros
- **ğŸ“ Testar extremos**: Heap vazio, um elemento 