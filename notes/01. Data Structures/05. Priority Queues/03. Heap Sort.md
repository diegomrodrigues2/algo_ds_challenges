# 🔄 Heap Sort

## 🎯 Visão Geral

**Heap Sort** é um algoritmo de ordenação baseado na estrutura de dados **heap**. Ele utiliza as propriedades do heap para ordenar elementos de forma eficiente, com complexidade O(n log n).

### 🌟 **Propriedade Fundamental**
```
Heap Sort: Constrói um heap e extrai elementos em ordem
- Build Heap: O(n) - constrói heap do array
- Extract: O(log n) - remove elemento da raiz
- Total: O(n log n) - n extrações
```

## 🔄 Como Funciona

### 📊 **Processo em Duas Fases**
1. **🏗️ Build Heap**: Converte array em heap
2. **📥 Extract**: Remove elementos da raiz em ordem

### 🎯 **Algoritmo Básico**
```python
def heap_sort(arr):
    n = len(arr)
    
    # Fase 1: Constrói heap
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # Fase 2: Extrai elementos
    for i in range(n - 1, 0, -1):
        # Troca raiz (máximo) com último elemento
        arr[0], arr[i] = arr[i], arr[0]
        
        # Heapify na subárvore reduzida
        heapify(arr, i, 0)

def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    # Encontra o maior entre pai e filhos
    if left < n and arr[left] > arr[largest]:
        largest = left
    
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    # Se o maior não é o pai, troca e continua
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
```

### 🎨 **Representação Visual**
```
Array: [7, 3, 1, 5, 4, 2]

Fase 1 - Build Heap:
Passo 1: [7, 3, 1, 5, 4, 2]
Passo 2: Heapify índices 2, 1, 0
Passo 3: [7, 5, 2, 3, 4, 1]

Fase 2 - Extract:
Passo 1: Troca 7 e 1 → [1, 5, 2, 3, 4, 7]
Passo 2: Heapify [1, 5, 2, 3, 4] → [5, 4, 2, 3, 1]
Passo 3: Troca 5 e 1 → [1, 4, 2, 3, 5, 7]
...
Resultado: [1, 2, 3, 4, 5, 7]
```

## ⚡ Complexidade

### 📈 **Análise de Complexidade**
| Fase | Complexidade | Explicação |
|------|--------------|------------|
| **🏗️ Build Heap** | O(n) | Heapify de baixo para cima |
| **📥 Extract** | O(n log n) | n extrações de O(log n) |
| **🔄 Total** | O(n log n) | Soma das duas fases |
| **💾 Space** | O(1) | Ordenação in-place |

### 🔍 **Por que Build Heap é O(n)?**
- **📊 Altura dos nós**: Nós em nível h precisam de h comparações
- **🔄 Número de nós**: ~n/2^h nós no nível h
- **⚡ Soma total**: Σ(h * n/2^h) = O(n)
- **📏 Limite superior**: n * Σ(h/2^h) = n * 2 = O(n)

## 🔧 Implementações

### 📝 **Heap Sort Clássico**
```python
def heap_sort_classic(arr):
    n = len(arr)
    
    # Constrói max heap
    for i in range(n // 2 - 1, -1, -1):
        heapify_max(arr, n, i)
    
    # Extrai elementos
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify_max(arr, i, 0)

def heapify_max(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and arr[left] > arr[largest]:
        largest = left
    
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify_max(arr, n, largest)
```

### 📝 **Heap Sort com Min Heap**
```python
def heap_sort_min(arr):
    n = len(arr)
    
    # Constrói min heap
    for i in range(n // 2 - 1, -1, -1):
        heapify_min(arr, n, i)
    
    # Extrai elementos (ordem decrescente)
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify_min(arr, i, 0)
    
    # Inverte para ordem crescente
    arr.reverse()

def heapify_min(arr, n, i):
    smallest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and arr[left] < arr[smallest]:
        smallest = left
    
    if right < n and arr[right] < arr[smallest]:
        smallest = right
    
    if smallest != i:
        arr[i], arr[smallest] = arr[smallest], arr[i]
        heapify_min(arr, n, smallest)
```

### 📝 **Heap Sort Iterativo**
```python
def heap_sort_iterative(arr):
    n = len(arr)
    
    # Build heap iterativo
    for i in range(n // 2 - 1, -1, -1):
        heapify_iterative(arr, n, i)
    
    # Extract iterativo
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify_iterative(arr, i, 0)

def heapify_iterative(arr, n, i):
    while True:
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        
        if left < n and arr[left] > arr[largest]:
            largest = left
        
        if right < n and arr[right] > arr[largest]:
            largest = right
        
        if largest == i:
            break
        
        arr[i], arr[largest] = arr[largest], arr[i]
        i = largest
```

## 🔄 Variações Avançadas

### 📊 **Heap Sort com Custom Comparator**
```python
def heap_sort_custom(arr, key_func=None):
    if key_func is None:
        key_func = lambda x: x
    
    n = len(arr)
    
    # Build heap com função customizada
    for i in range(n // 2 - 1, -1, -1):
        heapify_custom(arr, n, i, key_func)
    
    # Extract com função customizada
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify_custom(arr, i, 0, key_func)

def heapify_custom(arr, n, i, key_func):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and key_func(arr[left]) > key_func(arr[largest]):
        largest = left
    
    if right < n and key_func(arr[right]) > key_func(arr[largest]):
        largest = right
    
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify_custom(arr, n, largest, key_func)

# Exemplo: ordenar por segundo elemento
points = [(1, 3), (2, 1), (3, 2)]
heap_sort_custom(points, key_func=lambda x: x[1])
# Resultado: [(2, 1), (3, 2), (1, 3)]
```

### 📊 **Heap Sort Estável**
```python
def heap_sort_stable(arr):
    # Cria tuplas com índice original
    indexed_arr = [(arr[i], i) for i in range(len(arr))]
    
    n = len(indexed_arr)
    
    # Build heap
    for i in range(n // 2 - 1, -1, -1):
        heapify_stable(indexed_arr, n, i)
    
    # Extract
    for i in range(n - 1, 0, -1):
        indexed_arr[0], indexed_arr[i] = indexed_arr[i], indexed_arr[0]
        heapify_stable(indexed_arr, i, 0)
    
    # Reconstrói array original
    for i in range(n):
        arr[i] = indexed_arr[i][0]

def heapify_stable(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and arr[left] > arr[largest]:
        largest = left
    
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify_stable(arr, n, largest)
```

## ⚡ Otimizações

### 🔧 **Heap Sort Otimizado**
```python
def heap_sort_optimized(arr):
    n = len(arr)
    
    # Build heap otimizado
    for i in range(n // 2 - 1, -1, -1):
        heapify_optimized(arr, n, i)
    
    # Extract otimizado
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify_optimized(arr, i, 0)

def heapify_optimized(arr, n, i):
    # Versão com early exit
    while True:
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        
        if left < n and arr[left] > arr[largest]:
            largest = left
        
        if right < n and arr[right] > arr[largest]:
            largest = right
        
        if largest == i:
            break  # Early exit
        
        arr[i], arr[largest] = arr[largest], arr[i]
        i = largest
```

### 🔧 **Heap Sort com Bottom-Up**
```python
def heap_sort_bottom_up(arr):
    n = len(arr)
    
    # Build heap bottom-up
    for i in range(n - 1, -1, -1):
        heapify_bottom_up(arr, n, i)
    
    # Extract
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify_bottom_up(arr, i, 0)

def heapify_bottom_up(arr, n, i):
    # Versão bottom-up mais eficiente
    while i < n // 2:
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        
        if left < n and arr[left] > arr[largest]:
            largest = left
        
        if right < n and arr[right] > arr[largest]:
            largest = right
        
        if largest == i:
            break
        
        arr[i], arr[largest] = arr[largest], arr[i]
        i = largest
```

## 🎯 Aplicações Práticas

### 🔧 **Sistemas de Computação**
- **📊 Database**: Ordenação de grandes datasets
- **🎮 Game Engines**: Ordenação de objetos por distância
- **🌐 Networking**: Ordenação de pacotes por prioridade
- **🔧 Operating Systems**: Ordenação de processos

### 📊 **Algoritmos**
- **🔍 Top-k**: Encontrar k maiores/menores elementos
- **📝 External Sort**: Ordenação de arquivos grandes
- **🎯 Priority Scheduling**: Agendamento por prioridade
- **🔄 Event Processing**: Processamento de eventos ordenados

## 💡 Dicas de Implementação

### 🎯 **Pontos-Chave**
- **📊 Use max heap**: Para ordenação crescente
- **🔄 Controle índices**: Evite out-of-bounds
- **⚡ Otimize heapify**: Use early exit
- **📏 Mantenha propriedades**: Heap property durante extração

### 🔧 **Casos Especiais**
- **📊 Array vazio**: Trate adequadamente
- **🔄 Array com um elemento**: Caso base
- **⚡ Elementos iguais**: Considere estabilidade
- **📏 Arrays grandes**: Use otimizações

### 🎯 **Debugging**
- **📊 Valide heap property**: Após build heap
- **🔄 Verifique índices**: Durante heapify
- **⚡ Teste extremos**: Array vazio, um elemento
- **📏 Trace operações**: Para encontrar bugs 