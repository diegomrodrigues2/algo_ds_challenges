# 🔧 Aplicações Avançadas do Priority Queue

## 🎯 Visão Geral

Priority Queues são fundamentais para **muitos algoritmos avançados** e sistemas práticos. Sua capacidade de manter elementos ordenados por prioridade torna-os essenciais para algoritmos de grafos, sistemas de agendamento e processamento de dados.

## 🎯 K-ésimo Menor Elemento

### 🌟 **Problema**
Encontrar o **k-ésimo menor elemento** em um array sem ordenar todo o array.

### 📝 **Implementação**
```python
def kth_smallest(nums, k):
    # Usa max heap para manter k menores elementos
    max_heap = []
    
    for num in nums:
        if len(max_heap) < k:
            # Adiciona se heap não está cheio
            heapq.heappush(max_heap, -num)  # Negativo para max heap
        elif -num > max_heap[0]:
            # Substitui se é menor que o maior do heap
            heapq.heapreplace(max_heap, -num)
    
    return -max_heap[0]  # Retorna o k-ésimo menor

def kth_smallest_optimized(nums, k):
    # Versão otimizada com early exit
    if k > len(nums):
        return None
    
    max_heap = []
    
    for num in nums:
        if len(max_heap) < k:
            heapq.heappush(max_heap, -num)
        elif -num > max_heap[0]:
            heapq.heapreplace(max_heap, -num)
    
    return -max_heap[0]

# Exemplo de uso
nums = [3, 1, 4, 1, 5, 9, 2, 6]
k = 3
result = kth_smallest(nums, k)  # Retorna 2 (3º menor)
```

### 🎯 **Exemplo Visual**
```
Array: [3, 1, 4, 1, 5, 9, 2, 6]
k = 3

Passo 1: Heap = [-3] (k=1)
Passo 2: Heap = [-3, -1] (k=2)
Passo 3: Heap = [-3, -1, -4] (k=3)
Passo 4: 1 < 4, substitui → Heap = [-3, -1, -1]
Passo 5: 5 > 1, ignora
Passo 6: 9 > 1, ignora
Passo 7: 2 < 3, substitui → Heap = [-2, -1, -1]
Passo 8: 6 > 2, ignora

Resultado: 2 (3º menor elemento)
```

## 🔄 Merge de Listas Ordenadas

### 🌟 **Problema**
Mesclar **k listas ordenadas** em uma única lista ordenada de forma eficiente.

### 📝 **Implementação**
```python
def merge_k_sorted_lists(lists):
    # Usa min heap para manter o menor elemento de cada lista
    min_heap = []
    result = []
    
    # Adiciona primeiro elemento de cada lista
    for i, lst in enumerate(lists):
        if lst:  # Se lista não está vazia
            heapq.heappush(min_heap, (lst[0], i, 0))
    
    # Processa elementos
    while min_heap:
        value, list_idx, element_idx = heapq.heappop(min_heap)
        result.append(value)
        
        # Adiciona próximo elemento da mesma lista
        if element_idx + 1 < len(lists[list_idx]):
            next_element = lists[list_idx][element_idx + 1]
            heapq.heappush(min_heap, (next_element, list_idx, element_idx + 1))
    
    return result

def merge_k_sorted_lists_optimized(lists):
    # Versão otimizada com early exit
    min_heap = []
    result = []
    
    # Filtra listas vazias
    valid_lists = [(i, lst) for i, lst in enumerate(lists) if lst]
    
    if not valid_lists:
        return result
    
    # Adiciona primeiros elementos
    for list_idx, lst in valid_lists:
        heapq.heappush(min_heap, (lst[0], list_idx, 0))
    
    # Processa elementos
    while min_heap:
        value, list_idx, element_idx = heapq.heappop(min_heap)
        result.append(value)
        
        # Adiciona próximo elemento se disponível
        if element_idx + 1 < len(lists[list_idx]):
            next_element = lists[list_idx][element_idx + 1]
            heapq.heappush(min_heap, (next_element, list_idx, element_idx + 1))
    
    return result

# Exemplo de uso
lists = [
    [1, 4, 5],
    [1, 3, 4],
    [2, 6]
]
result = merge_k_sorted_lists(lists)  # [1, 1, 2, 3, 4, 4, 5, 6]
```

### 🎯 **Exemplo Visual**
```
Listas: [1,4,5], [1,3,4], [2,6]

Passo 1: Heap = [(1,0,0), (1,1,0), (2,2,0)]
         Result = []

Passo 2: Remove (1,0,0) → Heap = [(1,1,0), (2,2,0)]
         Add (4,0,1) → Heap = [(1,1,0), (2,2,0), (4,0,1)]
         Result = [1]

Passo 3: Remove (1,1,0) → Heap = [(2,2,0), (4,0,1)]
         Add (3,1,1) → Heap = [(2,2,0), (3,1,1), (4,0,1)]
         Result = [1, 1]

Resultado: [1, 1, 2, 3, 4, 4, 5, 6]
```

## 🔍 Dijkstra's Algorithm

### 🌟 **Problema**
Encontrar o **caminho mais curto** de um vértice para todos os outros em um grafo ponderado.

### 📝 **Implementação**
```python
def dijkstra(graph, start):
    # Priority queue para manter vértices ordenados por distância
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start] = 0
    
    pq = [(0, start)]
    visited = set()
    
    while pq:
        current_distance, current_vertex = heapq.heappop(pq)
        
        if current_vertex in visited:
            continue
        
        visited.add(current_vertex)
        
        # Explora vizinhos
        for neighbor, weight in graph[current_vertex].items():
            distance = current_distance + weight
            
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(pq, (distance, neighbor))
    
    return distances

def dijkstra_with_path(graph, start, end):
    # Versão que retorna o caminho
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start] = 0
    previous = {vertex: None for vertex in graph}
    
    pq = [(0, start)]
    visited = set()
    
    while pq:
        current_distance, current_vertex = heapq.heappop(pq)
        
        if current_vertex in visited:
            continue
        
        visited.add(current_vertex)
        
        if current_vertex == end:
            break
        
        for neighbor, weight in graph[current_vertex].items():
            distance = current_distance + weight
            
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                previous[neighbor] = current_vertex
                heapq.heappush(pq, (distance, neighbor))
    
    # Reconstrói caminho
    path = []
    current = end
    while current is not None:
        path.append(current)
        current = previous[current]
    
    return distances[end], path[::-1]

# Exemplo de uso
graph = {
    'A': {'B': 4, 'C': 2},
    'B': {'A': 4, 'C': 1, 'D': 5},
    'C': {'A': 2, 'B': 1, 'D': 8, 'E': 10},
    'D': {'B': 5, 'C': 8, 'E': 2},
    'E': {'C': 10, 'D': 2}
}

distances = dijkstra(graph, 'A')
# Resultado: {'A': 0, 'B': 3, 'C': 2, 'D': 8, 'E': 10}
```

## 🎮 Sistemas de Agendamento

### 🌟 **Priority-Based Scheduler**
```python
class PriorityScheduler:
    def __init__(self):
        self.tasks = []
        self.current_time = 0
    
    def add_task(self, task_id, priority, duration, arrival_time):
        self.tasks.append({
            'id': task_id,
            'priority': priority,
            'duration': duration,
            'arrival_time': arrival_time,
            'remaining_time': duration
        })
    
    def schedule(self):
        # Ordena por prioridade (maior primeiro) e tempo de chegada
        ready_tasks = [
            task for task in self.tasks 
            if task['arrival_time'] <= self.current_time and task['remaining_time'] > 0
        ]
        
        if not ready_tasks:
            self.current_time += 1
            return None
        
        # Seleciona tarefa de maior prioridade
        selected_task = max(ready_tasks, key=lambda x: (x['priority'], -x['arrival_time']))
        
        # Executa por 1 unidade de tempo
        selected_task['remaining_time'] -= 1
        self.current_time += 1
        
        return selected_task['id']
    
    def is_complete(self):
        return all(task['remaining_time'] <= 0 for task in self.tasks)

# Exemplo de uso
scheduler = PriorityScheduler()
scheduler.add_task('T1', priority=3, duration=5, arrival_time=0)
scheduler.add_task('T2', priority=1, duration=3, arrival_time=1)
scheduler.add_task('T3', priority=2, duration=4, arrival_time=2)

while not scheduler.is_complete():
    task = scheduler.schedule()
    if task:
        print(f"Executando: {task}")
```

### 🌟 **Real-Time Scheduler**
```python
class RealTimeScheduler:
    def __init__(self):
        self.tasks = []
        self.current_time = 0
    
    def add_periodic_task(self, task_id, period, execution_time, deadline):
        self.tasks.append({
            'id': task_id,
            'period': period,
            'execution_time': execution_time,
            'deadline': deadline,
            'next_release': 0,
            'remaining_time': 0
        })
    
    def schedule_edf(self):
        # Earliest Deadline First
        ready_tasks = [
            task for task in self.tasks
            if task['next_release'] <= self.current_time and task['remaining_time'] > 0
        ]
        
        if not ready_tasks:
            self.current_time += 1
            return None
        
        # Seleciona tarefa com deadline mais próximo
        selected_task = min(ready_tasks, key=lambda x: x['deadline'])
        
        # Executa por 1 unidade de tempo
        selected_task['remaining_time'] -= 1
        self.current_time += 1
        
        # Verifica se tarefa terminou
        if selected_task['remaining_time'] <= 0:
            selected_task['next_release'] += selected_task['period']
            selected_task['remaining_time'] = selected_task['execution_time']
        
        return selected_task['id']
```

## 📊 Median Finder

### 🌟 **Problema**
Manter a **mediana** de um stream de números de forma eficiente.

### 📝 **Implementação**
```python
class MedianFinder:
    def __init__(self):
        # Max heap para metade menor
        self.max_heap = []
        # Min heap para metade maior
        self.min_heap = []
    
    def add_num(self, num):
        # Adiciona no max heap primeiro
        heapq.heappush(self.max_heap, -num)
        
        # Move maior elemento do max heap para min heap
        heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap))
        
        # Balanceia os heaps
        if len(self.max_heap) < len(self.min_heap):
            heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap))
    
    def find_median(self):
        if len(self.max_heap) > len(self.min_heap):
            return -self.max_heap[0]
        else:
            return (-self.max_heap[0] + self.min_heap[0]) / 2

# Exemplo de uso
finder = MedianFinder()
finder.add_num(1)    # Median: 1
finder.add_num(2)    # Median: 1.5
finder.add_num(3)    # Median: 2
finder.add_num(4)    # Median: 2.5
finder.add_num(5)    # Median: 3
```

## 🎯 Top-K Elements

### 🌟 **Problema**
Encontrar os **k elementos mais frequentes** em um array.

### 📝 **Implementação**
```python
def top_k_frequent(nums, k):
    # Conta frequências
    frequency = {}
    for num in nums:
        frequency[num] = frequency.get(num, 0) + 1
    
    # Usa min heap para manter k mais frequentes
    min_heap = []
    
    for num, freq in frequency.items():
        if len(min_heap) < k:
            heapq.heappush(min_heap, (freq, num))
        elif freq > min_heap[0][0]:
            heapq.heapreplace(min_heap, (freq, num))
    
    # Retorna elementos em ordem decrescente
    result = []
    while min_heap:
        result.append(heapq.heappop(min_heap)[1])
    
    return result[::-1]

# Exemplo de uso
nums = [1, 1, 1, 2, 2, 3, 3, 3, 3, 4]
k = 2
result = top_k_frequent(nums, k)  # [3, 1]
```

## 💡 Dicas de Implementação

### 🎯 **Pontos-Chave**
- **📊 Escolha heap adequado**: Min ou max baseado no problema
- **🔄 Considere complexidade**: Amortizada vs pior caso
- **⚡ Otimize operações**: Use heapreplace quando possível
- **📏 Controle memória**: Para streams grandes

### 🔧 **Otimizações**
- **📊 Early exit**: Para problemas com condições de parada
- **🔄 Batch processing**: Para múltiplas operações
- **⚡ Custom comparators**: Para prioridades complexas
- **📏 Memory pooling**: Reutilizar estruturas

### 🎯 **Casos Especiais**
- **📊 Heap vazio**: Trate adequadamente
- **🔄 Elementos iguais**: Considere estabilidade
- **⚡ Streams infinitos**: Use bounded heaps
- **📏 Prioridades dinâmicas**: Atualize quando necessário 