# 🔄 Queue

## 🎯 O que é uma Queue?

**Queue** é uma estrutura de dados linear que segue o princípio **FIFO** (First In, First Out). É como uma fila de pessoas onde o primeiro a chegar é o primeiro a ser atendido.

### 🌟 **Propriedade Fundamental**
```
FIFO: First In, First Out
- Primeiro elemento inserido é o primeiro a ser removido
- Acesso apenas ao elemento da frente
```

## 🔄 Como Funciona

### 📊 **Analogia Simples**
> **Fila de Banco**: Como uma fila de pessoas no banco - quem chega primeiro é atendido primeiro. Não é possível "furar" a fila.

### 🎯 **Operações Principais**
1. **📤 Enqueue**: Adiciona elemento no final
2. **📥 Dequeue**: Remove elemento do início
3. **👀 Peek/Front**: Visualiza primeiro elemento
4. **📏 Size**: Retorna número de elementos
5. **🔍 Empty**: Verifica se está vazia

## 📊 Implementação com Array

### 🎯 **Estrutura Básica**
```python
class Queue:
    def __init__(self):
        self._data = []
        self._size = 0
    
    def enqueue(self, value):
        self._data.append(value)
        self._size += 1
    
    def dequeue(self):
        if self.is_empty():
            raise IndexError("Queue vazia")
        self._size -= 1
        return self._data.pop(0)
    
    def front(self):
        if self.is_empty():
            raise IndexError("Queue vazia")
        return self._data[0]
    
    def size(self):
        return self._size
    
    def is_empty(self):
        return self._size == 0
```

### 🎨 **Representação Visual**
```
Queue: [A, B, C, D]
       ↑        ↑
     Front    Back

Enqueue(E): [A, B, C, D, E]
             ↑           ↑
           Front       Back

Dequeue(): [B, C, D, E]
            ↑        ↑
          Front    Back
```

## ⚡ Complexidade das Operações

### 📈 **Análise de Complexidade**
| Operação | Complexidade | Explicação |
|----------|--------------|------------|
| **📤 Enqueue** | O(1) | Inserção no final do array |
| **📥 Dequeue** | O(n) | Remoção do início (shift) |
| **👀 Peek/Front** | O(1) | Acesso ao primeiro elemento |
| **📏 Size** | O(1) | Contador mantido |
| **🔍 Empty** | O(1) | Verificação de tamanho |

### 🔍 **Problema do Dequeue O(n)**
- **📊 Shift necessário**: Após remover do início, todos os elementos se movem
- **🔄 Ineficiência**: Para filas grandes, isso é custoso
- **⚡ Soluções**: Circular queue, linked list, ou duas stacks

## ✅ Vantagens vs ❌ Desvantagens

| Aspecto | ✅ Vantagem | ❌ Desvantagem |
|---------|-------------|----------------|
| **⚡ Enqueue** | O(1) - rápido | Dequeue O(n) - lento |
| **💾 Memória** | Eficiente | Pode crescer dinamicamente |
| **🔄 Simplicidade** | Fácil de implementar | Dequeue ineficiente |
| **📊 Flexibilidade** | Cresce automaticamente | Não permite acesso aleatório |

## 🎯 Aplicações Práticas

### 🔧 **Sistemas de Computação**
- **🌐 Networking**: Pacotes de rede em ordem
- **🎮 Game Loops**: Processamento de eventos
- **📊 Print Spooler**: Impressão de documentos
- **🔧 Task Scheduler**: Sistemas operacionais

### 📊 **Algoritmos**
- **🔍 Breadth-First Search**: Exploração de grafos
- **📝 Level-order Traversal**: Percursos em árvores
- **🔄 Simulation**: Eventos em ordem temporal
- **🎯 Buffer Management**: Dados em streaming

### 🏗️ **Sistemas Reais**
- **🏥 Hospital**: Fila de pacientes
- **🏦 Banco**: Fila de atendimento
- **🎬 Cinema**: Fila de ingressos
- **🚗 Trânsito**: Fila de carros

## 🔄 Propriedades Matemáticas

### 📊 **Invariantes**
- **📏 Tamanho**: Sempre não-negativo
- **🔄 FIFO**: Ordem de remoção igual à inserção
- **📦 Capacidade**: Pode crescer indefinidamente

### 🎯 **Operações Válidas**
```
Enqueue → Queue pode crescer
Dequeue → Queue não vazia
Peek → Queue não vazia
```

## 💡 Dicas de Implementação

### 🎯 **Pontos-Chave**
- **📊 Use list**: Implementação mais simples
- **🔄 Controle tamanho**: Mantenha contador atualizado
- **⚡ Verifique vazia**: Antes de dequeue/peek
- **📏 Otimize dequeue**: Considere implementações alternativas

### 🔧 **Otimizações**
- **📊 Pre-allocation**: Defina tamanho inicial se conhecido
- **🔄 Circular buffer**: Para evitar shift
- **⚡ Linked list**: Para dequeue O(1)
- **📏 Capacity management**: Controlar crescimento

## 🎯 Comparação com Outras Estruturas

| Estrutura | Inserção | Remoção | Acesso | Propriedade |
|-----------|----------|---------|--------|-------------|
| **🔄 Queue** | O(1) | O(n) | O(1) frente | FIFO |
| **📊 Array** | O(1) | O(n) | O(1) | Aleatório |
| **📦 Stack** | O(1) | O(1) | O(1) topo | LIFO |
| **🔄 Deque** | O(1) | O(1) | O(1) | Ambos |

## 🔄 Variações Importantes

### 📊 **Queue com Capacidade Fixa**
```python
class FixedQueue:
    def __init__(self, capacity):
        self._data = [None] * capacity
        self._front = 0
        self._rear = 0
        self._size = 0
        self._capacity = capacity
    
    def enqueue(self, value):
        if self.is_full():
            raise OverflowError("Queue cheia")
        
        self._data[self._rear] = value
        self._rear = (self._rear + 1) % self._capacity
        self._size += 1
    
    def dequeue(self):
        if self.is_empty():
            raise IndexError("Queue vazia")
        
        value = self._data[self._front]
        self._front = (self._front + 1) % self._capacity
        self._size -= 1
        return value
```

### 🔄 **Queue com Linked List**
```python
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

class LinkedListQueue:
    def __init__(self):
        self._front = None
        self._rear = None
        self._size = 0
    
    def enqueue(self, value):
        new_node = Node(value)
        
        if self.is_empty():
            self._front = self._rear = new_node
        else:
            self._rear.next = new_node
            self._rear = new_node
        
        self._size += 1
    
    def dequeue(self):
        if self.is_empty():
            raise IndexError("Queue vazia")
        
        value = self._front.value
        self._front = self._front.next
        
        if self._front is None:
            self._rear = None
        
        self._size -= 1
        return value
```

## 💡 Dicas de Debugging

### 🎯 **Problemas Comuns**
- **📊 Queue underflow**: Dequeue em queue vazia
- **🔄 Queue overflow**: Enqueue em queue cheia
- **⚡ Memory leaks**: Não limpar referências
- **📏 Size mismatch**: Contador desatualizado

### 🔧 **Soluções**
- **📊 Sempre verificar**: Empty antes de dequeue/peek
- **🔄 Usar try/catch**: Para operações críticas
- **⚡ Validar entrada**: Verificar parâmetros
- **📏 Testar extremos**: Queue vazia, um elemento 