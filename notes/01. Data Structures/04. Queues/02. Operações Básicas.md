# 🔄 Operações Básicas do Queue

## 🎯 Visão Geral

As operações básicas do queue garantem o funcionamento correto da estrutura **FIFO**. Cada operação tem complexidade específica e mantém as propriedades fundamentais da fila.

## 📤 Enqueue (Inserção)

### 🌟 **Processo de Inserção**
1. **📝 Adiciona elemento** no final do array
2. **📏 Incrementa contador** de tamanho
3. **✅ Retorna sucesso** (ou exceção se cheia)

### 📝 **Implementação**
```python
def enqueue(self, value):
    # Adiciona no final (back da fila)
    self._data.append(value)
    self._size += 1

def enqueue_with_capacity(self, value):
    # Versão com verificação de capacidade
    if self._size >= self._capacity:
        raise OverflowError("Queue cheia")
    
    self._data.append(value)
    self._size += 1
```

### 🎯 **Exemplo Visual**
```
Queue: [A, B, C]
       ↑     ↑
     Front  Back

Enqueue(D): [A, B, C, D]
             ↑        ↑
           Front    Back

Enqueue(E): [A, B, C, D, E]
             ↑           ↑
           Front       Back
```

## 📥 Dequeue (Remoção)

### 🌟 **Processo de Remoção**
1. **🔍 Verifica se vazia** (queue underflow)
2. **📝 Remove elemento** do início do array
3. **📏 Decrementa contador** de tamanho
4. **🔄 Retorna elemento** removido

### 📝 **Implementação**
```python
def dequeue(self):
    # Verifica se queue está vazia
    if self.is_empty():
        raise IndexError("Queue vazia")
    
    # Remove e retorna o primeiro elemento
    self._size -= 1
    return self._data.pop(0)

def dequeue_with_validation(self):
    # Versão com validação adicional
    if self.is_empty():
        raise IndexError("Queue vazia")
    
    # Remove elemento
    value = self._data[0]
    self._data = self._data[1:]  # Shift todos os elementos
    self._size -= 1
    
    return value
```

### 🎯 **Exemplo Visual**
```
Queue: [A, B, C, D, E]
        ↑           ↑
      Front       Back

Dequeue(): [B, C, D, E]  # Retorna A
            ↑        ↑
          Front    Back

Dequeue(): [C, D, E]     # Retorna B
             ↑        ↑
           Front    Back
```

## 👀 Peek/Front (Visualização)

### 🌟 **Processo de Visualização**
1. **🔍 Verifica se vazia**
2. **👀 Retorna elemento** da frente sem remover
3. **✅ Mantém estrutura** inalterada

### 📝 **Implementação**
```python
def front(self):
    if self.is_empty():
        raise IndexError("Queue vazia")
    
    return self._data[0]

def peek(self):
    # Alias para front()
    return self.front()

def front_with_index(self):
    # Versão que retorna índice também
    if self.is_empty():
        raise IndexError("Queue vazia")
    
    return self._data[0], 0
```

### 🎯 **Exemplo Visual**
```
Queue: [A, B, C, D]
        ↑        ↑
      Front    Back

Front(): Retorna A (queue inalterada)
         [A, B, C, D]
          ↑        ↑
        Front    Back
```

## 📏 Size e Empty

### 📊 **Verificação de Tamanho**
```python
def size(self):
    return self._size

def is_empty(self):
    return self._size == 0

def is_full(self):
    return self._size >= self._capacity  # Para queue com capacidade
```

### 🎯 **Verificações Úteis**
```python
def has_elements(self):
    return not self.is_empty()

def can_enqueue(self):
    return self._size < self._capacity  # Para queue com capacidade

def get_capacity(self):
    return self._capacity  # Para queue com capacidade
```

## 🔄 Implementações Iterativas

### 📊 **Iteração sobre Queue**
```python
def __iter__(self):
    # Itera da frente para o final
    for i in range(self._size):
        yield self._data[i]

def iterate_reverse(self):
    # Itera do final para a frente
    for i in range(self._size - 1, -1, -1):
        yield self._data[i]

def to_list(self):
    # Converte para lista (frente primeiro)
    return self._data[:self._size]
```

### 🎯 **Busca em Queue**
```python
def contains(self, value):
    # Busca linear O(n)
    for i in range(self._size):
        if self._data[i] == value:
            return True
    return False

def find(self, value):
    # Retorna posição (da frente)
    for i in range(self._size):
        if self._data[i] == value:
            return i
    return -1
```

## 🔧 Operações Avançadas

### 🗑️ **Clear (Limpar)**
```python
def clear(self):
    # Limpa todos os elementos
    self._data.clear()
    self._size = 0

def clear_with_capacity(self):
    # Mantém capacidade, limpa elementos
    self._data = [None] * self._capacity
    self._size = 0
```

### 📊 **Copy (Cópia)**
```python
def copy(self):
    # Cria cópia superficial
    new_queue = Queue()
    new_queue._data = self._data.copy()
    new_queue._size = self._size
    return new_queue

def deep_copy(self):
    # Cria cópia profunda (se necessário)
    import copy
    new_queue = Queue()
    new_queue._data = copy.deepcopy(self._data)
    new_queue._size = self._size
    return new_queue
```

### 🔄 **Reverse (Inverter)**
```python
def reverse(self):
    # Inverte ordem dos elementos
    self._data[:self._size] = self._data[:self._size][::-1]

def reverse_without_mutation(self):
    # Retorna nova queue invertida
    new_queue = Queue()
    for item in reversed(list(self)):
        new_queue.enqueue(item)
    return new_queue
```

## ⚡ Otimizações

### 🔧 **Enqueue Otimizado**
```python
def enqueue_optimized(self, value):
    # Evita redimensionamento frequente
    if len(self._data) <= self._size:
        self._data.append(value)
    else:
        self._data[self._size] = value
    self._size += 1
```

### 🔧 **Dequeue Otimizado**
```python
def dequeue_optimized(self):
    if self.is_empty():
        raise IndexError("Queue vazia")
    
    self._size -= 1
    value = self._data[0]
    
    # Shift otimizado
    for i in range(self._size):
        self._data[i] = self._data[i + 1]
    self._data[self._size] = None  # Ajuda GC
    
    return value
```

## 💡 Dicas de Implementação

### 🎯 **Pontos-Chave**
- **📊 Sempre verifique vazia**: Antes de dequeue/peek
- **🔄 Mantenha contador**: Size sempre atualizado
- **⚡ Use append**: Para enqueue eficiente
- **📏 Controle capacidade**: Para queues fixas

### 🔧 **Casos Especiais**
- **📊 Queue vazia**: Trate adequadamente
- **🔄 Queue cheia**: Para capacidades fixas
- **⚡ Elemento único**: Caso base
- **📏 Capacidade zero**: Queue inválida

### 🎯 **Debugging**
- **📊 Valide índices**: Evite out-of-bounds
- **🔄 Verifique contadores**: Size consistente
- **⚡ Teste extremos**: Vazia, cheia, um elemento
- **📏 Trace operações**: Para encontrar bugs 