# ğŸ“Š ImplementaÃ§Ãµes PrÃ¡ticas: ComparaÃ§Ã£o Direta

## ğŸ¯ Objetivo

Implementar e comparar **diretamente** as inserÃ§Ãµes em Ãrvores AVL e Red-Black, demonstrando os **trade-offs prÃ¡ticos** entre as duas estruturas.

## ğŸ“ Desafio 1: InserÃ§Ã£o AVL (`insert_avl.py`)

### ğŸ¯ EstratÃ©gia de ImplementaÃ§Ã£o

**Algoritmo:**
1. **InserÃ§Ã£o BST** padrÃ£o
2. **Atualizar altura** do nÃ³
3. **Calcular fator** de balanceamento
4. **Aplicar rotaÃ§Ãµes** se necessÃ¡rio

### ğŸ” PseudocÃ³digo Detalhado

```python
def insert_avl(root, value):
    # 1. InserÃ§Ã£o BST padrÃ£o
    if root is None:
        return TreeNode(value, height=1)
    
    if value < root.value:
        root.left = insert_avl(root.left, value)
    else:
        root.right = insert_avl(root.right, value)
    
    # 2. Atualizar altura
    root.height = 1 + max(height(root.left), height(root.right))
    
    # 3. Calcular fator de balanceamento
    balance = balance_factor(root)
    
    # 4. Casos de desbalanceamento
    # Left-Left
    if balance > 1 and value < root.left.value:
        return rotate_right(root)
    
    # Right-Right
    if balance < -1 and value > root.right.value:
        return rotate_left(root)
    
    # Left-Right
    if balance > 1 and value > root.left.value:
        root.left = rotate_left(root.left)
        return rotate_right(root)
    
    # Right-Left
    if balance < -1 and value < root.right.value:
        root.right = rotate_right(root.right)
        return rotate_left(root)
    
    return root

def balance_factor(node):
    return height(node.left) - height(node.right)

def height(node):
    return node.height if node else 0
```

### âš¡ AnÃ¡lise de Complexidade

| Aspecto | Complexidade | ExplicaÃ§Ã£o |
|---------|--------------|------------|
| **Tempo** | O(log n) | Altura logarÃ­tmica |
| **EspaÃ§o** | O(log n) | Stack de recursÃ£o |
| **RotaÃ§Ãµes** | MÃ¡ximo 2 | Por inserÃ§Ã£o |

### ğŸ§ª Casos de Teste Essenciais

```python
# Teste 1: InserÃ§Ã£o simples
root = insert_avl(None, 10)
assert root.value == 10
assert root.height == 1

# Teste 2: InserÃ§Ã£o que requer rotaÃ§Ã£o LL
root = insert_avl(root, 5)
root = insert_avl(root, 2)  # Deve causar rotaÃ§Ã£o
assert root.value == 5  # Nova raiz apÃ³s rotaÃ§Ã£o

# Teste 3: InserÃ§Ã£o que requer rotaÃ§Ã£o LR
root = insert_avl(root, 1)
root = insert_avl(root, 3)  # Deve causar rotaÃ§Ã£o dupla
```

## ğŸ“ Desafio 2: InserÃ§Ã£o Red-Black (`insert_red_black.py`)

### ğŸ¯ EstratÃ©gia de ImplementaÃ§Ã£o

**Algoritmo:**
1. **InserÃ§Ã£o BST** padrÃ£o
2. **Colorir nÃ³** como vermelho
3. **Corrigir propriedades** Red-Black
4. **Aplicar rotaÃ§Ãµes/recoloraÃ§Ãµes** se necessÃ¡rio

### ğŸ” PseudocÃ³digo Detalhado

```python
def insert_red_black(root, value):
    # 1. InserÃ§Ã£o BST padrÃ£o
    if root is None:
        return RBNode(value, BLACK)  # Raiz sempre preta
    
    if value < root.value:
        root.left = insert_red_black(root.left, value)
        root.left.parent = root
    else:
        root.right = insert_red_black(root.right, value)
        root.right.parent = root
    
    # 2. Corrigir propriedades Red-Black
    return fix_red_black_properties(root)

def fix_red_black_properties(node):
    # Caso 1: NÃ³ Ã© raiz
    if node.parent is None:
        node.color = BLACK
        return node
    
    # Caso 2: Pai Ã© preto
    if node.parent.color == BLACK:
        return node
    
    # Caso 3: Pai Ã© vermelho
    uncle = get_uncle(node)
    
    # Caso 3a: Tio Ã© vermelho
    if uncle and uncle.color == RED:
        node.parent.color = BLACK
        uncle.color = BLACK
        node.parent.parent.color = RED
        return fix_red_black_properties(node.parent.parent)
    
    # Caso 3b: Tio Ã© preto
    return fix_red_black_rotations(node)

def get_uncle(node):
    if node.parent.parent.left == node.parent:
        return node.parent.parent.right
    return node.parent.parent.left
```

### âš¡ AnÃ¡lise de Complexidade

| Aspecto | Complexidade | ExplicaÃ§Ã£o |
|---------|--------------|------------|
| **Tempo** | O(log n) | Altura logarÃ­tmica |
| **EspaÃ§o** | O(log n) | Stack de recursÃ£o |
| **RotaÃ§Ãµes** | MÃ¡ximo 3 | Por inserÃ§Ã£o |

### ğŸ§ª Casos de Teste Essenciais

```python
# Teste 1: InserÃ§Ã£o simples
root = insert_red_black(None, 10)
assert root.value == 10
assert root.color == BLACK

# Teste 2: InserÃ§Ã£o que requer recolorizaÃ§Ã£o
root = insert_red_black(root, 5)
root = insert_red_black(root, 15)
root = insert_red_black(root, 3)  # Deve causar recolorizaÃ§Ã£o

# Teste 3: InserÃ§Ã£o que requer rotaÃ§Ã£o
root = insert_red_black(root, 1)  # Deve causar rotaÃ§Ã£o
```

## ğŸ“Š ComparaÃ§Ã£o Direta

### ğŸ”„ **FrequÃªncia de RotaÃ§Ãµes**

| CenÃ¡rio | AVL Trees | Red-Black Trees |
|---------|-----------|-----------------|
| **InserÃ§Ã£o Simples** | 0 rotaÃ§Ãµes | 0 rotaÃ§Ãµes |
| **InserÃ§Ã£o com RotaÃ§Ãµes** | 1-2 rotaÃ§Ãµes | 0-3 rotaÃ§Ãµes |
| **SequÃªncia Crescente** | O(log n) rotaÃ§Ãµes | O(1) rotaÃ§Ãµes |
| **SequÃªncia AleatÃ³ria** | Poucas rotaÃ§Ãµes | Poucas rotaÃ§Ãµes |

### âš¡ **Performance PrÃ¡tica**

```python
# Benchmark: InserÃ§Ã£o de 1000 elementos
def benchmark_insertion():
    # AVL Trees
    avl_root = None
    avl_start = time.time()
    for i in range(1000):
        avl_root = insert_avl(avl_root, i)
    avl_time = time.time() - avl_start
    
    # Red-Black Trees
    rb_root = None
    rb_start = time.time()
    for i in range(1000):
        rb_root = insert_red_black(rb_root, i)
    rb_time = time.time() - rb_start
    
    return avl_time, rb_time

# Resultado tÃ­pico:
# AVL: ~0.15 segundos
# Red-Black: ~0.12 segundos
```

### ğŸ“ˆ **AnÃ¡lise de Altura**

```python
def compare_heights():
    # Construir Ã¡rvores idÃªnticas
    values = [10, 5, 15, 3, 7, 12, 18, 1, 4, 6, 8, 11, 13, 16, 19]
    
    # AVL Tree
    avl_root = None
    for v in values:
        avl_root = insert_avl(avl_root, v)
    
    # Red-Black Tree
    rb_root = None
    for v in values:
        rb_root = insert_red_black(rb_root, v)
    
    avl_height = get_height(avl_root)
    rb_height = get_height(rb_root)
    
    return avl_height, rb_height

# Resultado tÃ­pico:
# AVL height: 4
# Red-Black height: 5
```

## ğŸ” Debugging e VerificaÃ§Ã£o

### ğŸ¯ **VerificaÃ§Ã£o AVL**

```python
def verify_avl_properties(root):
    if root is None:
        return True
    
    # Verificar propriedade BST
    if not is_bst_property(root):
        return False
    
    # Verificar fator de balanceamento
    balance = balance_factor(root)
    if abs(balance) > 1:
        return False
    
    # Verificar altura
    expected_height = 1 + max(height(root.left), height(root.right))
    if root.height != expected_height:
        return False
    
    return (verify_avl_properties(root.left) and 
            verify_avl_properties(root.right))
```

### ğŸ”´ **VerificaÃ§Ã£o Red-Black**

```python
def verify_red_black_properties(root):
    if root is None:
        return True
    
    # Verificar propriedade BST
    if not is_bst_property(root):
        return False
    
    # Verificar regras Red-Black
    return (is_red_black_valid(root) and 
            black_height_consistent(root))

def is_red_black_valid(node):
    if node is None:
        return True
    
    # Regra 1: Raiz Ã© preta
    if node.parent is None and node.color != BLACK:
        return False
    
    # Regra 2: NÃ³s vermelhos nÃ£o tÃªm filhos vermelhos
    if node.color == RED:
        if (node.left and node.left.color == RED or
            node.right and node.right.color == RED):
            return False
    
    return (is_red_black_valid(node.left) and 
            is_red_black_valid(node.right))
```

## ğŸ’¡ Insights PrÃ¡ticos

### ğŸ¯ 1. Complexidade de ImplementaÃ§Ã£o
**AVL:** Mais complexa devido aos 4 casos de rotaÃ§Ã£o
**Red-Black:** Mais simples devido Ã s regras de cores

### ğŸ”„ 2. FrequÃªncia de RotaÃ§Ãµes
**AVL:** Mais rotaÃ§Ãµes, especialmente em sequÃªncias ordenadas
**Red-Black:** Menos rotaÃ§Ãµes, mais recolorizaÃ§Ãµes

### âš¡ 3. Performance Real
**AVL:** Melhor para busca intensiva
**Red-Black:** Melhor para modificaÃ§Ãµes intensivas

### ğŸ¯ 4. Escolha PrÃ¡tica
**AVL:** Quando busca Ã© crÃ­tica
**Red-Black:** Quando modificaÃ§Ãµes sÃ£o crÃ­ticas

## ğŸš€ AplicaÃ§Ãµes PrÃ¡ticas

### ğŸŒŸ **Quando Usar AVL**
```python
# Sistema de cache com poucas modificaÃ§Ãµes
class AVLCache:
    def __init__(self):
        self.root = None
    
    def get(self, key):
        # Busca rÃ¡pida - O(log n)
        return search_avl(self.root, key)
    
    def put(self, key, value):
        # InserÃ§Ã£o ocasional
        self.root = insert_avl(self.root, key)
```

### ğŸ”´ **Quando Usar Red-Black**
```python
# Agendador de tarefas com modificaÃ§Ãµes frequentes
class RedBlackScheduler:
    def __init__(self):
        self.root = None
    
    def add_task(self, priority, task):
        # InserÃ§Ã£o rÃ¡pida - O(log n)
        self.root = insert_red_black(self.root, priority)
    
    def remove_task(self, priority):
        # RemoÃ§Ã£o rÃ¡pida - O(log n)
        self.root = delete_red_black(self.root, priority)
```

## ğŸ¯ ConclusÃ£o PrÃ¡tica

A **escolha entre AVL e Red-Black** deve ser baseada na **carga de trabalho especÃ­fica**:

- **AVL Trees:** Para aplicaÃ§Ãµes **read-heavy** onde busca Ã© crÃ­tica
- **Red-Black Trees:** Para aplicaÃ§Ãµes **write-heavy** onde modificaÃ§Ãµes sÃ£o crÃ­ticas

**LiÃ§Ã£o:** Implemente ambas e **teste com sua carga de trabalho real** para fazer a escolha correta! 