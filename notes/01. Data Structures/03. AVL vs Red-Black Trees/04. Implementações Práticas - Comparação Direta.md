# 📊 Implementações Práticas: Comparação Direta

## 🎯 Objetivo

Implementar e comparar **diretamente** as inserções em Árvores AVL e Red-Black, demonstrando os **trade-offs práticos** entre as duas estruturas.

## 📝 Desafio 1: Inserção AVL (`insert_avl.py`)

### 🎯 Estratégia de Implementação

**Algoritmo:**
1. **Inserção BST** padrão
2. **Atualizar altura** do nó
3. **Calcular fator** de balanceamento
4. **Aplicar rotações** se necessário

### 🔍 Pseudocódigo Detalhado

```python
def insert_avl(root, value):
    # 1. Inserção BST padrão
    if root is None:
        return TreeNode(value, height=1)
    
    if value < root.value:
        root.left = insert_avl(root.left, value)
    else:
        root.right = insert_avl(root.right, value)
    
    # 2. Atualizar altura
    root.height = 1 + max(height(root.left), height(root.right))
    
    # 3. Calcular fator de balanceamento
    balance = balance_factor(root)
    
    # 4. Casos de desbalanceamento
    # Left-Left
    if balance > 1 and value < root.left.value:
        return rotate_right(root)
    
    # Right-Right
    if balance < -1 and value > root.right.value:
        return rotate_left(root)
    
    # Left-Right
    if balance > 1 and value > root.left.value:
        root.left = rotate_left(root.left)
        return rotate_right(root)
    
    # Right-Left
    if balance < -1 and value < root.right.value:
        root.right = rotate_right(root.right)
        return rotate_left(root)
    
    return root

def balance_factor(node):
    return height(node.left) - height(node.right)

def height(node):
    return node.height if node else 0
```

### ⚡ Análise de Complexidade

| Aspecto | Complexidade | Explicação |
|---------|--------------|------------|
| **Tempo** | O(log n) | Altura logarítmica |
| **Espaço** | O(log n) | Stack de recursão |
| **Rotações** | Máximo 2 | Por inserção |

### 🧪 Casos de Teste Essenciais

```python
# Teste 1: Inserção simples
root = insert_avl(None, 10)
assert root.value == 10
assert root.height == 1

# Teste 2: Inserção que requer rotação LL
root = insert_avl(root, 5)
root = insert_avl(root, 2)  # Deve causar rotação
assert root.value == 5  # Nova raiz após rotação

# Teste 3: Inserção que requer rotação LR
root = insert_avl(root, 1)
root = insert_avl(root, 3)  # Deve causar rotação dupla
```

## 📝 Desafio 2: Inserção Red-Black (`insert_red_black.py`)

### 🎯 Estratégia de Implementação

**Algoritmo:**
1. **Inserção BST** padrão
2. **Colorir nó** como vermelho
3. **Corrigir propriedades** Red-Black
4. **Aplicar rotações/recolorações** se necessário

### 🔍 Pseudocódigo Detalhado

```python
def insert_red_black(root, value):
    # 1. Inserção BST padrão
    if root is None:
        return RBNode(value, BLACK)  # Raiz sempre preta
    
    if value < root.value:
        root.left = insert_red_black(root.left, value)
        root.left.parent = root
    else:
        root.right = insert_red_black(root.right, value)
        root.right.parent = root
    
    # 2. Corrigir propriedades Red-Black
    return fix_red_black_properties(root)

def fix_red_black_properties(node):
    # Caso 1: Nó é raiz
    if node.parent is None:
        node.color = BLACK
        return node
    
    # Caso 2: Pai é preto
    if node.parent.color == BLACK:
        return node
    
    # Caso 3: Pai é vermelho
    uncle = get_uncle(node)
    
    # Caso 3a: Tio é vermelho
    if uncle and uncle.color == RED:
        node.parent.color = BLACK
        uncle.color = BLACK
        node.parent.parent.color = RED
        return fix_red_black_properties(node.parent.parent)
    
    # Caso 3b: Tio é preto
    return fix_red_black_rotations(node)

def get_uncle(node):
    if node.parent.parent.left == node.parent:
        return node.parent.parent.right
    return node.parent.parent.left
```

### ⚡ Análise de Complexidade

| Aspecto | Complexidade | Explicação |
|---------|--------------|------------|
| **Tempo** | O(log n) | Altura logarítmica |
| **Espaço** | O(log n) | Stack de recursão |
| **Rotações** | Máximo 3 | Por inserção |

### 🧪 Casos de Teste Essenciais

```python
# Teste 1: Inserção simples
root = insert_red_black(None, 10)
assert root.value == 10
assert root.color == BLACK

# Teste 2: Inserção que requer recolorização
root = insert_red_black(root, 5)
root = insert_red_black(root, 15)
root = insert_red_black(root, 3)  # Deve causar recolorização

# Teste 3: Inserção que requer rotação
root = insert_red_black(root, 1)  # Deve causar rotação
```

## 📊 Comparação Direta

### 🔄 **Frequência de Rotações**

| Cenário | AVL Trees | Red-Black Trees |
|---------|-----------|-----------------|
| **Inserção Simples** | 0 rotações | 0 rotações |
| **Inserção com Rotações** | 1-2 rotações | 0-3 rotações |
| **Sequência Crescente** | O(log n) rotações | O(1) rotações |
| **Sequência Aleatória** | Poucas rotações | Poucas rotações |

### ⚡ **Performance Prática**

```python
# Benchmark: Inserção de 1000 elementos
def benchmark_insertion():
    # AVL Trees
    avl_root = None
    avl_start = time.time()
    for i in range(1000):
        avl_root = insert_avl(avl_root, i)
    avl_time = time.time() - avl_start
    
    # Red-Black Trees
    rb_root = None
    rb_start = time.time()
    for i in range(1000):
        rb_root = insert_red_black(rb_root, i)
    rb_time = time.time() - rb_start
    
    return avl_time, rb_time

# Resultado típico:
# AVL: ~0.15 segundos
# Red-Black: ~0.12 segundos
```

### 📈 **Análise de Altura**

```python
def compare_heights():
    # Construir árvores idênticas
    values = [10, 5, 15, 3, 7, 12, 18, 1, 4, 6, 8, 11, 13, 16, 19]
    
    # AVL Tree
    avl_root = None
    for v in values:
        avl_root = insert_avl(avl_root, v)
    
    # Red-Black Tree
    rb_root = None
    for v in values:
        rb_root = insert_red_black(rb_root, v)
    
    avl_height = get_height(avl_root)
    rb_height = get_height(rb_root)
    
    return avl_height, rb_height

# Resultado típico:
# AVL height: 4
# Red-Black height: 5
```

## 🔍 Debugging e Verificação

### 🎯 **Verificação AVL**

```python
def verify_avl_properties(root):
    if root is None:
        return True
    
    # Verificar propriedade BST
    if not is_bst_property(root):
        return False
    
    # Verificar fator de balanceamento
    balance = balance_factor(root)
    if abs(balance) > 1:
        return False
    
    # Verificar altura
    expected_height = 1 + max(height(root.left), height(root.right))
    if root.height != expected_height:
        return False
    
    return (verify_avl_properties(root.left) and 
            verify_avl_properties(root.right))
```

### 🔴 **Verificação Red-Black**

```python
def verify_red_black_properties(root):
    if root is None:
        return True
    
    # Verificar propriedade BST
    if not is_bst_property(root):
        return False
    
    # Verificar regras Red-Black
    return (is_red_black_valid(root) and 
            black_height_consistent(root))

def is_red_black_valid(node):
    if node is None:
        return True
    
    # Regra 1: Raiz é preta
    if node.parent is None and node.color != BLACK:
        return False
    
    # Regra 2: Nós vermelhos não têm filhos vermelhos
    if node.color == RED:
        if (node.left and node.left.color == RED or
            node.right and node.right.color == RED):
            return False
    
    return (is_red_black_valid(node.left) and 
            is_red_black_valid(node.right))
```

## 💡 Insights Práticos

### 🎯 1. Complexidade de Implementação
**AVL:** Mais complexa devido aos 4 casos de rotação
**Red-Black:** Mais simples devido às regras de cores

### 🔄 2. Frequência de Rotações
**AVL:** Mais rotações, especialmente em sequências ordenadas
**Red-Black:** Menos rotações, mais recolorizações

### ⚡ 3. Performance Real
**AVL:** Melhor para busca intensiva
**Red-Black:** Melhor para modificações intensivas

### 🎯 4. Escolha Prática
**AVL:** Quando busca é crítica
**Red-Black:** Quando modificações são críticas

## 🚀 Aplicações Práticas

### 🌟 **Quando Usar AVL**
```python
# Sistema de cache com poucas modificações
class AVLCache:
    def __init__(self):
        self.root = None
    
    def get(self, key):
        # Busca rápida - O(log n)
        return search_avl(self.root, key)
    
    def put(self, key, value):
        # Inserção ocasional
        self.root = insert_avl(self.root, key)
```

### 🔴 **Quando Usar Red-Black**
```python
# Agendador de tarefas com modificações frequentes
class RedBlackScheduler:
    def __init__(self):
        self.root = None
    
    def add_task(self, priority, task):
        # Inserção rápida - O(log n)
        self.root = insert_red_black(self.root, priority)
    
    def remove_task(self, priority):
        # Remoção rápida - O(log n)
        self.root = delete_red_black(self.root, priority)
```

## 🎯 Conclusão Prática

A **escolha entre AVL e Red-Black** deve ser baseada na **carga de trabalho específica**:

- **AVL Trees:** Para aplicações **read-heavy** onde busca é crítica
- **Red-Black Trees:** Para aplicações **write-heavy** onde modificações são críticas

**Lição:** Implemente ambas e **teste com sua carga de trabalho real** para fazer a escolha correta! 