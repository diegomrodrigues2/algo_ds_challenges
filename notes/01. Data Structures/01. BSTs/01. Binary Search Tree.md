# 🌳 Binary Search Tree (BST) - Implementação e Aplicações

## 📚 Continuando do Ancestral Conceitual

Após entender a BST como **ancestral conceitual** das árvores balanceadas, vamos explorar sua implementação prática e aplicações reais.

### 🎯 Propriedade Fundamental

**Para qualquer nó na árvore:**
- **Subárvore esquerda**: Todos os valores são **menores** que o nó atual
- **Subárvore direita**: Todos os valores são **maiores** que o nó atual

```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \
     4   7
```


## ⚡ Por que BSTs são eficientes?

### 🚀 Complexidade das Operações

| Operação | Melhor Caso | Caso Médio | Pior Caso |
|----------|-------------|------------|-----------|
| **Busca** | O(1) | O(log n) | O(n) |
| **Inserção** | O(1) | O(log n) | O(n) |
| **Remoção** | O(1) | O(log n) | O(n) |

### 📊 Comparação com outras estruturas

| Estrutura | Busca | Inserção | Remoção |
|-----------|-------|----------|---------|
| **Array não ordenado** | O(n) | O(1) | O(n) |
| **Array ordenado** | O(log n) | O(n) | O(n) |
| **Lista ligada** | O(n) | O(1) | O(n) |
| **BST** | O(log n) | O(log n) | O(log n) |


## ⚠️ O Grande Problema: Desbalanceamento

### 🐛 O que acontece quando a árvore fica desbalanceada?

Imagine inserir números em ordem crescente: `1, 2, 3, 4, 5, 6, 7`

```
1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
           \
            7
```

**Resultado**: Uma "lista ligada" vertical! 😱
- Busca vira O(n) em vez de O(log n)

### 💡 Solução: Árvores Balanceadas

Para evitar esse problema, usamos árvores que se **reorganizam automaticamente**:


## 🌟 Tipos de Árvores Balanceadas

### 🔴 Red-Black Trees (Árvores Rubro-Negras)

**Como funciona:**
- Cada nó tem uma **cor** (vermelho ou preto)
- Regras especiais garantem que a árvore permaneça balanceada
- Usa **rotações** para reorganizar quando necessário

**Onde é usado:**
- `std::map` e `std::set` em C++
- `TreeMap` e `TreeSet` em Java

### 🌀 AVL Trees

**Como funciona:**
- Mantém o **fator de balanceamento** de cada nó
- Fator = altura(subárvore_esquerda) - altura(subárvore_direita)
- Deve estar entre -1, 0, ou +1

**Vantagens:**
- ✅ Balanceamento perfeito
- ✅ Altura mínima garantida

**Desvantagens:**
- ❌ Mais rotações que Red-Black Trees

### 🎲 Splay Trees

**Como funciona:**
- Move o nó acessado para o **topo** da árvore
- "Auto-organização" baseada no uso
- Nós mais acessados ficam mais próximos da raiz

**Vantagens:**
- ✅ Otimiza acesso a elementos frequentes
- ✅ Simples de implementar

**Desvantagens:**
- ❌ Pode ficar desbalanceada temporariamente


## 🛠️ Aplicações Práticas

### 📚 Dicionários e Conjuntos Ordenados

```python
# Exemplo: Controle de estoque
estoque = BST()
estoque.insert("produto_A", 50)
estoque.insert("produto_B", 30)
estoque.insert("produto_C", 80)

# Busca rápida por produto
quantidade = estoque.search("produto_B")  # O(log n)
```

### 🎯 Filas de Prioridade

```python
# Exemplo: Sistema de atendimento
fila_atendimento = BST()
fila_atendimento.insert(1, "Urgente")
fila_atendimento.insert(3, "Normal")
fila_atendimento.insert(5, "Baixa prioridade")

# Próximo paciente
proximo = fila_atendimento.min()  # O(log n)
```

### 🔍 Autocompletar e Sugestões

```python
# Exemplo: Sistema de busca
historico_busca = BST()
historico_busca.insert("algoritmo")
historico_busca.insert("arvore")
historico_busca.insert("busca")

# Sugestões baseadas em prefixo
sugestoes = historico_busca.prefix_search("al")  # ["algoritmo"]
```


## 📚 Implementações nas Bibliotecas Modernas

### 🐍 Python
```python
# Usando dict (hash table) - mais comum
dicionario = {}

# Para dados ordenados, use sortedcontainers
from sortedcontainers import SortedDict
bst_ordenado = SortedDict()
```

### ☕ Java
```java
// TreeMap usa Red-Black Tree internamente
TreeMap<String, Integer> bst = new TreeMap<>();
```

### ⚡ C++
```cpp
// std::map usa Red-Black Tree
std::map<std::string, int> bst;
```


## 🎯 Quando Usar BST?

### ✅ Use BST quando:
- **Dados precisam estar ordenados**
- **Busca por range** é importante
- **Operações de mínimo/máximo** são frequentes
- **Dados não cabem na memória** (B-Trees)

### ❌ Evite BST quando:
- **Dados são aleatórios** e não precisam de ordem
- **Hash table** é suficiente
- **Inserções/remoções são muito frequentes**
- **Memória é muito limitada**
