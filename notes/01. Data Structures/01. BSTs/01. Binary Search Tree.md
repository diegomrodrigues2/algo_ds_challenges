# ğŸŒ³ Binary Search Tree (BST) - ImplementaÃ§Ã£o e AplicaÃ§Ãµes

## ğŸ“š Continuando do Ancestral Conceitual

ApÃ³s entender a BST como **ancestral conceitual** das Ã¡rvores balanceadas, vamos explorar sua implementaÃ§Ã£o prÃ¡tica e aplicaÃ§Ãµes reais.

### ğŸ¯ Propriedade Fundamental

**Para qualquer nÃ³ na Ã¡rvore:**
- **SubÃ¡rvore esquerda**: Todos os valores sÃ£o **menores** que o nÃ³ atual
- **SubÃ¡rvore direita**: Todos os valores sÃ£o **maiores** que o nÃ³ atual

```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \
     4   7
```


## âš¡ Por que BSTs sÃ£o eficientes?

### ğŸš€ Complexidade das OperaÃ§Ãµes

| OperaÃ§Ã£o | Melhor Caso | Caso MÃ©dio | Pior Caso |
|----------|-------------|------------|-----------|
| **Busca** | O(1) | O(log n) | O(n) |
| **InserÃ§Ã£o** | O(1) | O(log n) | O(n) |
| **RemoÃ§Ã£o** | O(1) | O(log n) | O(n) |

### ğŸ“Š ComparaÃ§Ã£o com outras estruturas

| Estrutura | Busca | InserÃ§Ã£o | RemoÃ§Ã£o |
|-----------|-------|----------|---------|
| **Array nÃ£o ordenado** | O(n) | O(1) | O(n) |
| **Array ordenado** | O(log n) | O(n) | O(n) |
| **Lista ligada** | O(n) | O(1) | O(n) |
| **BST** | O(log n) | O(log n) | O(log n) |


## âš ï¸ O Grande Problema: Desbalanceamento

### ğŸ› O que acontece quando a Ã¡rvore fica desbalanceada?

Imagine inserir nÃºmeros em ordem crescente: `1, 2, 3, 4, 5, 6, 7`

```
1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
           \
            7
```

**Resultado**: Uma "lista ligada" vertical! ğŸ˜±
- Busca vira O(n) em vez de O(log n)

### ğŸ’¡ SoluÃ§Ã£o: Ãrvores Balanceadas

Para evitar esse problema, usamos Ã¡rvores que se **reorganizam automaticamente**:


## ğŸŒŸ Tipos de Ãrvores Balanceadas

### ğŸ”´ Red-Black Trees (Ãrvores Rubro-Negras)

**Como funciona:**
- Cada nÃ³ tem uma **cor** (vermelho ou preto)
- Regras especiais garantem que a Ã¡rvore permaneÃ§a balanceada
- Usa **rotaÃ§Ãµes** para reorganizar quando necessÃ¡rio

**Onde Ã© usado:**
- `std::map` e `std::set` em C++
- `TreeMap` e `TreeSet` em Java

### ğŸŒ€ AVL Trees

**Como funciona:**
- MantÃ©m o **fator de balanceamento** de cada nÃ³
- Fator = altura(subÃ¡rvore_esquerda) - altura(subÃ¡rvore_direita)
- Deve estar entre -1, 0, ou +1

**Vantagens:**
- âœ… Balanceamento perfeito
- âœ… Altura mÃ­nima garantida

**Desvantagens:**
- âŒ Mais rotaÃ§Ãµes que Red-Black Trees

### ğŸ² Splay Trees

**Como funciona:**
- Move o nÃ³ acessado para o **topo** da Ã¡rvore
- "Auto-organizaÃ§Ã£o" baseada no uso
- NÃ³s mais acessados ficam mais prÃ³ximos da raiz

**Vantagens:**
- âœ… Otimiza acesso a elementos frequentes
- âœ… Simples de implementar

**Desvantagens:**
- âŒ Pode ficar desbalanceada temporariamente


## ğŸ› ï¸ AplicaÃ§Ãµes PrÃ¡ticas

### ğŸ“š DicionÃ¡rios e Conjuntos Ordenados

```python
# Exemplo: Controle de estoque
estoque = BST()
estoque.insert("produto_A", 50)
estoque.insert("produto_B", 30)
estoque.insert("produto_C", 80)

# Busca rÃ¡pida por produto
quantidade = estoque.search("produto_B")  # O(log n)
```

### ğŸ¯ Filas de Prioridade

```python
# Exemplo: Sistema de atendimento
fila_atendimento = BST()
fila_atendimento.insert(1, "Urgente")
fila_atendimento.insert(3, "Normal")
fila_atendimento.insert(5, "Baixa prioridade")

# PrÃ³ximo paciente
proximo = fila_atendimento.min()  # O(log n)
```

### ğŸ” Autocompletar e SugestÃµes

```python
# Exemplo: Sistema de busca
historico_busca = BST()
historico_busca.insert("algoritmo")
historico_busca.insert("arvore")
historico_busca.insert("busca")

# SugestÃµes baseadas em prefixo
sugestoes = historico_busca.prefix_search("al")  # ["algoritmo"]
```


## ğŸ“š ImplementaÃ§Ãµes nas Bibliotecas Modernas

### ğŸ Python
```python
# Usando dict (hash table) - mais comum
dicionario = {}

# Para dados ordenados, use sortedcontainers
from sortedcontainers import SortedDict
bst_ordenado = SortedDict()
```

### â˜• Java
```java
// TreeMap usa Red-Black Tree internamente
TreeMap<String, Integer> bst = new TreeMap<>();
```

### âš¡ C++
```cpp
// std::map usa Red-Black Tree
std::map<std::string, int> bst;
```


## ğŸ¯ Quando Usar BST?

### âœ… Use BST quando:
- **Dados precisam estar ordenados**
- **Busca por range** Ã© importante
- **OperaÃ§Ãµes de mÃ­nimo/mÃ¡ximo** sÃ£o frequentes
- **Dados nÃ£o cabem na memÃ³ria** (B-Trees)

### âŒ Evite BST quando:
- **Dados sÃ£o aleatÃ³rios** e nÃ£o precisam de ordem
- **Hash table** Ã© suficiente
- **InserÃ§Ãµes/remoÃ§Ãµes sÃ£o muito frequentes**
- **MemÃ³ria Ã© muito limitada**
