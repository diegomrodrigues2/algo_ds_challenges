# 🔍 Operações Básicas em BSTs

## 📋 Visão Geral

As **três operações fundamentais** em uma Binary Search Tree são:
- **🔎 Busca (Search)**
- **➕ Inserção (Insert)** 
- **🗑️ Remoção (Delete)**


## 🔎 Busca em BST

### 📝 Algoritmo
```python
def search_bst(root, target):
    if root is None:
        return None
    
    if root.value == target:
        return root
    
    if target < root.value:
        return search_bst(root.left, target)
    
    return search_bst(root.right, target)
```

### 🎨 Exemplo Visual
```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \
     4   7

Busca por 6:
1. Começa em 8 → 6 < 8 → vai para esquerda
2. Chega em 3 → 6 > 3 → vai para direita  
3. Chega em 6 → 6 == 6 → ENCONTRADO! ✅
```

### ⚡ Complexidade
- **Melhor caso**: O(1) - elemento na raiz
- **Caso médio**: O(log n) - árvore balanceada
- **Pior caso**: O(n) - árvore desbalanceada


## ➕ Inserção em BST

### 📝 Algoritmo
```python
def insert_bst(root, value):
    if root is None:
        return TreeNode(value)
    
    if value < root.value:
        root.left = insert_bst(root.left, value)
    elif value > root.value:
        root.right = insert_bst(root.right, value)
    
    return root
```

### 🎨 Exemplo Visual
```
Inserindo 5 na árvore:

Antes:        Depois:
   8             8
  / \           / \
 3   10        3   10
/ \    \      / \    \
1   6    14  1   6    14
    / \          / \
   4   7        4   7
                    \
                     5  ← Nova folha
```


## 🗑️ Remoção em BST

### 📝 Algoritmo
```python
def delete_bst_node(root, key):
    if root is None:
        return root
    
    if key < root.value:
        root.left = delete_bst_node(root.left, key)
    elif key > root.value:
        root.right = delete_bst_node(root.right, key)
    else:
        # Caso 1: Nó é uma folha
        if root.left is None and root.right is None:
            return None
        
        # Caso 2: Nó tem apenas um filho
        elif root.left is None:
            return root.right
        elif root.right is None:
            return root.left
        
        # Caso 3: Nó tem dois filhos
        else:
            successor = find_min(root.right)
            root.value = successor.value
            root.right = delete_bst_node(root.right, successor.value)
    
    return root

def find_min(node):
    while node.left is not None:
        node = node.left
    return node
```

### 🎨 Os Três Casos de Remoção

#### 📍 Caso 1: Nó Folha
```
Remover 7:
   8             8
  / \           / \
 3   10        3   10
/ \    \      / \    \
1   6    14  1   6    14
    / \          /
   4   7        4
```

#### 📍 Caso 2: Nó com Um Filho
```
Remover 10:
   8             8
  / \           / \
 3   10        3   14
/ \    \      / \
1   6    14  1   6
    / \          / \
   4   7        4   7
```

#### 📍 Caso 3: Nó com Dois Filhos
```
Remover 8:
   8             9
  / \           / \
 3   10        3   10
/ \    \      / \    \
1   6    14  1   6    14
    / \          / \
   4   7        4   7

Estratégia: Substituir pelo sucessor inorder (9)
```


## 🚀 Implementação Iterativa

### 🔄 Busca Iterativa
```python
def search_bst_iterative(root, target):
    current = root
    
    while current is not None:
        if current.value == target:
            return current
        elif target < current.value:
            current = current.left
        else:
            current = current.right
    
    return None
```

### 🔄 Inserção Iterativa
```python
def insert_bst_iterative(root, value):
    if root is None:
        return TreeNode(value)
    
    current = root
    while True:
        if value < current.value:
            if current.left is None:
                current.left = TreeNode(value)
                break
            current = current.left
        elif value > current.value:
            if current.right is None:
                current.right = TreeNode(value)
                break
            current = current.right
        else:
            break
    
    return root
```


## 🎯 Vantagens e Desvantagens

### ✅ Vantagens
- **Busca eficiente**: O(log n) no caso médio
- **Inserção simples**: Sempre O(log n)
- **Dados ordenados**: Traversal inorder dá elementos ordenados
- **Flexibilidade**: Fácil de implementar e modificar

### ❌ Desvantagens
- **Remoção complexa**: Múltiplos casos para tratar
- **Desbalanceamento**: Performance pode degradar para O(n)
- **Memória**: Overhead de ponteiros
- **Não é cache-friendly**: Acesso aleatório à memória
