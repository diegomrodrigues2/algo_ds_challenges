# 🚀 Operações Avançadas em BSTs

## 📋 Visão Geral

Além das operações básicas (busca, inserção, remoção), BSTs oferecem várias **operações avançadas** que são fundamentais para algoritmos e aplicações práticas.


## 🔍 Lowest Common Ancestor (LCA)

### 📝 Algoritmo para BST
```python
def lowest_common_ancestor_bst(root, p, q):
    """Encontra o LCA de dois nós em uma BST"""
    if root is None:
        return None
    
    if p.value < root.value and q.value < root.value:
        return lowest_common_ancestor_bst(root.left, p, q)
    
    if p.value > root.value and q.value > root.value:
        return lowest_common_ancestor_bst(root.right, p, q)
    
    return root
```

### 🎨 Exemplo Visual
```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \
     4   7

LCA(4, 7) = 6  (ambos são descendentes de 6)
LCA(1, 6) = 3  (ambos são descendentes de 3)
LCA(4, 14) = 8 (ambos são descendentes de 8)
```

### 🛠️ Aplicações
- **Sistemas de arquivos**: Encontrar diretório comum
- **Árvores genealógicas**: Encontrar ancestral comum
- **Redes**: Encontrar roteador comum


## 📏 Altura da Árvore

### 📝 Algoritmo
```python
def tree_height(root):
    """Calcula a altura da árvore"""
    if root is None:
        return 0
    
    left_height = tree_height(root.left)
    right_height = tree_height(root.right)
    return max(left_height, right_height) + 1
```

### 🎨 Exemplo Visual
```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \
     4   7

Altura = 3 (caminho mais longo: 8 → 3 → 6 → 4 ou 8 → 3 → 6 → 7)
```

### 🚀 Versão Iterativa
```python
def tree_height_iterative(root):
    """Versão iterativa usando level-order traversal"""
    if root is None:
        return 0
    
    queue = [(root, 0)]
    max_height = 0
    
    while queue:
        node, level = queue.pop(0)
        max_height = max(max_height, level)
        
        if node.left:
            queue.append((node.left, level + 1))
        if node.right:
            queue.append((node.right, level + 1))
    
    return max_height
```


## 🔍 Mínimo e Máximo

### 📝 Algoritmos
```python
def tree_min(root):
    """Encontra o valor mínimo na BST"""
    if root is None:
        return None
    
    while root.left is not None:
        root = root.left
    
    return root.value

def tree_max(root):
    """Encontra o valor máximo na BST"""
    if root is None:
        return None
    
    while root.right is not None:
        root = root.right
    
    return root.value
```

### 🎨 Exemplo Visual
```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \
     4   7

Mínimo: 1 (nó mais à esquerda)
Máximo: 14 (nó mais à direita)
```

### 🚀 Versão Recursiva
```python
def tree_min_recursive(root):
    if root is None:
        return None
    if root.left is None:
        return root.value
    return tree_min_recursive(root.left)

def tree_max_recursive(root):
    if root is None:
        return None
    if root.right is None:
        return root.value
    return tree_max_recursive(root.right)
```


## 🔢 Contagem de Nós

### 📝 Algoritmo
```python
def count_nodes(root):
    """Conta o número de nós na árvore"""
    if root is None:
        return 0
    
    return 1 + count_nodes(root.left) + count_nodes(root.right)
```

### 🚀 Versão Iterativa
```python
def count_nodes_iterative(root):
    """Versão iterativa usando qualquer traversal"""
    if root is None:
        return 0
    
    count = 0
    stack = [root]
    
    while stack:
        node = stack.pop()
        count += 1
        
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    
    return count
```

### 🎯 Contagem por Nível
```python
def count_nodes_by_level(root):
    """Conta nós por nível"""
    if root is None:
        return {}
    
    level_counts = {}
    queue = [(root, 0)]
    
    while queue:
        node, level = queue.pop(0)
        level_counts[level] = level_counts.get(level, 0) + 1
        
        if node.left:
            queue.append((node.left, level + 1))
        if node.right:
            queue.append((node.right, level + 1))
    
    return level_counts
```


## ⚖️ Balanceamento de BST

### 📝 Algoritmo
```python
def balance_bst(root):
    """Balanceia uma BST desbalanceada"""
    if root is None:
        return None
    
    values = in_ordem(root)
    
    def build_balanced_tree(arr, start, end):
        if start > end:
            return None
        
        mid = (start + end) // 2
        node = TreeNode(arr[mid])
        
        node.left = build_balanced_tree(arr, start, mid - 1)
        node.right = build_balanced_tree(arr, mid + 1, end)
        
        return node
    
    return build_balanced_tree(values, 0, len(values) - 1)
```

### 🎨 Exemplo Visual
```
Antes (desbalanceada):    Depois (balanceada):
   1                         4
    \                      / \
     2                    2   6
      \                  / \ / \
       3                1  3 5  7
        \
         4
          \
           5
            \
             6
              \
               7
```

### 🚀 Verificação de Balanceamento
```python
def is_balanced(root):
    """Verifica se a árvore está balanceada (AVL)"""
    def check_balance(node):
        if node is None:
            return 0
        
        left_height = check_balance(node.left)
        if left_height == -1:
            return -1
        
        right_height = check_balance(node.right)
        if right_height == -1:
            return -1
        
        if abs(left_height - right_height) > 1:
            return -1
        
        return max(left_height, right_height) + 1
    
    return check_balance(root) != -1
```


## 🔍 Sucessor e Predecessor

### 📝 Algoritmos
```python
def find_successor(root, target):
    """Encontra o sucessor de um valor"""
    successor = None
    current = root
    
    while current:
        if current.value > target:
            successor = current
            current = current.left
        else:
            current = current.right
    
    return successor

def find_predecessor(root, target):
    """Encontra o predecessor de um valor"""
    predecessor = None
    current = root
    
    while current:
        if current.value < target:
            predecessor = current
            current = current.right
        else:
            current = current.left
    
    return predecessor
```

### 🎨 Exemplo Visual
```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \
     4   7

Sucessor(6) = 7
Predecessor(6) = 4
Sucessor(8) = 10
Predecessor(8) = 7
```


## 🎯 K-ésimo Menor Elemento

### 📝 Algoritmo
```python
def kth_smallest(root, k):
    """Encontra o k-ésimo menor elemento"""
    def inorder_traversal(node):
        if node is None:
            return []
        return inorder_traversal(node.left) + [node.value] + inorder_traversal(node.right)
    
    values = inorder_traversal(root)
    return values[k-1] if k <= len(values) else None
```

### 🚀 Versão Otimizada
```python
def kth_smallest_optimized(root, k):
    """Versão otimizada que para quando encontra o k-ésimo"""
    stack = []
    current = root
    count = 0
    
    while current or stack:
        while current:
            stack.append(current)
            current = current.left
        
        current = stack.pop()
        count += 1
        
        if count == k:
            return current.value
        
        current = current.right
    
    return None
```


## 🧪 Exemplos Práticos

### 📝 Sistema de Arquivos
```python
class FileSystem:
    def __init__(self):
        self.root = None
    
    def find_common_directory(self, file1, file2):
        """Encontra diretório comum usando LCA"""
        path1 = self.get_path(file1)
        path2 = self.get_path(file2)
        
        lca = lowest_common_ancestor_bst(self.root, path1[-1], path2[-1])
        return lca.value
```

### 📝 Sistema de Cache
```python
class CacheManager:
    def __init__(self):
        self.bst = None
    
    def get_range(self, min_val, max_val):
        """Obtém todos os valores em um range"""
        result = []
        
        def range_search(node):
            if node is None:
                return
            
            if min_val < node.value:
                range_search(node.left)
            
            if min_val <= node.value <= max_val:
                result.append(node.value)
            
            if max_val > node.value:
                range_search(node.right)
        
        range_search(self.bst)
        return result
```


## 💡 Dicas Importantes

### 🎓 Para Implementação
1. **Use a propriedade BST** para otimizar buscas
2. **Considere casos especiais** (árvore vazia, nó único)
3. **Balanceamento** é crucial para performance
4. **LCA em BST** é mais simples que em árvores binárias gerais

### 🔍 Para Debugging
1. **Desenhe a árvore** para visualizar operações
2. **Teste com árvores pequenas** primeiro
3. **Verifique propriedades BST** após operações
4. **Use traversal inorder** para verificar ordenação

### 🚀 Para Otimização
1. **LCA em BST** pode usar comparações simples
2. **Mínimo/máximo** são O(h) em vez de O(n)
3. **Balanceamento** melhora todas as operações
4. **Sucessor/predecessor** são úteis para iteração
