# ğŸš€ OperaÃ§Ãµes AvanÃ§adas em BSTs

## ğŸ“‹ VisÃ£o Geral

AlÃ©m das operaÃ§Ãµes bÃ¡sicas (busca, inserÃ§Ã£o, remoÃ§Ã£o), BSTs oferecem vÃ¡rias **operaÃ§Ãµes avanÃ§adas** que sÃ£o fundamentais para algoritmos e aplicaÃ§Ãµes prÃ¡ticas.


## ğŸ” Lowest Common Ancestor (LCA)

### ğŸ“ Algoritmo para BST
```python
def lowest_common_ancestor_bst(root, p, q):
    """Encontra o LCA de dois nÃ³s em uma BST"""
    if root is None:
        return None
    
    if p.value < root.value and q.value < root.value:
        return lowest_common_ancestor_bst(root.left, p, q)
    
    if p.value > root.value and q.value > root.value:
        return lowest_common_ancestor_bst(root.right, p, q)
    
    return root
```

### ğŸ¨ Exemplo Visual
```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \
     4   7

LCA(4, 7) = 6  (ambos sÃ£o descendentes de 6)
LCA(1, 6) = 3  (ambos sÃ£o descendentes de 3)
LCA(4, 14) = 8 (ambos sÃ£o descendentes de 8)
```

### ğŸ› ï¸ AplicaÃ§Ãµes
- **Sistemas de arquivos**: Encontrar diretÃ³rio comum
- **Ãrvores genealÃ³gicas**: Encontrar ancestral comum
- **Redes**: Encontrar roteador comum


## ğŸ“ Altura da Ãrvore

### ğŸ“ Algoritmo
```python
def tree_height(root):
    """Calcula a altura da Ã¡rvore"""
    if root is None:
        return 0
    
    left_height = tree_height(root.left)
    right_height = tree_height(root.right)
    return max(left_height, right_height) + 1
```

### ğŸ¨ Exemplo Visual
```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \
     4   7

Altura = 3 (caminho mais longo: 8 â†’ 3 â†’ 6 â†’ 4 ou 8 â†’ 3 â†’ 6 â†’ 7)
```

### ğŸš€ VersÃ£o Iterativa
```python
def tree_height_iterative(root):
    """VersÃ£o iterativa usando level-order traversal"""
    if root is None:
        return 0
    
    queue = [(root, 0)]
    max_height = 0
    
    while queue:
        node, level = queue.pop(0)
        max_height = max(max_height, level)
        
        if node.left:
            queue.append((node.left, level + 1))
        if node.right:
            queue.append((node.right, level + 1))
    
    return max_height
```


## ğŸ” MÃ­nimo e MÃ¡ximo

### ğŸ“ Algoritmos
```python
def tree_min(root):
    """Encontra o valor mÃ­nimo na BST"""
    if root is None:
        return None
    
    while root.left is not None:
        root = root.left
    
    return root.value

def tree_max(root):
    """Encontra o valor mÃ¡ximo na BST"""
    if root is None:
        return None
    
    while root.right is not None:
        root = root.right
    
    return root.value
```

### ğŸ¨ Exemplo Visual
```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \
     4   7

MÃ­nimo: 1 (nÃ³ mais Ã  esquerda)
MÃ¡ximo: 14 (nÃ³ mais Ã  direita)
```

### ğŸš€ VersÃ£o Recursiva
```python
def tree_min_recursive(root):
    if root is None:
        return None
    if root.left is None:
        return root.value
    return tree_min_recursive(root.left)

def tree_max_recursive(root):
    if root is None:
        return None
    if root.right is None:
        return root.value
    return tree_max_recursive(root.right)
```


## ğŸ”¢ Contagem de NÃ³s

### ğŸ“ Algoritmo
```python
def count_nodes(root):
    """Conta o nÃºmero de nÃ³s na Ã¡rvore"""
    if root is None:
        return 0
    
    return 1 + count_nodes(root.left) + count_nodes(root.right)
```

### ğŸš€ VersÃ£o Iterativa
```python
def count_nodes_iterative(root):
    """VersÃ£o iterativa usando qualquer traversal"""
    if root is None:
        return 0
    
    count = 0
    stack = [root]
    
    while stack:
        node = stack.pop()
        count += 1
        
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    
    return count
```

### ğŸ¯ Contagem por NÃ­vel
```python
def count_nodes_by_level(root):
    """Conta nÃ³s por nÃ­vel"""
    if root is None:
        return {}
    
    level_counts = {}
    queue = [(root, 0)]
    
    while queue:
        node, level = queue.pop(0)
        level_counts[level] = level_counts.get(level, 0) + 1
        
        if node.left:
            queue.append((node.left, level + 1))
        if node.right:
            queue.append((node.right, level + 1))
    
    return level_counts
```


## âš–ï¸ Balanceamento de BST

### ğŸ“ Algoritmo
```python
def balance_bst(root):
    """Balanceia uma BST desbalanceada"""
    if root is None:
        return None
    
    values = in_ordem(root)
    
    def build_balanced_tree(arr, start, end):
        if start > end:
            return None
        
        mid = (start + end) // 2
        node = TreeNode(arr[mid])
        
        node.left = build_balanced_tree(arr, start, mid - 1)
        node.right = build_balanced_tree(arr, mid + 1, end)
        
        return node
    
    return build_balanced_tree(values, 0, len(values) - 1)
```

### ğŸ¨ Exemplo Visual
```
Antes (desbalanceada):    Depois (balanceada):
   1                         4
    \                      / \
     2                    2   6
      \                  / \ / \
       3                1  3 5  7
        \
         4
          \
           5
            \
             6
              \
               7
```

### ğŸš€ VerificaÃ§Ã£o de Balanceamento
```python
def is_balanced(root):
    """Verifica se a Ã¡rvore estÃ¡ balanceada (AVL)"""
    def check_balance(node):
        if node is None:
            return 0
        
        left_height = check_balance(node.left)
        if left_height == -1:
            return -1
        
        right_height = check_balance(node.right)
        if right_height == -1:
            return -1
        
        if abs(left_height - right_height) > 1:
            return -1
        
        return max(left_height, right_height) + 1
    
    return check_balance(root) != -1
```


## ğŸ” Sucessor e Predecessor

### ğŸ“ Algoritmos
```python
def find_successor(root, target):
    """Encontra o sucessor de um valor"""
    successor = None
    current = root
    
    while current:
        if current.value > target:
            successor = current
            current = current.left
        else:
            current = current.right
    
    return successor

def find_predecessor(root, target):
    """Encontra o predecessor de um valor"""
    predecessor = None
    current = root
    
    while current:
        if current.value < target:
            predecessor = current
            current = current.right
        else:
            current = current.left
    
    return predecessor
```

### ğŸ¨ Exemplo Visual
```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \
     4   7

Sucessor(6) = 7
Predecessor(6) = 4
Sucessor(8) = 10
Predecessor(8) = 7
```


## ğŸ¯ K-Ã©simo Menor Elemento

### ğŸ“ Algoritmo
```python
def kth_smallest(root, k):
    """Encontra o k-Ã©simo menor elemento"""
    def inorder_traversal(node):
        if node is None:
            return []
        return inorder_traversal(node.left) + [node.value] + inorder_traversal(node.right)
    
    values = inorder_traversal(root)
    return values[k-1] if k <= len(values) else None
```

### ğŸš€ VersÃ£o Otimizada
```python
def kth_smallest_optimized(root, k):
    """VersÃ£o otimizada que para quando encontra o k-Ã©simo"""
    stack = []
    current = root
    count = 0
    
    while current or stack:
        while current:
            stack.append(current)
            current = current.left
        
        current = stack.pop()
        count += 1
        
        if count == k:
            return current.value
        
        current = current.right
    
    return None
```


## ğŸ§ª Exemplos PrÃ¡ticos

### ğŸ“ Sistema de Arquivos
```python
class FileSystem:
    def __init__(self):
        self.root = None
    
    def find_common_directory(self, file1, file2):
        """Encontra diretÃ³rio comum usando LCA"""
        path1 = self.get_path(file1)
        path2 = self.get_path(file2)
        
        lca = lowest_common_ancestor_bst(self.root, path1[-1], path2[-1])
        return lca.value
```

### ğŸ“ Sistema de Cache
```python
class CacheManager:
    def __init__(self):
        self.bst = None
    
    def get_range(self, min_val, max_val):
        """ObtÃ©m todos os valores em um range"""
        result = []
        
        def range_search(node):
            if node is None:
                return
            
            if min_val < node.value:
                range_search(node.left)
            
            if min_val <= node.value <= max_val:
                result.append(node.value)
            
            if max_val > node.value:
                range_search(node.right)
        
        range_search(self.bst)
        return result
```


## ğŸ’¡ Dicas Importantes

### ğŸ“ Para ImplementaÃ§Ã£o
1. **Use a propriedade BST** para otimizar buscas
2. **Considere casos especiais** (Ã¡rvore vazia, nÃ³ Ãºnico)
3. **Balanceamento** Ã© crucial para performance
4. **LCA em BST** Ã© mais simples que em Ã¡rvores binÃ¡rias gerais

### ğŸ” Para Debugging
1. **Desenhe a Ã¡rvore** para visualizar operaÃ§Ãµes
2. **Teste com Ã¡rvores pequenas** primeiro
3. **Verifique propriedades BST** apÃ³s operaÃ§Ãµes
4. **Use traversal inorder** para verificar ordenaÃ§Ã£o

### ğŸš€ Para OtimizaÃ§Ã£o
1. **LCA em BST** pode usar comparaÃ§Ãµes simples
2. **MÃ­nimo/mÃ¡ximo** sÃ£o O(h) em vez de O(n)
3. **Balanceamento** melhora todas as operaÃ§Ãµes
4. **Sucessor/predecessor** sÃ£o Ãºteis para iteraÃ§Ã£o
