# Chaining vs Open Addressing

## üéØ Objetivo

Comparar duas estrat√©gias fundamentais para resolver **colis√µes** em tabelas hash: **chaining** (encadeamento) e **open addressing** (endere√ßamento aberto).

## üîó Chaining (Encadeamento)

### Conceito
Quando ocorre uma colis√£o, armazenar m√∫ltiplos elementos na mesma posi√ß√£o usando uma **estrutura de dados auxiliar**.

### Estrutura
```python
# Tabela hash com listas encadeadas
table = [
    [(key1, value1), (key2, value2)],  # Slot 0: 2 elementos
    [(key3, value3)],                  # Slot 1: 1 elemento
    [],                                # Slot 2: vazio
    [(key4, value4), (key5, value5), (key6, value6)]  # Slot 3: 3 elementos
]
```

### Implementa√ß√£o
```python
class ChainingHashTable:
    def __init__(self, size):
        self.size = size
        self.table = [[] for _ in range(size)]
        self.n = 0
    
    def _hash(self, key):
        return hash(key) % self.size
    
    def insert(self, key, value):
        index = self._hash(key)
        chain = self.table[index]
        
        # Busca se j√° existe
        for i, (k, v) in enumerate(chain):
            if k == key:
                chain[i] = (key, value)  # Atualiza
                return
        
        # Insere novo
        chain.append((key, value))
        self.n += 1
    
    def find(self, key):
        index = self._hash(key)
        chain = self.table[index]
        
        for k, v in chain:
            if k == key:
                return v
        return None
```

### Vantagens
- ‚úÖ **Simplicidade**: Implementa√ß√£o direta
- ‚úÖ **Flexibilidade**: Qualquer estrutura de dados para cadeias
- ‚úÖ **An√°lise f√°cil**: Performance bem entendida
- ‚úÖ **Sem clustering**: Colis√µes n√£o afetam outras posi√ß√µes

### Desvantagens
- ‚ùå **Overhead**: Ponteiros e estruturas auxiliares
- ‚ùå **Cache locality**: Elementos espalhados na mem√≥ria
- ‚ùå **Espa√ßo extra**: Estruturas de dados para cadeias

## üè† Open Addressing (Endere√ßamento Aberto)

### Conceito
Quando ocorre uma colis√£o, procurar a **pr√≥xima posi√ß√£o dispon√≠vel** na pr√≥pria tabela hash.

### Estrat√©gias de Prospec√ß√£o

#### 1. Linear Probing
```python
def linear_probe(hash_value, i, size):
    return (hash_value + i) % size

# Exemplo: h(k) = 3, size = 8
# Tentativas: 3, 4, 5, 6, 7, 0, 1, 2
```

#### 2. Quadratic Probing
```python
def quadratic_probe(hash_value, i, size):
    return (hash_value + i¬≤) % size

# Exemplo: h(k) = 3, size = 8
# Tentativas: 3, 4, 7, 4, 3, 4, 7, 4 (ciclo!)
```

#### 3. Double Hashing
```python
def double_hash(hash_value, i, size, hash2):
    return (hash_value + i * hash2) % size

# Exemplo: h(k) = 3, h2(k) = 5, size = 8
# Tentativas: 3, 0, 5, 2, 7, 4, 1, 6
```

### Implementa√ß√£o
```python
class OpenAddressingHashTable:
    def __init__(self, size):
        self.size = size
        self.table = [None] * size
        self.n = 0
        self.DELETED = object()  # Marcador para slots deletados
    
    def _hash(self, key):
        return hash(key) % self.size
    
    def _hash2(self, key):
        return 1 + (hash(key) % (self.size - 1))  # Nunca 0
    
    def _probe(self, key, i):
        return (self._hash(key) + i * self._hash2(key)) % self.size
    
    def insert(self, key, value):
        for i in range(self.size):
            index = self._probe(key, i)
            slot = self.table[index]
            
            if slot is None or slot == self.DELETED:
                self.table[index] = (key, value)
                self.n += 1
                return
            elif slot[0] == key:
                self.table[index] = (key, value)  # Atualiza
                return
        
        raise Exception("Tabela cheia")
    
    def find(self, key):
        for i in range(self.size):
            index = self._probe(key, i)
            slot = self.table[index]
            
            if slot is None:
                return None  # N√£o encontrado
            elif slot != self.DELETED and slot[0] == key:
                return slot[1]
        
        return None
```

## üìä Compara√ß√£o de Performance

### Complexidade Assint√≥tica
| Opera√ß√£o | Chaining | Open Addressing |
|----------|----------|-----------------|
| **insert** | O(1) esperado | O(1) esperado |
| **find** | O(1) esperado | O(1) esperado |
| **delete** | O(1) esperado | O(1) esperado |

### Fatores Pr√°ticos

#### Chaining
```python
# Performance depende do comprimento das cadeias
# E[comprimento] = Œ± (fator de carga)
# Œ± = n/m (elementos/slots)

# Para Œ± = 1: E[comprimento] = 1
# Para Œ± = 2: E[comprimento] = 2
```

#### Open Addressing
```python
# Performance depende do fator de carga
# Deve manter Œ± < 1 (n < m)

# Para Œ± = 0.5: Performance excelente
# Para Œ± = 0.9: Performance degradada
# Para Œ± ‚â• 1: Imposs√≠vel inserir
```

## üîç An√°lise Detalhada

### Chaining

#### Vantagens
- **Flexibilidade**: Pode usar qualquer estrutura para cadeias
- **Robustez**: Funciona bem mesmo com Œ± > 1
- **Simplicidade**: Implementa√ß√£o e an√°lise diretas
- **Sem clustering**: Colis√µes isoladas

#### Desvantagens
- **Overhead**: Estruturas de dados extras
- **Cache misses**: Elementos espalhados
- **Espa√ßo**: Ponteiros e estruturas auxiliares

### Open Addressing

#### Vantagens
- **Cache locality**: Elementos pr√≥ximos na mem√≥ria
- **Efici√™ncia**: Sem overhead de estruturas
- **Simplicidade**: Apenas um array
- **Espa√ßo**: Apenas os dados

#### Desvantagens
- **Clustering**: Colis√µes podem causar mais colis√µes
- **Fator de carga**: Deve manter Œ± < 1
- **Dele√ß√£o complexa**: Requer marcadores especiais
- **An√°lise dif√≠cil**: Comportamento mais complexo

## üéØ Escolha da Estrat√©gia

### Use Chaining Quando
- **Fator de carga vari√°vel**: Œ± pode ser > 1
- **Dele√ß√µes frequentes**: Mais simples de implementar
- **An√°lise rigorosa**: Performance bem entendida
- **Flexibilidade**: Diferentes estruturas para cadeias

### Use Open Addressing Quando
- **Cache performance**: Cr√≠tico para performance
- **Espa√ßo limitado**: Minimizar overhead
- **Fator de carga controlado**: Œ± < 0.8
- **Implementa√ß√£o simples**: Apenas um array

## üîß Implementa√ß√µes Pr√°ticas

### Python dict
```python
# Python usa open addressing com:
# - Sondagem pseudo-aleat√≥ria
# - Redimensionamento quando Œ± ‚âà 2/3
# - Dele√ß√£o com marcadores especiais
```

### Java HashMap
```python
# Java usa chaining com:
# - Listas encadeadas (Java 7)
# - √Årvores bin√°rias (Java 8+)
# - Redimensionamento quando Œ± > 0.75
```

### C++ unordered_map
```python
# C++ usa chaining com:
# - Listas encadeadas
# - Redimensionamento quando Œ± > 1
```

## üéØ Conclus√£o

### Chaining
- **Mais robusto**: Funciona bem em mais situa√ß√µes
- **Mais flex√≠vel**: Permite diferentes estruturas
- **Mais simples**: Implementa√ß√£o e an√°lise diretas

### Open Addressing
- **Mais eficiente**: Melhor uso de cache
- **Menos espa√ßo**: Sem overhead de estruturas
- **Mais complexo**: Requer cuidados especiais

### Escolha
A escolha depende do contexto espec√≠fico:
- **Performance cr√≠tica**: Open addressing
- **Robustez**: Chaining
- **Simplicidade**: Chaining
- **Espa√ßo limitado**: Open addressing

---

**Pr√≥ximo**: [README](README.md) 