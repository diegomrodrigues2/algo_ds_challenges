# Direct Access Arrays

## 🎯 Objetivo

Implementar operações de conjunto usando **acesso direto à memória**, permitindo operações O(1) mas com limitações de espaço.

## 🏗️ Conceito Básico

### Ideia Central
Armazenar um item com chave **k** diretamente na posição **k** do array:

```python
# Se item tem chave = 10, armazenar em array[10]
array[10] = item
```

### Operações O(1)
```python
def find(key):
    return array[key]  # O(1)

def insert(key, item):
    array[key] = item  # O(1)

def delete(key):
    array[key] = None  # O(1)
```

## 📊 Complexidade

| Operação | Tempo | Espaço |
|----------|-------|--------|
| **build** | O(n) | O(u) |
| **find** | O(1) | - |
| **insert** | O(1) | - |
| **delete** | O(1) | - |
| **find_min** | O(u) | - |
| **find_max** | O(u) | - |

Onde:
- **n**: número de elementos armazenados
- **u**: tamanho do universo de chaves (u ≥ n)

## ⚠️ Limitações

### 1. Espaço Excessivo
```python
# Exemplo: MIT IDs (9 dígitos)
u = 10^9  # Tamanho do universo
n = 400   # Número de estudantes

# Espaço necessário: O(10^9)
# Espaço usado: O(400)
# Eficiência: 0.00004%
```

### 2. Chaves Inteiras
- **Restrição**: Apenas chaves inteiras são suportadas
- **Motivo**: Chaves devem ser usadas como índices
- **Limitação**: Não funciona com strings, objetos complexos

### 3. Word RAM Model
```python
# Restrição: u ≤ 2^w
# Onde w = tamanho da palavra da máquina
# Exemplo: w = 64 bits → u ≤ 2^64
```

## 🔧 Implementação

### Estrutura Básica
```python
class DirectAccessArray:
    def __init__(self, universe_size):
        self.array = [None] * universe_size
        self.size = 0
    
    def find(self, key):
        return self.array[key]
    
    def insert(self, key, item):
        if self.array[key] is None:
            self.size += 1
        self.array[key] = item
    
    def delete(self, key):
        if self.array[key] is not None:
            self.size -= 1
            self.array[key] = None
```

### Operações de Min/Max
```python
def find_min(self):
    for i in range(len(self.array)):
        if self.array[i] is not None:
            return self.array[i]
    return None

def find_max(self):
    for i in range(len(self.array) - 1, -1, -1):
        if self.array[i] is not None:
            return self.array[i]
    return None
```

## 📈 Análise de Trade-offs

### Vantagens
- ✅ **Operações O(1)**: find, insert, delete
- ✅ **Simplicidade**: Implementação direta
- ✅ **Sem colisões**: Cada chave tem posição única

### Desvantagens
- ❌ **Espaço O(u)**: Pode ser muito maior que O(n)
- ❌ **Chaves inteiras**: Limitação de tipos
- ❌ **Operações de ordem**: find_min/max são O(u)
- ❌ **Espaço desperdiçado**: Muitas posições vazias

## 🎯 Casos de Uso

### Apropriado Quando
- **u ≈ n**: Universo pequeno comparado aos dados
- **Chaves inteiras**: IDs, códigos numéricos
- **Operações críticas**: find/insert/delete frequentes
- **Espaço disponível**: Memória não é restrição

### Exemplos Práticos
```python
# IDs de funcionários (1 a 1000)
employee_db = DirectAccessArray(1000)

# Códigos de produtos (0 a 9999)
product_catalog = DirectAccessArray(10000)

# Índices de array (0 a n-1)
index_mapping = DirectAccessArray(n)
```

## 🔄 Transição para Hashing

### Problema Central
Como reduzir o espaço de O(u) para O(n) mantendo operações O(1)?

### Solução: Função Hash
```python
# Em vez de: array[key]
# Usar: array[hash(key) % m]
# Onde m ≈ n (tamanho da tabela)
```

### Vantagens do Hashing
- **Espaço O(n)**: Tamanho proporcional aos dados
- **Operações O(1)**: Mantém eficiência
- **Chaves arbitrárias**: Suporta qualquer tipo
- **Flexibilidade**: Tamanho adaptável

## 🎯 Conclusão

Direct Access Arrays:
- **Demonstram** o potencial do Word RAM Model
- **Superam** o limite Ω(log n) do modelo de comparação
- **Motivam** o desenvolvimento de hashing
- **Servem** como base conceitual para estruturas mais eficientes

---

**Próximo**: [Universal Hashing](03.%20Universal%20Hashing.md) 