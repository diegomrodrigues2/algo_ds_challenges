# ğŸ”— Linked Lists

## ğŸ¯ DefiniÃ§Ã£o
**Lista encadeada** = estrutura baseada em nÃ³s conectados por ponteiros

### ğŸ—ï¸ Estrutura
- **NÃ³**: `{item, next_pointer}`
- **CabeÃ§a**: Ponteiro para primeiro nÃ³
- **Ordem**: Definida pelos ponteiros `next`

## âš¡ OperaÃ§Ãµes e Complexidade

| OperaÃ§Ã£o | Complexidade | DescriÃ§Ã£o |
|----------|-------------|-----------|
| `insert_first(x)` | O(1) | Adiciona no inÃ­cio |
| `delete_first()` | O(1) | Remove do inÃ­cio |
| `get_at(i)` | O(i) | Percorre i nÃ³s |
| `set_at(i, x)` | O(i) | Percorre + modifica |
| `insert_at(i, x)` | O(i) | Percorre + insere |
| `delete_at(i)` | O(i) | Percorre + remove |

## âœ… Vantagens
- **ğŸš€ InserÃ§Ã£o/remoÃ§Ã£o**: O(1) no inÃ­cio
- **ğŸ”„ Flexibilidade**: ReordenaÃ§Ã£o sem mover dados
- **ğŸ“ Crescimento dinÃ¢mico**: Sem realocaÃ§Ã£o
- **ğŸ’¾ AlocaÃ§Ã£o incremental**: SÃ³ aloca quando necessÃ¡rio

## âŒ LimitaÃ§Ãµes
- **ğŸŒ Acesso aleatÃ³rio**: O(n) no pior caso
- **ğŸ’¾ Overhead**: Ponteiros ocupam memÃ³ria extra
- **ğŸ”„ Cache-unfriendly**: Dados espalhados na memÃ³ria
- **ğŸ“ Complexidade**: Mais difÃ­cil de implementar

## ğŸ”§ ImplementaÃ§Ã£o BÃ¡sica
```python
class Node:
    def __init__(self, item):
        self.item = item
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.length = 0
    
    def insert_first(self, x):
        new_node = Node(x)
        new_node.next = self.head
        self.head = new_node
        self.length += 1
    
    def get_at(self, i):
        current = self.head
        for _ in range(i):
            current = current.next
        return current.item
```

## ğŸ¯ OtimizaÃ§Ãµes

### ğŸ Tail Pointer
- **Adiciona**: Ponteiro para Ãºltimo nÃ³
- **BenefÃ­cio**: `insert_last()` e `get_last()` em O(1)
- **Custo**: Manter ponteiro atualizado

### ğŸ”„ Doubly Linked List
- **Estrutura**: `{prev, item, next}`
- **BenefÃ­cio**: `delete_last()` em O(1)
- **Custo**: Mais memÃ³ria e complexidade

## ğŸ’¡ Insights TeÃ³ricos
- **Modelo Word RAM**: Ponteiros = endereÃ§os de memÃ³ria
- **AlocaÃ§Ã£o dinÃ¢mica**: Cada nÃ³ = array de tamanho 2
- **Trade-off fundamental**: Flexibilidade vs velocidade de acesso
- **Complementaridade**: Arrays vs listas tÃªm vantagens opostas 