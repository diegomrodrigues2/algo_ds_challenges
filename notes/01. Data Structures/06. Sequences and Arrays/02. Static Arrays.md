# ğŸ”’ Static Arrays

## ğŸ¯ DefiniÃ§Ã£o
**Array estÃ¡tico** = bloco contÃ­guo de memÃ³ria com tamanho fixo

### ğŸ—ï¸ ImplementaÃ§Ã£o
- **MemÃ³ria**: Bloco consecutivo de palavras
- **Acesso**: `array[i] = memory[base_address + i]`
- **Tamanho**: Fixo durante toda vida Ãºtil

## âš¡ OperaÃ§Ãµes e Complexidade

| OperaÃ§Ã£o | Complexidade | DescriÃ§Ã£o |
|----------|-------------|-----------|
| `build(x)` | O(n) | Aloca e inicializa array |
| `get_at(i)` | O(1) | Acesso direto por Ã­ndice |
| `set_at(i, x)` | O(1) | ModificaÃ§Ã£o direta |
| `length()` | O(1) | Retorna tamanho fixo |
| `iter()` | O(n) | Percorre todos elementos |

## âœ… Vantagens
- **ğŸš€ Acesso rÃ¡pido**: O(1) para qualquer posiÃ§Ã£o
- **ğŸ’¾ EficiÃªncia espacial**: Sem overhead de ponteiros
- **ğŸ”„ Cache-friendly**: Dados contÃ­guos na memÃ³ria
- **ğŸ“ Simplicidade**: ImplementaÃ§Ã£o direta

## âŒ LimitaÃ§Ãµes
- **ğŸ”’ Tamanho fixo**: NÃ£o pode crescer/diminuir
- **ğŸ“ PrÃ©-alocaÃ§Ã£o**: Deve conhecer tamanho antecipadamente
- **ğŸ”„ InserÃ§Ã£o/remoÃ§Ã£o**: Requer realocaÃ§Ã£o completa

## ğŸ¯ Casos de Uso
- **Dados imutÃ¡veis**: Tamanho conhecido a priori
- **Acesso aleatÃ³rio**: PadrÃ£o de acesso uniforme
- **Performance crÃ­tica**: Quando velocidade Ã© essencial
- **MemÃ³ria limitada**: Sem overhead de estruturas dinÃ¢micas

## ğŸ”§ ImplementaÃ§Ã£o PrÃ¡tica
```python
# Conceitual - nÃ£o existe em Python puro
class StaticArray:
    def __init__(self, size):
        self.size = size
        self.data = [None] * size  # Simula alocaÃ§Ã£o estÃ¡tica
    
    def get_at(self, i):
        return self.data[i]
    
    def set_at(self, i, x):
        self.data[i] = x
```

## ğŸ’¡ Insights TeÃ³ricos
- **Modelo Word RAM**: Base para anÃ¡lise de complexidade
- **Acesso constante**: PossÃ­vel devido Ã  contiguidade
- **AlocaÃ§Ã£o linear**: Custo inevitÃ¡vel para criaÃ§Ã£o 