# 🎯 Aplicações Avançadas do Heap

## 🎯 Visão Geral

Heaps são fundamentais para **muitos algoritmos avançados** e problemas práticos. Sua eficiência em encontrar extremos torna-os ideais para problemas de seleção e ordenação parcial.

## 🎯 K Maiores/Menores Elementos

### 🌟 **Problema**
Encontrar os **k maiores** ou **k menores** elementos de um array sem ordenar completamente.

### 📝 **Implementação com Min-Heap**
```python
def k_largest_elements(arr, k):
    # Usa min-heap para manter k maiores
    heap = []
    
    for num in arr:
        if len(heap) < k:
            heapq.heappush(heap, num)
        elif num > heap[0]:
            heapq.heapreplace(heap, num)
    
    # Retorna em ordem decrescente
    return sorted(heap, reverse=True)

def k_smallest_elements(arr, k):
    # Usa max-heap para manter k menores
    heap = []
    
    for num in arr:
        if len(heap) < k:
            heapq.heappush(heap, -num)  # Negativo para max-heap
        elif -num > heap[0]:
            heapq.heapreplace(heap, -num)
    
    return [-x for x in sorted(heap, reverse=True)]
```

### ⚡ **Complexidade**
- **⏰ Tempo**: O(n log k) - melhor que O(n log n)
- **💾 Espaço**: O(k) - independente do tamanho do array

## 🔄 Merge K Sorted Lists

### 🌟 **Problema**
Combinar **k listas ordenadas** em uma única lista ordenada.

### 📝 **Implementação**
```python
def merge_k_sorted_lists(lists):
    heap = []
    result = []
    
    # Insere primeiro elemento de cada lista
    for i, lst in enumerate(lists):
        if lst:
            heapq.heappush(heap, (lst[0], i, 0))
    
    while heap:
        val, list_idx, elem_idx = heapq.heappop(heap)
        result.append(val)
        
        # Adiciona próximo elemento da mesma lista
        if elem_idx + 1 < len(lists[list_idx]):
            next_val = lists[list_idx][elem_idx + 1]
            heapq.heappush(heap, (next_val, list_idx, elem_idx + 1))
    
    return result
```

### 🎯 **Exemplo**
```
Listas: [1,4,5], [1,3,4], [2,6]
Heap: [(1,0,0), (1,1,0), (2,2,0)]
Resultado: [1,1,2,3,4,4,5,6]
```

## 📊 Median Finder

### 🌟 **Problema**
Manter a **mediana** de um stream de números em tempo real.

### 📝 **Implementação com Two Heaps**
```python
class MedianFinder:
    def __init__(self):
        self.max_heap = []  # Metade menor (max-heap)
        self.min_heap = []  # Metade maior (min-heap)
    
    def add_num(self, num):
        # Adiciona na max-heap primeiro
        heapq.heappush(self.max_heap, -num)
        
        # Move maior elemento para min-heap
        heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap))
        
        # Balanceia os heaps
        if len(self.max_heap) < len(self.min_heap):
            heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap))
    
    def find_median(self):
        if len(self.max_heap) > len(self.min_heap):
            return -self.max_heap[0]
        return (-self.max_heap[0] + self.min_heap[0]) / 2
```

### 🎯 **Estratégia**
- **📉 Max-heap**: Armazena metade menor dos números
- **📈 Min-heap**: Armazena metade maior dos números
- **⚖️ Mediana**: Raiz do max-heap (ímpar) ou média das raízes (par)

## 🔥 Top K Frequent Elements

### 🌟 **Problema**
Encontrar os **k elementos mais frequentes** em um array.

### 📝 **Implementação**
```python
def top_k_frequent(nums, k):
    # Conta frequências
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    
    # Min-heap para manter k mais frequentes
    heap = []
    for num, count in freq.items():
        if len(heap) < k:
            heapq.heappush(heap, (count, num))
        elif count > heap[0][0]:
            heapq.heapreplace(heap, (count, num))
    
    return [num for count, num in sorted(heap, reverse=True)]
```

### 🎯 **Variação com Bucket Sort**
```python
def top_k_frequent_bucket(nums, k):
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    
    # Bucket sort por frequência
    buckets = [[] for _ in range(len(nums) + 1)]
    for num, count in freq.items():
        buckets[count].append(num)
    
    # Coleta k mais frequentes
    result = []
    for i in range(len(buckets) - 1, -1, -1):
        result.extend(buckets[i])
        if len(result) >= k:
            break
    
    return result[:k]
```

## 🎮 Priority Queue Avançada

### 🌟 **Implementação Completa**
```python
class PriorityQueue:
    def __init__(self):
        self.heap = []
        self.count = 0  # Para desempate
    
    def push(self, priority, item):
        # (prioridade, contador, item) para desempate
        heapq.heappush(self.heap, (priority, self.count, item))
        self.count += 1
    
    def pop(self):
        if not self.heap:
            raise IndexError("Queue vazia")
        return heapq.heappop(self.heap)[2]
    
    def peek(self):
        if not self.heap:
            raise IndexError("Queue vazia")
        return self.heap[0][2]
    
    def size(self):
        return len(self.heap)
```

## 🔧 Dijkstra's Algorithm

### 🌟 **Implementação com Heap**
```python
def dijkstra_heap(graph, start):
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    
    heap = [(0, start)]
    visited = set()
    
    while heap:
        dist, node = heapq.heappop(heap)
        
        if node in visited:
            continue
        
        visited.add(node)
        
        for neighbor, weight in graph[node].items():
            if neighbor not in visited:
                new_dist = dist + weight
                if new_dist < distances[neighbor]:
                    distances[neighbor] = new_dist
                    heapq.heappush(heap, (new_dist, neighbor))
    
    return distances
```

## 🎯 Sliding Window Median

### 🌟 **Problema**
Encontrar a mediana de cada janela deslizante de tamanho k.

### 📝 **Implementação**
```python
def sliding_window_median(nums, k):
    def get_median(max_heap, min_heap):
        if len(max_heap) > len(min_heap):
            return -max_heap[0]
        return (-max_heap[0] + min_heap[0]) / 2
    
    max_heap = []  # Metade menor
    min_heap = []  # Metade maior
    result = []
    
    for i, num in enumerate(nums):
        # Adiciona novo elemento
        heapq.heappush(max_heap, -num)
        heapq.heappush(min_heap, -heapq.heappop(max_heap))
        
        if len(max_heap) < len(min_heap):
            heapq.heappush(max_heap, -heapq.heappop(min_heap))
        
        # Remove elemento antigo se necessário
        if i >= k:
            remove_num = nums[i - k]
            if remove_num <= -max_heap[0]:
                # Remove da max-heap
                max_heap.remove(-remove_num)
                heapq.heapify(max_heap)
            else:
                # Remove da min-heap
                min_heap.remove(remove_num)
                heapq.heapify(min_heap)
        
        # Balanceia após remoção
        if len(max_heap) < len(min_heap):
            heapq.heappush(max_heap, -heapq.heappop(min_heap))
        
        if i >= k - 1:
            result.append(get_median(max_heap, min_heap))
    
    return result
```

## 💡 Dicas de Implementação

### 🎯 **Pontos-Chave**
- **📊 Escolha heap correto**: Min-heap para k maiores, max-heap para k menores
- **🔄 Mantenha balance**: Para median finder
- **⚡ Otimize remoção**: Para sliding window
- **📏 Controle tamanho**: Evite heaps muito grandes

### 🔧 **Otimizações**
- **📊 Lazy deletion**: Marcar elementos como deletados
- **🔄 Bulk operations**: Inserir múltiplos elementos
- **⚡ Custom comparators**: Para objetos complexos
- **💾 Memory pooling**: Reutilizar estruturas

### 🎯 **Casos Especiais**
- **📊 k > n/2**: Use heap oposto
- **🔄 Elementos iguais**: Defina ordem consistente
- **⚡ Stream infinito**: Considere memory limits
- **📏 Real-time**: Otimize para latência 