# ğŸ—‚ï¸ Binary Heap

## ğŸ¯ O que Ã© uma Binary Heap?

**Binary Heap** Ã© uma estrutura de dados em Ã¡rvore binÃ¡ria que satisfaz a **propriedade de heap**. Ã‰ uma Ã¡rvore binÃ¡ria completa onde cada nÃ³ Ã© maior (max-heap) ou menor (min-heap) que seus filhos.

### ğŸŒŸ **Propriedade Fundamental**
```
Para qualquer nÃ³ N:
- Min-heap: N â‰¤ todos os filhos de N
- Max-heap: N â‰¥ todos os filhos de N
```

## ğŸŒ³ Estrutura da Ãrvore

### ğŸ“Š **CaracterÃ­sticas**
- **ğŸŒ³ Ãrvore binÃ¡ria completa**: Todos os nÃ­veis preenchidos (exceto o Ãºltimo)
- **ğŸ“Š Propriedade de heap**: RelaÃ§Ã£o pai-filho especÃ­fica
- **ğŸ”„ RepresentaÃ§Ã£o em array**: Eficiente e compacta

### ğŸ¨ **Analogia Simples**
> **Fila de prioridade**: Como uma fila onde o mais importante sempre vai na frente, mas com inserÃ§Ã£o e remoÃ§Ã£o eficientes.

## ğŸ”„ RepresentaÃ§Ã£o em Array

### ğŸ“Š **Mapeamento Ãrvore â†” Array**
```
Ãndice i no array:
- Pai: (i-1) // 2
- Filho esquerdo: 2*i + 1
- Filho direito: 2*i + 2
```

### ğŸ¯ **Exemplo Visual**
```
Array: [10, 20, 15, 30, 40, 50, 60]

Ãrvore:
       10
     /    \
   20     15
  /  \   /  \
30   40 50   60
```

## ğŸ“‰ Min-heap vs ğŸ“ˆ Max-heap

### ğŸ“Š **ComparaÃ§Ã£o**
| Aspecto | ğŸ“‰ Min-heap | ğŸ“ˆ Max-heap |
|---------|-------------|-------------|
| **ğŸ¯ Raiz** | Menor elemento | Maior elemento |
| **ğŸ“Š Propriedade** | Pai â‰¤ filhos | Pai â‰¥ filhos |
| **ğŸ” AplicaÃ§Ã£o** | Priority queue | K-largest elements |
| **âš¡ OperaÃ§Ã£o** | extract_min() | extract_max() |

### ğŸ¯ **Escolha do Tipo**
- **ğŸ“‰ Min-heap**: Para encontrar menores elementos
- **ğŸ“ˆ Max-heap**: Para encontrar maiores elementos
- **ğŸ”„ ConversÃ£o**: Multiplicar por -1 para converter

## âš¡ Complexidade das OperaÃ§Ãµes

### ğŸ“ˆ **AnÃ¡lise de Complexidade**
| OperaÃ§Ã£o | Complexidade | ExplicaÃ§Ã£o |
|----------|--------------|------------|
| **ğŸ“Š InserÃ§Ã£o** | O(log n) | Bubble-up atÃ© a raiz |
| **ğŸ—‘ï¸ RemoÃ§Ã£o** | O(log n) | Bubble-down atÃ© a folha |
| **ğŸ‘€ Peek** | O(1) | Acesso direto Ã  raiz |
| **ğŸ—ï¸ Heapify** | O(n) | ConstruÃ§Ã£o bottom-up |
| **ğŸ“ Size** | O(1) | Contador mantido |

### ğŸ” **Por que O(log n)?**
- **ğŸ“Š Altura**: Ãrvore binÃ¡ria completa tem altura logâ‚‚(n)
- **ğŸ”„ Bubble-up**: MÃ¡ximo logâ‚‚(n) comparaÃ§Ãµes
- **â¬‡ï¸ Bubble-down**: MÃ¡ximo logâ‚‚(n) comparaÃ§Ãµes

## âœ… Vantagens vs âŒ Desvantagens

| Aspecto | âœ… Vantagem | âŒ Desvantagem |
|---------|-------------|----------------|
| **âš¡ Performance** | O(log n) inserÃ§Ã£o/remoÃ§Ã£o | NÃ£o Ã© O(1) como arrays |
| **ğŸ’¾ MemÃ³ria** | RepresentaÃ§Ã£o compacta | NÃ£o Ã© cache-friendly |
| **ğŸ” Busca** | O(1) para min/max | O(n) para busca geral |
| **ğŸ”„ OrdenaÃ§Ã£o** | Heap sort in-place | NÃ£o Ã© estÃ¡vel |

## ğŸ¯ AplicaÃ§Ãµes PrÃ¡ticas

### ğŸ”„ **Priority Queues**
- **ğŸ® Sistemas de jogo**: Processamento de eventos
- **ğŸ“¦ Sistemas de build**: OrdenaÃ§Ã£o de tarefas
- **ğŸŒ Networking**: Pacotes com prioridade

### ğŸ“Š **Algoritmos de OrdenaÃ§Ã£o**
- **ğŸ“ˆ Heap sort**: OrdenaÃ§Ã£o in-place O(n log n)
- **ğŸ¯ Partial sorting**: K maiores/menores elementos
- **ğŸ”„ External sorting**: Para dados grandes

### ğŸ—ï¸ **Sistemas Reais**
- **ğŸ”§ Schedulers**: Sistemas operacionais
- **ğŸ“Š Databases**: Ãndices de prioridade
- **ğŸ¯ AI/ML**: Algoritmos de busca (A*, Dijkstra)

## ğŸ”„ Propriedades MatemÃ¡ticas

### ğŸ“Š **Altura da Ãrvore**
```
Altura = âŒŠlogâ‚‚(n)âŒ‹
NÃºmero de nÃ³s no nÃ­vel h = 2^h
```

### ğŸ¯ **Ãndices Importantes**
```
Primeiro nÃ³ nÃ£o-folha: n//2 - 1
Ãšltimo nÃ³: n - 1
```

### ğŸ” **ValidaÃ§Ã£o**
```
Para min-heap: arr[i] â‰¤ arr[2*i+1] e arr[i] â‰¤ arr[2*i+2]
Para max-heap: arr[i] â‰¥ arr[2*i+1] e arr[i] â‰¥ arr[2*i+2]
```

## ğŸ’¡ Dicas de ImplementaÃ§Ã£o

### ğŸ¯ **Pontos-Chave**
- **ğŸ“Š Use array**: RepresentaÃ§Ã£o mais eficiente
- **ğŸ”„ Mantenha propriedade**: ApÃ³s cada operaÃ§Ã£o
- **âš¡ Otimize Ã­ndices**: Calcule pai/filhos eficientemente
- **ğŸ“ Controle tamanho**: Mantenha contador atualizado

### ğŸ”§ **OtimizaÃ§Ãµes**
- **ğŸ“Š Lazy deletion**: Marcar como deletado
- **ğŸ”„ Bulk operations**: Inserir mÃºltiplos elementos
- **ğŸ’¾ Memory pooling**: Reutilizar arrays
- **âš¡ SIMD**: Para operaÃ§Ãµes paralelas

## ğŸ¯ ComparaÃ§Ã£o com Outras Estruturas

| Estrutura | InserÃ§Ã£o | RemoÃ§Ã£o | Peek | AplicaÃ§Ã£o |
|-----------|----------|---------|------|-----------|
| **ğŸ—‚ï¸ Heap** | O(log n) | O(log n) | O(1) | Priority queue |
| **ğŸ“Š Array** | O(1) | O(n) | O(n) | Acesso aleatÃ³rio |
| **ğŸŒ³ BST** | O(log n) | O(log n) | O(log n) | Busca ordenada |
| **ğŸ“¦ Stack** | O(1) | O(1) | O(1) | LIFO | 