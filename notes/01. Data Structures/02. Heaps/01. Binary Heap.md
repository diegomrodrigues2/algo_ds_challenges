# 🗂️ Binary Heap

## 🎯 O que é uma Binary Heap?

**Binary Heap** é uma estrutura de dados em árvore binária que satisfaz a **propriedade de heap**. É uma árvore binária completa onde cada nó é maior (max-heap) ou menor (min-heap) que seus filhos.

### 🌟 **Propriedade Fundamental**
```
Para qualquer nó N:
- Min-heap: N ≤ todos os filhos de N
- Max-heap: N ≥ todos os filhos de N
```

## 🌳 Estrutura da Árvore

### 📊 **Características**
- **🌳 Árvore binária completa**: Todos os níveis preenchidos (exceto o último)
- **📊 Propriedade de heap**: Relação pai-filho específica
- **🔄 Representação em array**: Eficiente e compacta

### 🎨 **Analogia Simples**
> **Fila de prioridade**: Como uma fila onde o mais importante sempre vai na frente, mas com inserção e remoção eficientes.

## 🔄 Representação em Array

### 📊 **Mapeamento Árvore ↔ Array**
```
Índice i no array:
- Pai: (i-1) // 2
- Filho esquerdo: 2*i + 1
- Filho direito: 2*i + 2
```

### 🎯 **Exemplo Visual**
```
Array: [10, 20, 15, 30, 40, 50, 60]

Árvore:
       10
     /    \
   20     15
  /  \   /  \
30   40 50   60
```

## 📉 Min-heap vs 📈 Max-heap

### 📊 **Comparação**
| Aspecto | 📉 Min-heap | 📈 Max-heap |
|---------|-------------|-------------|
| **🎯 Raiz** | Menor elemento | Maior elemento |
| **📊 Propriedade** | Pai ≤ filhos | Pai ≥ filhos |
| **🔍 Aplicação** | Priority queue | K-largest elements |
| **⚡ Operação** | extract_min() | extract_max() |

### 🎯 **Escolha do Tipo**
- **📉 Min-heap**: Para encontrar menores elementos
- **📈 Max-heap**: Para encontrar maiores elementos
- **🔄 Conversão**: Multiplicar por -1 para converter

## ⚡ Complexidade das Operações

### 📈 **Análise de Complexidade**
| Operação | Complexidade | Explicação |
|----------|--------------|------------|
| **📊 Inserção** | O(log n) | Bubble-up até a raiz |
| **🗑️ Remoção** | O(log n) | Bubble-down até a folha |
| **👀 Peek** | O(1) | Acesso direto à raiz |
| **🏗️ Heapify** | O(n) | Construção bottom-up |
| **📏 Size** | O(1) | Contador mantido |

### 🔍 **Por que O(log n)?**
- **📊 Altura**: Árvore binária completa tem altura log₂(n)
- **🔄 Bubble-up**: Máximo log₂(n) comparações
- **⬇️ Bubble-down**: Máximo log₂(n) comparações

## ✅ Vantagens vs ❌ Desvantagens

| Aspecto | ✅ Vantagem | ❌ Desvantagem |
|---------|-------------|----------------|
| **⚡ Performance** | O(log n) inserção/remoção | Não é O(1) como arrays |
| **💾 Memória** | Representação compacta | Não é cache-friendly |
| **🔍 Busca** | O(1) para min/max | O(n) para busca geral |
| **🔄 Ordenação** | Heap sort in-place | Não é estável |

## 🎯 Aplicações Práticas

### 🔄 **Priority Queues**
- **🎮 Sistemas de jogo**: Processamento de eventos
- **📦 Sistemas de build**: Ordenação de tarefas
- **🌐 Networking**: Pacotes com prioridade

### 📊 **Algoritmos de Ordenação**
- **📈 Heap sort**: Ordenação in-place O(n log n)
- **🎯 Partial sorting**: K maiores/menores elementos
- **🔄 External sorting**: Para dados grandes

### 🏗️ **Sistemas Reais**
- **🔧 Schedulers**: Sistemas operacionais
- **📊 Databases**: Índices de prioridade
- **🎯 AI/ML**: Algoritmos de busca (A*, Dijkstra)

## 🔄 Propriedades Matemáticas

### 📊 **Altura da Árvore**
```
Altura = ⌊log₂(n)⌋
Número de nós no nível h = 2^h
```

### 🎯 **Índices Importantes**
```
Primeiro nó não-folha: n//2 - 1
Último nó: n - 1
```

### 🔍 **Validação**
```
Para min-heap: arr[i] ≤ arr[2*i+1] e arr[i] ≤ arr[2*i+2]
Para max-heap: arr[i] ≥ arr[2*i+1] e arr[i] ≥ arr[2*i+2]
```

## 💡 Dicas de Implementação

### 🎯 **Pontos-Chave**
- **📊 Use array**: Representação mais eficiente
- **🔄 Mantenha propriedade**: Após cada operação
- **⚡ Otimize índices**: Calcule pai/filhos eficientemente
- **📏 Controle tamanho**: Mantenha contador atualizado

### 🔧 **Otimizações**
- **📊 Lazy deletion**: Marcar como deletado
- **🔄 Bulk operations**: Inserir múltiplos elementos
- **💾 Memory pooling**: Reutilizar arrays
- **⚡ SIMD**: Para operações paralelas

## 🎯 Comparação com Outras Estruturas

| Estrutura | Inserção | Remoção | Peek | Aplicação |
|-----------|----------|---------|------|-----------|
| **🗂️ Heap** | O(log n) | O(log n) | O(1) | Priority queue |
| **📊 Array** | O(1) | O(n) | O(n) | Acesso aleatório |
| **🌳 BST** | O(log n) | O(log n) | O(log n) | Busca ordenada |
| **📦 Stack** | O(1) | O(1) | O(1) | LIFO | 