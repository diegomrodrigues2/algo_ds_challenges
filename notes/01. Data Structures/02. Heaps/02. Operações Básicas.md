# ğŸ”„ OperaÃ§Ãµes BÃ¡sicas do Heap

## ğŸ¯ VisÃ£o Geral

As operaÃ§Ãµes bÃ¡sicas do heap garantem que a **propriedade de heap** seja mantida apÃ³s cada modificaÃ§Ã£o. Cada operaÃ§Ã£o tem complexidade O(log n) e usa algoritmos de **bubble-up** e **bubble-down**.

## ğŸ“Š InserÃ§Ã£o (Bubble-Up)

### ğŸŒŸ **Processo de InserÃ§Ã£o**
1. **ğŸ“ Adiciona elemento** no final do array
2. **â¬†ï¸ Compara com pai** e troca se necessÃ¡rio
3. **ğŸ”„ Repete** atÃ© a propriedade ser satisfeita

### ğŸ“ **ImplementaÃ§Ã£o**
```python
def insert(self, value):
    # Adiciona no final
    self._data.append(value)
    
    # Bubble-up
    self._bubble_up(len(self._data) - 1)

def _bubble_up(self, index):
    while index > 0:
        pai = (index - 1) // 2
        
        # Para min-heap: troca se filho < pai
        if self._data[index] < self._data[pai]:
            self._data[index], self._data[pai] = self._data[pai], self._data[index]
            index = pai
        else:
            break
```

### ğŸ¯ **Exemplo Visual**
```
Inserir 5 na min-heap [10, 20, 15, 30, 40, 50, 60]

Passo 1: [10, 20, 15, 30, 40, 50, 60, 5]
Passo 2: [10, 20, 15, 5, 40, 50, 60, 30]
Passo 3: [5, 20, 15, 10, 40, 50, 60, 30]
```

## ğŸ—‘ï¸ RemoÃ§Ã£o (Bubble-Down)

### ğŸŒŸ **Processo de RemoÃ§Ã£o**
1. **ğŸ‘€ Remove elemento** da raiz
2. **ğŸ“ Coloca Ãºltimo elemento** na raiz
3. **â¬‡ï¸ Compara com filhos** e troca se necessÃ¡rio
4. **ğŸ”„ Repete** atÃ© a propriedade ser satisfeita

### ğŸ“ **ImplementaÃ§Ã£o**
```python
def extract_min(self):
    if not self._data:
        raise IndexError("Heap vazia")
    
    # Remove raiz
    min_val = self._data[0]
    
    # Coloca Ãºltimo elemento na raiz
    self._data[0] = self._data.pop()
    
    # Bubble-down se necessÃ¡rio
    if self._data:
        self._bubble_down(0)
    
    return min_val

def _bubble_down(self, index):
    while True:
        menor = index
        esquerdo = 2 * index + 1
        direito = 2 * index + 2
        
        # Encontra o menor filho
        if esquerdo < len(self._data) and self._data[esquerdo] < self._data[menor]:
            menor = esquerdo
        
        if direito < len(self._data) and self._data[direito] < self._data[menor]:
            menor = direito
        
        # Se nÃ£o precisa trocar, para
        if menor == index:
            break
        
        # Troca com o menor filho
        self._data[index], self._data[menor] = self._data[menor], self._data[index]
        index = menor
```

### ğŸ¯ **Exemplo Visual**
```
Remover raiz da min-heap [5, 20, 15, 10, 40, 50, 60, 30]

Passo 1: Remove 5, coloca 30 na raiz
Passo 2: [30, 20, 15, 10, 40, 50, 60]
Passo 3: [15, 20, 30, 10, 40, 50, 60]
Passo 4: [10, 20, 30, 15, 40, 50, 60]
```

## ğŸ—ï¸ Heapify (ConstruÃ§Ã£o)

### ğŸŒŸ **Heapify Bottom-Up**
ConstrÃ³i uma heap a partir de um array nÃ£o-ordenado em O(n).

### ğŸ“ **ImplementaÃ§Ã£o**
```python
def heapify(self, arr):
    self._data = arr.copy()
    
    # ComeÃ§a do Ãºltimo nÃ³ nÃ£o-folha
    for i in range(len(self._data) // 2 - 1, -1, -1):
        self._bubble_down(i)

def heapify_inplace(arr):
    # Heapify in-place
    for i in range(len(arr) // 2 - 1, -1, -1):
        _bubble_down_inplace(arr, i, len(arr))

def _bubble_down_inplace(arr, index, size):
    while True:
        menor = index
        esquerdo = 2 * index + 1
        direito = 2 * index + 2
        
        if esquerdo < size and arr[esquerdo] < arr[menor]:
            menor = esquerdo
        
        if direito < size and arr[direito] < arr[menor]:
            menor = direito
        
        if menor == index:
            break
        
        arr[index], arr[menor] = arr[menor], arr[index]
        index = menor
```

### ğŸ¯ **Por que O(n)?**
- **ğŸ“Š Altura h**: logâ‚‚(n)
- **ğŸ”„ NÃ³s no nÃ­vel h**: n/2^h
- **âš¡ Custo total**: Î£(h=0 to log n) n/2^h * h = O(n)

## ğŸ‘€ OperaÃ§Ãµes de Acesso

### ğŸ“Š **Peek (Ver sem Remover)**
```python
def peek(self):
    if not self._data:
        raise IndexError("Heap vazia")
    return self._data[0]
```

### ğŸ“ **Size (Tamanho)**
```python
def size(self):
    return len(self._data)

def is_empty(self):
    return len(self._data) == 0
```

## ğŸ”„ OperaÃ§Ãµes AvanÃ§adas

### ğŸ—‘ï¸ **Decrease Key**
```python
def decrease_key(self, index, new_value):
    if new_value > self._data[index]:
        raise ValueError("Novo valor deve ser menor")
    
    self._data[index] = new_value
    self._bubble_up(index)
```

### ğŸ—‘ï¸ **Delete Key**
```python
def delete_key(self, index):
    # Decrease para -âˆ
    self._data[index] = float('-inf')
    self._bubble_up(index)
    
    # Remove mÃ­nimo
    return self.extract_min()
```

## âš¡ OtimizaÃ§Ãµes

### ğŸ”§ **Bubble-Up Otimizado**
```python
def _bubble_up_optimized(self, index):
    valor = self._data[index]
    
    while index > 0:
        pai = (index - 1) // 2
        if self._data[pai] <= valor:
            break
        self._data[index] = self._data[pai]
        index = pai
    
    self._data[index] = valor
```

### ğŸ”§ **Bubble-Down Otimizado**
```python
def _bubble_down_optimized(self, index):
    valor = self._data[index]
    
    while True:
        menor = index
        esquerdo = 2 * index + 1
        direito = 2 * index + 2
        
        if esquerdo < len(self._data) and self._data[esquerdo] < self._data[menor]:
            menor = esquerdo
        
        if direito < len(self._data) and self._data[direito] < self._data[menor]:
            menor = direito
        
        if menor == index:
            break
        
        self._data[index] = self._data[menor]
        index = menor
    
    self._data[index] = valor
```

## ğŸ’¡ Dicas de ImplementaÃ§Ã£o

### ğŸ¯ **Pontos-Chave**
- **ğŸ“Š Sempre verifique Ã­ndices**: Evite IndexError
- **ğŸ”„ Mantenha propriedade**: ApÃ³s cada operaÃ§Ã£o
- **âš¡ Otimize comparaÃ§Ãµes**: Reduza swaps desnecessÃ¡rios
- **ğŸ“ Controle tamanho**: Atualize contadores

### ğŸ”§ **Casos Especiais**
- **ğŸ“Š Heap vazia**: Trate adequadamente
- **ğŸ”„ Elementos iguais**: Defina ordem consistente
- **âš¡ Heap de um elemento**: Caso base
- **ğŸ“ Heap de dois elementos**: Caso especial

### ğŸ¯ **Debugging**
- **ğŸ“Š Valide propriedade**: ApÃ³s cada operaÃ§Ã£o
- **ğŸ”„ Desenhe Ã¡rvore**: Para visualizar mudanÃ§as
- **âš¡ Trace execuÃ§Ã£o**: Com arrays pequenos
- **ğŸ“ Verifique Ã­ndices**: Pai/filhos corretos 