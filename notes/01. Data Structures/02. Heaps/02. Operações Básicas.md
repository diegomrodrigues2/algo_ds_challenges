# 🔄 Operações Básicas do Heap

## 🎯 Visão Geral

As operações básicas do heap garantem que a **propriedade de heap** seja mantida após cada modificação. Cada operação tem complexidade O(log n) e usa algoritmos de **bubble-up** e **bubble-down**.

## 📊 Inserção (Bubble-Up)

### 🌟 **Processo de Inserção**
1. **📝 Adiciona elemento** no final do array
2. **⬆️ Compara com pai** e troca se necessário
3. **🔄 Repete** até a propriedade ser satisfeita

### 📝 **Implementação**
```python
def insert(self, value):
    # Adiciona no final
    self._data.append(value)
    
    # Bubble-up
    self._bubble_up(len(self._data) - 1)

def _bubble_up(self, index):
    while index > 0:
        pai = (index - 1) // 2
        
        # Para min-heap: troca se filho < pai
        if self._data[index] < self._data[pai]:
            self._data[index], self._data[pai] = self._data[pai], self._data[index]
            index = pai
        else:
            break
```

### 🎯 **Exemplo Visual**
```
Inserir 5 na min-heap [10, 20, 15, 30, 40, 50, 60]

Passo 1: [10, 20, 15, 30, 40, 50, 60, 5]
Passo 2: [10, 20, 15, 5, 40, 50, 60, 30]
Passo 3: [5, 20, 15, 10, 40, 50, 60, 30]
```

## 🗑️ Remoção (Bubble-Down)

### 🌟 **Processo de Remoção**
1. **👀 Remove elemento** da raiz
2. **📝 Coloca último elemento** na raiz
3. **⬇️ Compara com filhos** e troca se necessário
4. **🔄 Repete** até a propriedade ser satisfeita

### 📝 **Implementação**
```python
def extract_min(self):
    if not self._data:
        raise IndexError("Heap vazia")
    
    # Remove raiz
    min_val = self._data[0]
    
    # Coloca último elemento na raiz
    self._data[0] = self._data.pop()
    
    # Bubble-down se necessário
    if self._data:
        self._bubble_down(0)
    
    return min_val

def _bubble_down(self, index):
    while True:
        menor = index
        esquerdo = 2 * index + 1
        direito = 2 * index + 2
        
        # Encontra o menor filho
        if esquerdo < len(self._data) and self._data[esquerdo] < self._data[menor]:
            menor = esquerdo
        
        if direito < len(self._data) and self._data[direito] < self._data[menor]:
            menor = direito
        
        # Se não precisa trocar, para
        if menor == index:
            break
        
        # Troca com o menor filho
        self._data[index], self._data[menor] = self._data[menor], self._data[index]
        index = menor
```

### 🎯 **Exemplo Visual**
```
Remover raiz da min-heap [5, 20, 15, 10, 40, 50, 60, 30]

Passo 1: Remove 5, coloca 30 na raiz
Passo 2: [30, 20, 15, 10, 40, 50, 60]
Passo 3: [15, 20, 30, 10, 40, 50, 60]
Passo 4: [10, 20, 30, 15, 40, 50, 60]
```

## 🏗️ Heapify (Construção)

### 🌟 **Heapify Bottom-Up**
Constrói uma heap a partir de um array não-ordenado em O(n).

### 📝 **Implementação**
```python
def heapify(self, arr):
    self._data = arr.copy()
    
    # Começa do último nó não-folha
    for i in range(len(self._data) // 2 - 1, -1, -1):
        self._bubble_down(i)

def heapify_inplace(arr):
    # Heapify in-place
    for i in range(len(arr) // 2 - 1, -1, -1):
        _bubble_down_inplace(arr, i, len(arr))

def _bubble_down_inplace(arr, index, size):
    while True:
        menor = index
        esquerdo = 2 * index + 1
        direito = 2 * index + 2
        
        if esquerdo < size and arr[esquerdo] < arr[menor]:
            menor = esquerdo
        
        if direito < size and arr[direito] < arr[menor]:
            menor = direito
        
        if menor == index:
            break
        
        arr[index], arr[menor] = arr[menor], arr[index]
        index = menor
```

### 🎯 **Por que O(n)?**
- **📊 Altura h**: log₂(n)
- **🔄 Nós no nível h**: n/2^h
- **⚡ Custo total**: Σ(h=0 to log n) n/2^h * h = O(n)

## 👀 Operações de Acesso

### 📊 **Peek (Ver sem Remover)**
```python
def peek(self):
    if not self._data:
        raise IndexError("Heap vazia")
    return self._data[0]
```

### 📏 **Size (Tamanho)**
```python
def size(self):
    return len(self._data)

def is_empty(self):
    return len(self._data) == 0
```

## 🔄 Operações Avançadas

### 🗑️ **Decrease Key**
```python
def decrease_key(self, index, new_value):
    if new_value > self._data[index]:
        raise ValueError("Novo valor deve ser menor")
    
    self._data[index] = new_value
    self._bubble_up(index)
```

### 🗑️ **Delete Key**
```python
def delete_key(self, index):
    # Decrease para -∞
    self._data[index] = float('-inf')
    self._bubble_up(index)
    
    # Remove mínimo
    return self.extract_min()
```

## ⚡ Otimizações

### 🔧 **Bubble-Up Otimizado**
```python
def _bubble_up_optimized(self, index):
    valor = self._data[index]
    
    while index > 0:
        pai = (index - 1) // 2
        if self._data[pai] <= valor:
            break
        self._data[index] = self._data[pai]
        index = pai
    
    self._data[index] = valor
```

### 🔧 **Bubble-Down Otimizado**
```python
def _bubble_down_optimized(self, index):
    valor = self._data[index]
    
    while True:
        menor = index
        esquerdo = 2 * index + 1
        direito = 2 * index + 2
        
        if esquerdo < len(self._data) and self._data[esquerdo] < self._data[menor]:
            menor = esquerdo
        
        if direito < len(self._data) and self._data[direito] < self._data[menor]:
            menor = direito
        
        if menor == index:
            break
        
        self._data[index] = self._data[menor]
        index = menor
    
    self._data[index] = valor
```

## 💡 Dicas de Implementação

### 🎯 **Pontos-Chave**
- **📊 Sempre verifique índices**: Evite IndexError
- **🔄 Mantenha propriedade**: Após cada operação
- **⚡ Otimize comparações**: Reduza swaps desnecessários
- **📏 Controle tamanho**: Atualize contadores

### 🔧 **Casos Especiais**
- **📊 Heap vazia**: Trate adequadamente
- **🔄 Elementos iguais**: Defina ordem consistente
- **⚡ Heap de um elemento**: Caso base
- **📏 Heap de dois elementos**: Caso especial

### 🎯 **Debugging**
- **📊 Valide propriedade**: Após cada operação
- **🔄 Desenhe árvore**: Para visualizar mudanças
- **⚡ Trace execução**: Com arrays pequenos
- **📏 Verifique índices**: Pai/filhos corretos 