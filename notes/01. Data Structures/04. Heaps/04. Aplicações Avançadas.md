# ğŸ¯ AplicaÃ§Ãµes AvanÃ§adas do Heap

## ğŸ¯ VisÃ£o Geral

Heaps sÃ£o fundamentais para **muitos algoritmos avanÃ§ados** e problemas prÃ¡ticos. Sua eficiÃªncia em encontrar extremos torna-os ideais para problemas de seleÃ§Ã£o e ordenaÃ§Ã£o parcial.

## ğŸ¯ K Maiores/Menores Elementos

### ğŸŒŸ **Problema**
Encontrar os **k maiores** ou **k menores** elementos de um array sem ordenar completamente.

### ğŸ“ **ImplementaÃ§Ã£o com Min-Heap**
```python
def k_largest_elements(arr, k):
    # Usa min-heap para manter k maiores
    heap = []
    
    for num in arr:
        if len(heap) < k:
            heapq.heappush(heap, num)
        elif num > heap[0]:
            heapq.heapreplace(heap, num)
    
    # Retorna em ordem decrescente
    return sorted(heap, reverse=True)

def k_smallest_elements(arr, k):
    # Usa max-heap para manter k menores
    heap = []
    
    for num in arr:
        if len(heap) < k:
            heapq.heappush(heap, -num)  # Negativo para max-heap
        elif -num > heap[0]:
            heapq.heapreplace(heap, -num)
    
    return [-x for x in sorted(heap, reverse=True)]
```

### âš¡ **Complexidade**
- **â° Tempo**: O(n log k) - melhor que O(n log n)
- **ğŸ’¾ EspaÃ§o**: O(k) - independente do tamanho do array

## ğŸ”„ Merge K Sorted Lists

### ğŸŒŸ **Problema**
Combinar **k listas ordenadas** em uma Ãºnica lista ordenada.

### ğŸ“ **ImplementaÃ§Ã£o**
```python
def merge_k_sorted_lists(lists):
    heap = []
    result = []
    
    # Insere primeiro elemento de cada lista
    for i, lst in enumerate(lists):
        if lst:
            heapq.heappush(heap, (lst[0], i, 0))
    
    while heap:
        val, list_idx, elem_idx = heapq.heappop(heap)
        result.append(val)
        
        # Adiciona prÃ³ximo elemento da mesma lista
        if elem_idx + 1 < len(lists[list_idx]):
            next_val = lists[list_idx][elem_idx + 1]
            heapq.heappush(heap, (next_val, list_idx, elem_idx + 1))
    
    return result
```

### ğŸ¯ **Exemplo**
```
Listas: [1,4,5], [1,3,4], [2,6]
Heap: [(1,0,0), (1,1,0), (2,2,0)]
Resultado: [1,1,2,3,4,4,5,6]
```

## ğŸ“Š Median Finder

### ğŸŒŸ **Problema**
Manter a **mediana** de um stream de nÃºmeros em tempo real.

### ğŸ“ **ImplementaÃ§Ã£o com Two Heaps**
```python
class MedianFinder:
    def __init__(self):
        self.max_heap = []  # Metade menor (max-heap)
        self.min_heap = []  # Metade maior (min-heap)
    
    def add_num(self, num):
        # Adiciona na max-heap primeiro
        heapq.heappush(self.max_heap, -num)
        
        # Move maior elemento para min-heap
        heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap))
        
        # Balanceia os heaps
        if len(self.max_heap) < len(self.min_heap):
            heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap))
    
    def find_median(self):
        if len(self.max_heap) > len(self.min_heap):
            return -self.max_heap[0]
        return (-self.max_heap[0] + self.min_heap[0]) / 2
```

### ğŸ¯ **EstratÃ©gia**
- **ğŸ“‰ Max-heap**: Armazena metade menor dos nÃºmeros
- **ğŸ“ˆ Min-heap**: Armazena metade maior dos nÃºmeros
- **âš–ï¸ Mediana**: Raiz do max-heap (Ã­mpar) ou mÃ©dia das raÃ­zes (par)

## ğŸ”¥ Top K Frequent Elements

### ğŸŒŸ **Problema**
Encontrar os **k elementos mais frequentes** em um array.

### ğŸ“ **ImplementaÃ§Ã£o**
```python
def top_k_frequent(nums, k):
    # Conta frequÃªncias
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    
    # Min-heap para manter k mais frequentes
    heap = []
    for num, count in freq.items():
        if len(heap) < k:
            heapq.heappush(heap, (count, num))
        elif count > heap[0][0]:
            heapq.heapreplace(heap, (count, num))
    
    return [num for count, num in sorted(heap, reverse=True)]
```

### ğŸ¯ **VariaÃ§Ã£o com Bucket Sort**
```python
def top_k_frequent_bucket(nums, k):
    freq = {}
    for num in nums:
        freq[num] = freq.get(num, 0) + 1
    
    # Bucket sort por frequÃªncia
    buckets = [[] for _ in range(len(nums) + 1)]
    for num, count in freq.items():
        buckets[count].append(num)
    
    # Coleta k mais frequentes
    result = []
    for i in range(len(buckets) - 1, -1, -1):
        result.extend(buckets[i])
        if len(result) >= k:
            break
    
    return result[:k]
```

## ğŸ® Priority Queue AvanÃ§ada

### ğŸŒŸ **ImplementaÃ§Ã£o Completa**
```python
class PriorityQueue:
    def __init__(self):
        self.heap = []
        self.count = 0  # Para desempate
    
    def push(self, priority, item):
        # (prioridade, contador, item) para desempate
        heapq.heappush(self.heap, (priority, self.count, item))
        self.count += 1
    
    def pop(self):
        if not self.heap:
            raise IndexError("Queue vazia")
        return heapq.heappop(self.heap)[2]
    
    def peek(self):
        if not self.heap:
            raise IndexError("Queue vazia")
        return self.heap[0][2]
    
    def size(self):
        return len(self.heap)
```

## ğŸ”§ Dijkstra's Algorithm

### ğŸŒŸ **ImplementaÃ§Ã£o com Heap**
```python
def dijkstra_heap(graph, start):
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    
    heap = [(0, start)]
    visited = set()
    
    while heap:
        dist, node = heapq.heappop(heap)
        
        if node in visited:
            continue
        
        visited.add(node)
        
        for neighbor, weight in graph[node].items():
            if neighbor not in visited:
                new_dist = dist + weight
                if new_dist < distances[neighbor]:
                    distances[neighbor] = new_dist
                    heapq.heappush(heap, (new_dist, neighbor))
    
    return distances
```

## ğŸ¯ Sliding Window Median

### ğŸŒŸ **Problema**
Encontrar a mediana de cada janela deslizante de tamanho k.

### ğŸ“ **ImplementaÃ§Ã£o**
```python
def sliding_window_median(nums, k):
    def get_median(max_heap, min_heap):
        if len(max_heap) > len(min_heap):
            return -max_heap[0]
        return (-max_heap[0] + min_heap[0]) / 2
    
    max_heap = []  # Metade menor
    min_heap = []  # Metade maior
    result = []
    
    for i, num in enumerate(nums):
        # Adiciona novo elemento
        heapq.heappush(max_heap, -num)
        heapq.heappush(min_heap, -heapq.heappop(max_heap))
        
        if len(max_heap) < len(min_heap):
            heapq.heappush(max_heap, -heapq.heappop(min_heap))
        
        # Remove elemento antigo se necessÃ¡rio
        if i >= k:
            remove_num = nums[i - k]
            if remove_num <= -max_heap[0]:
                # Remove da max-heap
                max_heap.remove(-remove_num)
                heapq.heapify(max_heap)
            else:
                # Remove da min-heap
                min_heap.remove(remove_num)
                heapq.heapify(min_heap)
        
        # Balanceia apÃ³s remoÃ§Ã£o
        if len(max_heap) < len(min_heap):
            heapq.heappush(max_heap, -heapq.heappop(min_heap))
        
        if i >= k - 1:
            result.append(get_median(max_heap, min_heap))
    
    return result
```

## ğŸ’¡ Dicas de ImplementaÃ§Ã£o

### ğŸ¯ **Pontos-Chave**
- **ğŸ“Š Escolha heap correto**: Min-heap para k maiores, max-heap para k menores
- **ğŸ”„ Mantenha balance**: Para median finder
- **âš¡ Otimize remoÃ§Ã£o**: Para sliding window
- **ğŸ“ Controle tamanho**: Evite heaps muito grandes

### ğŸ”§ **OtimizaÃ§Ãµes**
- **ğŸ“Š Lazy deletion**: Marcar elementos como deletados
- **ğŸ”„ Bulk operations**: Inserir mÃºltiplos elementos
- **âš¡ Custom comparators**: Para objetos complexos
- **ğŸ’¾ Memory pooling**: Reutilizar estruturas

### ğŸ¯ **Casos Especiais**
- **ğŸ“Š k > n/2**: Use heap oposto
- **ğŸ”„ Elementos iguais**: Defina ordem consistente
- **âš¡ Stream infinito**: Considere memory limits
- **ğŸ“ Real-time**: Otimize para latÃªncia 