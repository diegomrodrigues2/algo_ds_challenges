# 📊 Heap Sort

## 🎯 O que é Heap Sort?

**Heap Sort** é um algoritmo de ordenação baseado na estrutura de dados **heap**. Ele usa a propriedade de que a raiz de uma heap sempre contém o maior (max-heap) ou menor (min-heap) elemento.

### 🌟 **Conceito Central**
```
1. Constrói uma heap a partir do array
2. Remove elementos da raiz um por um
3. Coloca na posição correta do array ordenado
```

## 🔄 Algoritmo

### 📊 **Processo em Duas Fases**
1. **🏗️ Build Heap**: Converte array em max-heap
2. **🔄 Extract & Place**: Remove raiz e coloca no final

### 📝 **Implementação**
```python
def heap_sort(arr):
    n = len(arr)
    
    # Fase 1: Constrói max-heap
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # Fase 2: Extrai elementos um por um
    for i in range(n - 1, 0, -1):
        # Troca raiz (maior) com último elemento
        arr[0], arr[i] = arr[i], arr[0]
        
        # Heapify na subárvore reduzida
        heapify(arr, i, 0)

def heapify(arr, n, i):
    maior = i
    esquerdo = 2 * i + 1
    direito = 2 * i + 2
    
    # Encontra o maior entre pai e filhos
    if esquerdo < n and arr[esquerdo] > arr[maior]:
        maior = esquerdo
    
    if direito < n and arr[direito] > arr[maior]:
        maior = direito
    
    # Se maior não é a raiz, troca e heapify
    if maior != i:
        arr[i], arr[maior] = arr[maior], arr[i]
        heapify(arr, n, maior)
```

## 🎯 Exemplo Visual

### 📊 **Array Original**: [12, 11, 13, 5, 6, 7]

### 🏗️ **Fase 1: Build Max-Heap**
```
Passo 1: [12, 11, 13, 5, 6, 7]
Passo 2: [12, 11, 13, 5, 6, 7]
Passo 3: [13, 11, 12, 5, 6, 7]
Passo 4: [13, 11, 12, 5, 6, 7]
```

### 🔄 **Fase 2: Extract & Place**
```
Passo 1: [7, 11, 12, 5, 6, 13]  # 13 vai para o final
Passo 2: [12, 11, 7, 5, 6, 13]  # Heapify
Passo 3: [6, 11, 7, 5, 12, 13]  # 12 vai para o final
Passo 4: [11, 6, 7, 5, 12, 13]  # Heapify
Passo 5: [5, 6, 7, 11, 12, 13]  # Continua...
```

## ⚡ Análise de Complexidade

### 📈 **Complexidade de Tempo**
| Fase | Complexidade | Explicação |
|------|--------------|------------|
| **🏗️ Build Heap** | O(n) | Heapify bottom-up |
| **🔄 Extract & Place** | O(n log n) | n extrações × log n |
| **📊 Total** | O(n log n) | Dominado pela segunda fase |

### 💾 **Complexidade de Espaço**
- **🔄 In-place**: O(1) espaço extra
- **📊 Recursão**: O(log n) pilha de recursão
- **⚡ Iterativo**: O(1) espaço total

### 🔍 **Por que O(n log n)?**
- **📊 n extrações**: Uma para cada elemento
- **🔄 log n por extração**: Altura da heap
- **⚡ Total**: n × log n = O(n log n)

## ✅ Vantagens vs ❌ Desvantagens

| Aspecto | ✅ Vantagem | ❌ Desvantagem |
|---------|-------------|----------------|
| **💾 Espaço** | In-place O(1) | Não é estável |
| **⚡ Performance** | O(n log n) garantido | Pior que quicksort na prática |
| **🔄 Consistência** | Sempre O(n log n) | Não adaptativo |
| **📊 Cache** | Não cache-friendly | Muitos swaps |

## 🎯 Comparação com Outros Algoritmos

| Algoritmo | Melhor | Médio | Pior | Espaço | Estável |
|-----------|--------|-------|------|--------|---------|
| **📊 Heap Sort** | O(n log n) | O(n log n) | O(n log n) | O(1) | ❌ |
| **🔄 Quick Sort** | O(n log n) | O(n log n) | O(n²) | O(log n) | ❌ |
| **📈 Merge Sort** | O(n log n) | O(n log n) | O(n log n) | O(n) | ✅ |
| **🔄 Bubble Sort** | O(n) | O(n²) | O(n²) | O(1) | ✅ |

## 🔧 Otimizações

### ⚡ **Heapify Iterativo**
```python
def heapify_iterative(arr, n, i):
    while True:
        maior = i
        esquerdo = 2 * i + 1
        direito = 2 * i + 2
        
        if esquerdo < n and arr[esquerdo] > arr[maior]:
            maior = esquerdo
        
        if direito < n and arr[direito] > arr[maior]:
            maior = direito
        
        if maior == i:
            break
        
        arr[i], arr[maior] = arr[maior], arr[i]
        i = maior
```

### 🔧 **Heap Sort Otimizado**
```python
def heap_sort_optimized(arr):
    n = len(arr)
    
    # Build heap otimizado
    for i in range(n // 2 - 1, -1, -1):
        heapify_iterative(arr, n, i)
    
    # Extract elementos
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify_iterative(arr, i, 0)
```

## 🎯 Variações

### 📉 **Min-Heap Sort**
```python
def min_heap_sort(arr):
    n = len(arr)
    
    # Build min-heap
    for i in range(n // 2 - 1, -1, -1):
        min_heapify(arr, n, i)
    
    # Extract elementos (ordem decrescente)
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        min_heapify(arr, i, 0)

def min_heapify(arr, n, i):
    menor = i
    esquerdo = 2 * i + 1
    direito = 2 * i + 2
    
    if esquerdo < n and arr[esquerdo] < arr[menor]:
        menor = esquerdo
    
    if direito < n and arr[direito] < arr[menor]:
        menor = direito
    
    if menor != i:
        arr[i], arr[menor] = arr[menor], arr[i]
        min_heapify(arr, n, menor)
```

### 🎯 **Partial Heap Sort**
```python
def partial_heap_sort(arr, k):
    """Ordena apenas os k maiores elementos"""
    n = len(arr)
    
    # Build max-heap
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # Extrai apenas k elementos
    for i in range(n - 1, n - k - 1, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
    
    return arr[n-k:]  # Retorna k maiores
```

## 💡 Dicas de Implementação

### 🎯 **Pontos-Chave**
- **📊 Use max-heap**: Para ordenação crescente
- **🔄 Heapify bottom-up**: Mais eficiente
- **⚡ Evite recursão**: Use versão iterativa
- **📏 Controle índices**: Evite out-of-bounds

### 🔧 **Otimizações**
- **📊 Early termination**: Se array já ordenado
- **🔄 Reduce swaps**: Otimize heapify
- **⚡ Cache-friendly**: Para arrays grandes
- **📏 Memory-efficient**: Minimize alocações

### 🎯 **Casos Especiais**
- **📊 Array vazio**: Trate adequadamente
- **🔄 Array unitário**: Caso base
- **⚡ Elementos iguais**: Mantenha ordem relativa
- **📏 Arrays grandes**: Considere cache locality 