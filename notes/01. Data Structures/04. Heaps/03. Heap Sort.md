# ğŸ“Š Heap Sort

## ğŸ¯ O que Ã© Heap Sort?

**Heap Sort** Ã© um algoritmo de ordenaÃ§Ã£o baseado na estrutura de dados **heap**. Ele usa a propriedade de que a raiz de uma heap sempre contÃ©m o maior (max-heap) ou menor (min-heap) elemento.

### ğŸŒŸ **Conceito Central**
```
1. ConstrÃ³i uma heap a partir do array
2. Remove elementos da raiz um por um
3. Coloca na posiÃ§Ã£o correta do array ordenado
```

## ğŸ”„ Algoritmo

### ğŸ“Š **Processo em Duas Fases**
1. **ğŸ—ï¸ Build Heap**: Converte array em max-heap
2. **ğŸ”„ Extract & Place**: Remove raiz e coloca no final

### ğŸ“ **ImplementaÃ§Ã£o**
```python
def heap_sort(arr):
    n = len(arr)
    
    # Fase 1: ConstrÃ³i max-heap
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # Fase 2: Extrai elementos um por um
    for i in range(n - 1, 0, -1):
        # Troca raiz (maior) com Ãºltimo elemento
        arr[0], arr[i] = arr[i], arr[0]
        
        # Heapify na subÃ¡rvore reduzida
        heapify(arr, i, 0)

def heapify(arr, n, i):
    maior = i
    esquerdo = 2 * i + 1
    direito = 2 * i + 2
    
    # Encontra o maior entre pai e filhos
    if esquerdo < n and arr[esquerdo] > arr[maior]:
        maior = esquerdo
    
    if direito < n and arr[direito] > arr[maior]:
        maior = direito
    
    # Se maior nÃ£o Ã© a raiz, troca e heapify
    if maior != i:
        arr[i], arr[maior] = arr[maior], arr[i]
        heapify(arr, n, maior)
```

## ğŸ¯ Exemplo Visual

### ğŸ“Š **Array Original**: [12, 11, 13, 5, 6, 7]

### ğŸ—ï¸ **Fase 1: Build Max-Heap**
```
Passo 1: [12, 11, 13, 5, 6, 7]
Passo 2: [12, 11, 13, 5, 6, 7]
Passo 3: [13, 11, 12, 5, 6, 7]
Passo 4: [13, 11, 12, 5, 6, 7]
```

### ğŸ”„ **Fase 2: Extract & Place**
```
Passo 1: [7, 11, 12, 5, 6, 13]  # 13 vai para o final
Passo 2: [12, 11, 7, 5, 6, 13]  # Heapify
Passo 3: [6, 11, 7, 5, 12, 13]  # 12 vai para o final
Passo 4: [11, 6, 7, 5, 12, 13]  # Heapify
Passo 5: [5, 6, 7, 11, 12, 13]  # Continua...
```

## âš¡ AnÃ¡lise de Complexidade

### ğŸ“ˆ **Complexidade de Tempo**
| Fase | Complexidade | ExplicaÃ§Ã£o |
|------|--------------|------------|
| **ğŸ—ï¸ Build Heap** | O(n) | Heapify bottom-up |
| **ğŸ”„ Extract & Place** | O(n log n) | n extraÃ§Ãµes Ã— log n |
| **ğŸ“Š Total** | O(n log n) | Dominado pela segunda fase |

### ğŸ’¾ **Complexidade de EspaÃ§o**
- **ğŸ”„ In-place**: O(1) espaÃ§o extra
- **ğŸ“Š RecursÃ£o**: O(log n) pilha de recursÃ£o
- **âš¡ Iterativo**: O(1) espaÃ§o total

### ğŸ” **Por que O(n log n)?**
- **ğŸ“Š n extraÃ§Ãµes**: Uma para cada elemento
- **ğŸ”„ log n por extraÃ§Ã£o**: Altura da heap
- **âš¡ Total**: n Ã— log n = O(n log n)

## âœ… Vantagens vs âŒ Desvantagens

| Aspecto | âœ… Vantagem | âŒ Desvantagem |
|---------|-------------|----------------|
| **ğŸ’¾ EspaÃ§o** | In-place O(1) | NÃ£o Ã© estÃ¡vel |
| **âš¡ Performance** | O(n log n) garantido | Pior que quicksort na prÃ¡tica |
| **ğŸ”„ ConsistÃªncia** | Sempre O(n log n) | NÃ£o adaptativo |
| **ğŸ“Š Cache** | NÃ£o cache-friendly | Muitos swaps |

## ğŸ¯ ComparaÃ§Ã£o com Outros Algoritmos

| Algoritmo | Melhor | MÃ©dio | Pior | EspaÃ§o | EstÃ¡vel |
|-----------|--------|-------|------|--------|---------|
| **ğŸ“Š Heap Sort** | O(n log n) | O(n log n) | O(n log n) | O(1) | âŒ |
| **ğŸ”„ Quick Sort** | O(n log n) | O(n log n) | O(nÂ²) | O(log n) | âŒ |
| **ğŸ“ˆ Merge Sort** | O(n log n) | O(n log n) | O(n log n) | O(n) | âœ… |
| **ğŸ”„ Bubble Sort** | O(n) | O(nÂ²) | O(nÂ²) | O(1) | âœ… |

## ğŸ”§ OtimizaÃ§Ãµes

### âš¡ **Heapify Iterativo**
```python
def heapify_iterative(arr, n, i):
    while True:
        maior = i
        esquerdo = 2 * i + 1
        direito = 2 * i + 2
        
        if esquerdo < n and arr[esquerdo] > arr[maior]:
            maior = esquerdo
        
        if direito < n and arr[direito] > arr[maior]:
            maior = direito
        
        if maior == i:
            break
        
        arr[i], arr[maior] = arr[maior], arr[i]
        i = maior
```

### ğŸ”§ **Heap Sort Otimizado**
```python
def heap_sort_optimized(arr):
    n = len(arr)
    
    # Build heap otimizado
    for i in range(n // 2 - 1, -1, -1):
        heapify_iterative(arr, n, i)
    
    # Extract elementos
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify_iterative(arr, i, 0)
```

## ğŸ¯ VariaÃ§Ãµes

### ğŸ“‰ **Min-Heap Sort**
```python
def min_heap_sort(arr):
    n = len(arr)
    
    # Build min-heap
    for i in range(n // 2 - 1, -1, -1):
        min_heapify(arr, n, i)
    
    # Extract elementos (ordem decrescente)
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        min_heapify(arr, i, 0)

def min_heapify(arr, n, i):
    menor = i
    esquerdo = 2 * i + 1
    direito = 2 * i + 2
    
    if esquerdo < n and arr[esquerdo] < arr[menor]:
        menor = esquerdo
    
    if direito < n and arr[direito] < arr[menor]:
        menor = direito
    
    if menor != i:
        arr[i], arr[menor] = arr[menor], arr[i]
        min_heapify(arr, n, menor)
```

### ğŸ¯ **Partial Heap Sort**
```python
def partial_heap_sort(arr, k):
    """Ordena apenas os k maiores elementos"""
    n = len(arr)
    
    # Build max-heap
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # Extrai apenas k elementos
    for i in range(n - 1, n - k - 1, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
    
    return arr[n-k:]  # Retorna k maiores
```

## ğŸ’¡ Dicas de ImplementaÃ§Ã£o

### ğŸ¯ **Pontos-Chave**
- **ğŸ“Š Use max-heap**: Para ordenaÃ§Ã£o crescente
- **ğŸ”„ Heapify bottom-up**: Mais eficiente
- **âš¡ Evite recursÃ£o**: Use versÃ£o iterativa
- **ğŸ“ Controle Ã­ndices**: Evite out-of-bounds

### ğŸ”§ **OtimizaÃ§Ãµes**
- **ğŸ“Š Early termination**: Se array jÃ¡ ordenado
- **ğŸ”„ Reduce swaps**: Otimize heapify
- **âš¡ Cache-friendly**: Para arrays grandes
- **ğŸ“ Memory-efficient**: Minimize alocaÃ§Ãµes

### ğŸ¯ **Casos Especiais**
- **ğŸ“Š Array vazio**: Trate adequadamente
- **ğŸ”„ Array unitÃ¡rio**: Caso base
- **âš¡ Elementos iguais**: Mantenha ordem relativa
- **ğŸ“ Arrays grandes**: Considere cache locality 