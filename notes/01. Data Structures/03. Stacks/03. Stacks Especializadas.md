# 🎨 Stacks Especializadas

## 🎯 Visão Geral

Stacks especializadas estendem a funcionalidade básica para resolver problemas específicos. As mais comuns são **Min Stack**, **Max Stack** e suas variações, que permitem acesso O(1) aos extremos.

## 📉 Min Stack

### 🌟 **O que é?**
**Min Stack** é uma pilha que permite obter o **menor elemento** em tempo O(1), mantendo todas as operações básicas de stack.

### 📝 **Implementação com Stack Auxiliar**
```python
class MinStack:
    def __init__(self):
        self._stack = []      # Stack principal
        self._mins = []       # Stack de mínimos
    
    def push(self, value):
        # Adiciona na stack principal
        self._stack.append(value)
        
        # Atualiza stack de mínimos
        if not self._mins or value <= self._mins[-1]:
            self._mins.append(value)
    
    def pop(self):
        if not self._stack:
            raise IndexError("Stack vazia")
        
        # Remove da stack principal
        value = self._stack.pop()
        
        # Remove da stack de mínimos se necessário
        if value == self._mins[-1]:
            self._mins.pop()
        
        return value
    
    def top(self):
        if not self._stack:
            raise IndexError("Stack vazia")
        return self._stack[-1]
    
    def get_min(self):
        if not self._mins:
            raise IndexError("Stack vazia")
        return self._mins[-1]
```

### 🎯 **Exemplo Visual**
```
Stack: [3, 5, 2, 1, 4]
Mins:  [3, 2, 1]

Push(0): Stack: [3, 5, 2, 1, 4, 0]
         Mins:  [3, 2, 1, 0]

Pop():  Stack: [3, 5, 2, 1, 4]  # Remove 0
        Mins:  [3, 2, 1]        # Remove 0 dos mins

Get_min(): 1 (menor atual)
```

## 📈 Max Stack

### 🌟 **O que é?**
**Max Stack** é similar ao Min Stack, mas mantém o **maior elemento** em O(1).

### 📝 **Implementação**
```python
class MaxStack:
    def __init__(self):
        self._stack = []      # Stack principal
        self._maxs = []       # Stack de máximos
    
    def push(self, value):
        self._stack.append(value)
        
        # Atualiza stack de máximos
        if not self._maxs or value >= self._maxs[-1]:
            self._maxs.append(value)
    
    def pop(self):
        if not self._stack:
            raise IndexError("Stack vazia")
        
        value = self._stack.pop()
        
        # Remove da stack de máximos se necessário
        if value == self._maxs[-1]:
            self._maxs.pop()
        
        return value
    
    def get_max(self):
        if not self._maxs:
            raise IndexError("Stack vazia")
        return self._maxs[-1]
```

## 📊 Min-Max Stack

### 🌟 **O que é?**
**Min-Max Stack** combina as funcionalidades de Min e Max Stack, permitindo acesso O(1) a ambos os extremos.

### 📝 **Implementação**
```python
class MinMaxStack:
    def __init__(self):
        self._stack = []      # Stack principal
        self._mins = []       # Stack de mínimos
        self._maxs = []       # Stack de máximos
    
    def push(self, value):
        self._stack.append(value)
        
        # Atualiza stack de mínimos
        if not self._mins or value <= self._mins[-1]:
            self._mins.append(value)
        
        # Atualiza stack de máximos
        if not self._maxs or value >= self._maxs[-1]:
            self._maxs.append(value)
    
    def pop(self):
        if not self._stack:
            raise IndexError("Stack vazia")
        
        value = self._stack.pop()
        
        # Remove das stacks auxiliares se necessário
        if value == self._mins[-1]:
            self._mins.pop()
        
        if value == self._maxs[-1]:
            self._maxs.pop()
        
        return value
    
    def get_min(self):
        if not self._mins:
            raise IndexError("Stack vazia")
        return self._mins[-1]
    
    def get_max(self):
        if not self._maxs:
            raise IndexError("Stack vazia")
        return self._maxs[-1]
```

### 🎯 **Vantagens**
- **⚡ O(1)**: Todas as operações
- **📊 Completo**: Min e max simultaneamente
- **🔄 Simples**: Fácil de implementar
- **💾 Eficiente**: Pouco overhead

## 🔗 Pair Stack

### 🌟 **O que é?**
**Pair Stack** armazena pares de valores, útil para problemas que precisam manter informações relacionadas.

### 📝 **Implementação**
```python
class PairStack:
    def __init__(self):
        self._data = []  # Lista de tuplas
    
    def push(self, pair):
        if not isinstance(pair, tuple) or len(pair) != 2:
            raise ValueError("Deve ser um par (tuple de 2 elementos)")
        
        self._data.append(pair)
    
    def pop(self):
        if self.is_empty():
            raise IndexError("Stack vazia")
        return self._data.pop()
    
    def top(self):
        if self.is_empty():
            raise IndexError("Stack vazia")
        return self._data[-1]
    
    def is_empty(self):
        return len(self._data) == 0
    
    def size(self):
        return len(self._data)
```

### 🎯 **Aplicações**
- **📊 Coordenadas**: (x, y) para gráficos
- **🔄 Estados**: (valor, índice) para algoritmos
- **📈 Estatísticas**: (média, contador)
- **🎯 Problemas**: (soma, elemento) para otimizações

## ⚡ Implementações Otimizadas

### 🔧 **Min Stack com Valor Único**
```python
class MinStackOptimized:
    def __init__(self):
        self._stack = []
        self._min = None
    
    def push(self, value):
        if self._min is None or value <= self._min:
            # Guarda o mínimo anterior
            self._stack.append(self._min)
            self._min = value
        
        self._stack.append(value)
    
    def pop(self):
        if not self._stack:
            raise IndexError("Stack vazia")
        
        value = self._stack.pop()
        
        if value == self._min:
            # Restaura o mínimo anterior
            self._min = self._stack.pop()
        
        return value
    
    def get_min(self):
        return self._min
```

### 🔧 **Min Stack com Contagem**
```python
class MinStackWithCount:
    def __init__(self):
        self._stack = []
        self._mins = []  # (valor, contagem)
    
    def push(self, value):
        self._stack.append(value)
        
        if not self._mins or value < self._mins[-1][0]:
            self._mins.append((value, 1))
        elif value == self._mins[-1][0]:
            self._mins[-1] = (value, self._mins[-1][1] + 1)
    
    def pop(self):
        if not self._stack:
            raise IndexError("Stack vazia")
        
        value = self._stack.pop()
        
        if value == self._mins[-1][0]:
            if self._mins[-1][1] == 1:
                self._mins.pop()
            else:
                self._mins[-1] = (value, self._mins[-1][1] - 1)
        
        return value
```

## 🎯 Variações Avançadas

### 📊 **Stack com Média**
```python
class AverageStack:
    def __init__(self):
        self._stack = []
        self._sum = 0
        self._count = 0
    
    def push(self, value):
        self._stack.append(value)
        self._sum += value
        self._count += 1
    
    def pop(self):
        if not self._stack:
            raise IndexError("Stack vazia")
        
        value = self._stack.pop()
        self._sum -= value
        self._count -= 1
        return value
    
    def get_average(self):
        if self._count == 0:
            raise IndexError("Stack vazia")
        return self._sum / self._count
```

### 📊 **Stack com Moda**
```python
class ModeStack:
    def __init__(self):
        self._stack = []
        self._freq = {}  # Frequência de cada valor
        self._max_freq = 0
        self._mode = None
    
    def push(self, value):
        self._stack.append(value)
        
        # Atualiza frequência
        self._freq[value] = self._freq.get(value, 0) + 1
        
        # Atualiza moda
        if self._freq[value] > self._max_freq:
            self._max_freq = self._freq[value]
            self._mode = value
    
    def pop(self):
        if not self._stack:
            raise IndexError("Stack vazia")
        
        value = self._stack.pop()
        self._freq[value] -= 1
        
        # Recalcula moda se necessário
        if value == self._mode and self._freq[value] < self._max_freq:
            self._recalculate_mode()
        
        return value
    
    def get_mode(self):
        return self._mode
    
    def _recalculate_mode(self):
        self._max_freq = 0
        self._mode = None
        for value, freq in self._freq.items():
            if freq > self._max_freq:
                self._max_freq = freq
                self._mode = value
```

## 💡 Dicas de Implementação

### 🎯 **Pontos-Chave**
- **📊 Mantenha sincronização**: Entre stack principal e auxiliar
- **🔄 Considere duplicatas**: Como tratar valores iguais
- **⚡ Otimize memória**: Evite redundância desnecessária
- **📏 Valide entrada**: Verifique tipos e valores

### 🔧 **Otimizações**
- **📊 Lazy updates**: Atualize apenas quando necessário
- **🔄 Batch operations**: Para múltiplas inserções
- **⚡ Memory pooling**: Reutilize estruturas
- **📏 Early termination**: Pare quando possível

### 🎯 **Casos Especiais**
- **📊 Stack vazia**: Trate adequadamente
- **🔄 Valores iguais**: Defina política clara
- **⚡ Overflow**: Para stacks com capacidade
- **📏 Underflow**: Para operações de remoção 