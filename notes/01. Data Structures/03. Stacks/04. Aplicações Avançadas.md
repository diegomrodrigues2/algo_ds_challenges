# ğŸ”§ AplicaÃ§Ãµes AvanÃ§adas do Stack

## ğŸ¯ VisÃ£o Geral

Stacks sÃ£o fundamentais para **muitos algoritmos avanÃ§ados** e problemas prÃ¡ticos. Sua propriedade LIFO torna-os ideais para parsing, backtracking e processamento de expressÃµes.

## ğŸ” ValidaÃ§Ã£o de ParÃªnteses

### ğŸŒŸ **Problema**
Verificar se uma string de parÃªnteses estÃ¡ **bem-formada** (balanceada).

### ğŸ“ **ImplementaÃ§Ã£o**
```python
def is_valid_parentheses(expression):
    stack = []
    pairs = {')': '(', '}': '{', ']': '['}
    
    for char in expression:
        if char in '({[':
            # Abre parÃªntese - empilha
            stack.append(char)
        elif char in ')}]':
            # Fecha parÃªntese - verifica correspondÃªncia
            if not stack or stack.pop() != pairs[char]:
                return False
    
    # Verifica se todos foram fechados
    return len(stack) == 0
```

### ğŸ¯ **Exemplo Visual**
```
ExpressÃ£o: "((()))"
Stack: []
Passo 1: "(" â†’ Stack: ['(']
Passo 2: "(" â†’ Stack: ['(', '(']
Passo 3: "(" â†’ Stack: ['(', '(', '(']
Passo 4: ")" â†’ Stack: ['(', '(']
Passo 5: ")" â†’ Stack: ['(']
Passo 6: ")" â†’ Stack: []
Resultado: True (vÃ¡lida)
```

## ğŸ“Š AvaliaÃ§Ã£o de ExpressÃµes PÃ³s-Fixas

### ğŸŒŸ **Problema**
Calcular o resultado de uma expressÃ£o em **notaÃ§Ã£o pÃ³s-fixa** (RPN - Reverse Polish Notation).

### ğŸ“ **ImplementaÃ§Ã£o**
```python
def evaluate_postfix(expression):
    stack = []
    operators = {
        '+': lambda x, y: x + y,
        '-': lambda x, y: x - y,
        '*': lambda x, y: x * y,
        '/': lambda x, y: x // y  # DivisÃ£o inteira
    }
    
    for token in expression.split():
        if token.isdigit():
            # Operando - empilha
            stack.append(int(token))
        elif token in operators:
            # Operador - aplica aos dois Ãºltimos operandos
            if len(stack) < 2:
                raise ValueError("ExpressÃ£o invÃ¡lida")
            
            b = stack.pop()
            a = stack.pop()
            result = operators[token](a, b)
            stack.append(result)
        else:
            raise ValueError(f"Token invÃ¡lido: {token}")
    
    if len(stack) != 1:
        raise ValueError("ExpressÃ£o invÃ¡lida")
    
    return stack[0]
```

### ğŸ¯ **Exemplo**
```
ExpressÃ£o: "3 4 + 2 *"
Stack: []
Passo 1: "3" â†’ Stack: [3]
Passo 2: "4" â†’ Stack: [3, 4]
Passo 3: "+" â†’ Stack: [7] (3+4)
Passo 4: "2" â†’ Stack: [7, 2]
Passo 5: "*" â†’ Stack: [14] (7*2)
Resultado: 14
```

## ğŸ“¦ Equal Stacks

### ğŸŒŸ **Problema**
Equalizar a altura de **trÃªs pilhas** removendo elementos do topo atÃ© que todas tenham a mesma altura.

### ğŸ“ **ImplementaÃ§Ã£o**
```python
def equal_stacks(h1, h2, h3):
    # Calcula alturas cumulativas (da base para o topo)
    def get_cumulative_heights(heights):
        cumulative = [0]
        for height in reversed(heights):
            cumulative.append(cumulative[-1] + height)
        return set(cumulative)
    
    # Encontra alturas comuns
    heights1 = get_cumulative_heights(h1)
    heights2 = get_cumulative_heights(h2)
    heights3 = get_cumulative_heights(h3)
    
    # IntersecÃ§Ã£o das trÃªs alturas
    common_heights = heights1 & heights2 & heights3
    
    if not common_heights:
        return 0
    
    return max(common_heights)
```

### ğŸ¯ **Exemplo**
```
h1: [3, 2, 1, 1, 1] â†’ Alturas: [0, 1, 2, 3, 5, 8]
h2: [4, 3, 2]       â†’ Alturas: [0, 2, 5, 9]
h3: [1, 1, 4, 1]    â†’ Alturas: [0, 1, 2, 6, 7]

Alturas comuns: {0, 1, 2}
Altura mÃ¡xima: 2
```

## ğŸ”„ ConversÃ£o de NotaÃ§Ãµes

### ğŸŒŸ **Infixa para PÃ³s-Fixa**
```python
def infix_to_postfix(expression):
    stack = []
    output = []
    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}
    
    for char in expression:
        if char.isalnum():
            # Operando - adiciona Ã  saÃ­da
            output.append(char)
        elif char == '(':
            # Abre parÃªntese - empilha
            stack.append(char)
        elif char == ')':
            # Fecha parÃªntese - desempilha atÃ© '('
            while stack and stack[-1] != '(':
                output.append(stack.pop())
            if stack:
                stack.pop()  # Remove '('
        elif char in precedence:
            # Operador - desempilha operadores com precedÃªncia maior/igual
            while (stack and stack[-1] != '(' and 
                   precedence.get(stack[-1], 0) >= precedence[char]):
                output.append(stack.pop())
            stack.append(char)
    
    # Desempilha operadores restantes
    while stack:
        output.append(stack.pop())
    
    return ' '.join(output)
```

### ğŸ¯ **Exemplo**
```
Infixa: "3 + 4 * 2"
Stack: []
Output: []
Passo 1: "3" â†’ Output: ['3']
Passo 2: "+" â†’ Stack: ['+'], Output: ['3']
Passo 3: "4" â†’ Output: ['3', '4']
Passo 4: "*" â†’ Stack: ['+', '*'], Output: ['3', '4']
Passo 5: "2" â†’ Output: ['3', '4', '2']
Final: Stack: [], Output: ['3', '4', '2', '*', '+']
PÃ³s-fixa: "3 4 2 * +"
```

## ğŸ¨ Algoritmos de Backtracking

### ğŸŒŸ **N-Queens com Stack**
```python
def solve_n_queens_stack(n):
    stack = [(0, [])]  # (row, queens_positions)
    solutions = []
    
    while stack:
        row, queens = stack.pop()
        
        if row == n:
            # SoluÃ§Ã£o encontrada
            solutions.append(queens)
            continue
        
        for col in range(n):
            if is_safe(queens, row, col):
                new_queens = queens + [(row, col)]
                stack.append((row + 1, new_queens))
    
    return solutions

def is_safe(queens, row, col):
    for q_row, q_col in queens:
        if (q_col == col or 
            q_row + q_col == row + col or 
            q_row - q_col == row - col):
            return False
    return True
```

### ğŸŒŸ **Sudoku Solver com Stack**
```python
def solve_sudoku_stack(board):
    stack = [(0, 0, board)]  # (row, col, board_state)
    
    while stack:
        row, col, current_board = stack.pop()
        
        if row == 9:
            return current_board
        
        if current_board[row][col] != 0:
            # CÃ©lula jÃ¡ preenchida
            next_row, next_col = get_next_cell(row, col)
            stack.append((next_row, next_col, current_board))
            continue
        
        # Tenta nÃºmeros de 1 a 9
        for num in range(1, 10):
            if is_valid_move(current_board, row, col, num):
                new_board = [row[:] for row in current_board]
                new_board[row][col] = num
                next_row, next_col = get_next_cell(row, col)
                stack.append((next_row, next_col, new_board))
    
    return None
```

## ğŸ”§ Monotonic Stack

### ğŸŒŸ **PrÃ³ximo Maior Elemento**
```python
def next_greater_element(nums):
    stack = []
    result = [-1] * len(nums)
    
    for i, num in enumerate(nums):
        # Remove elementos menores do stack
        while stack and nums[stack[-1]] < num:
            result[stack.pop()] = num
        
        stack.append(i)
    
    return result
```

### ğŸ¯ **Exemplo**
```
Array: [4, 5, 2, 10, 8]
Stack: []
Result: [-1, -1, -1, -1, -1]

Passo 1: i=0, num=4 â†’ Stack: [0]
Passo 2: i=1, num=5 â†’ Stack: [1] (remove 0, result[0]=5)
Passo 3: i=2, num=2 â†’ Stack: [1, 2]
Passo 4: i=3, num=10 â†’ Stack: [3] (remove 1,2, result[1,2]=10)
Passo 5: i=4, num=8 â†’ Stack: [3, 4]

Resultado: [5, 10, 10, -1, -1]
```

## ğŸ’¡ Dicas de ImplementaÃ§Ã£o

### ğŸ¯ **Pontos-Chave**
- **ğŸ“Š Sempre verifique vazia**: Antes de pop
- **ğŸ”„ Mantenha invariantes**: Propriedades da stack
- **âš¡ Otimize operaÃ§Ãµes**: Evite recÃ¡lculos
- **ğŸ“ Controle memÃ³ria**: Para problemas grandes

### ğŸ”§ **OtimizaÃ§Ãµes**
- **ğŸ“Š Early termination**: Pare quando possÃ­vel
- **ğŸ”„ Lazy evaluation**: Calcule apenas quando necessÃ¡rio
- **âš¡ Memory pooling**: Reutilize estruturas
- **ğŸ“ Batch processing**: Para mÃºltiplas operaÃ§Ãµes

### ğŸ¯ **Casos Especiais**
- **ğŸ“Š ExpressÃµes vazias**: Trate adequadamente
- **ğŸ”„ ParÃªnteses desbalanceados**: Detecte erros
- **âš¡ Overflow/Underflow**: Para stacks fixas
- **ğŸ“ Caracteres invÃ¡lidos**: Valide entrada 