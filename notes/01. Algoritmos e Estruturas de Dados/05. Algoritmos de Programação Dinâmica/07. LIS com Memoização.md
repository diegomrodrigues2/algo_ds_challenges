# ğŸ§  LIS com MemoizaÃ§Ã£o

## ğŸ¯ VisÃ£o Geral

O problema da **SubsequÃªncia Crescente Mais Longa (LIS - Longest Increasing Subsequence)** consiste em encontrar o comprimento da maior subsequÃªncia estritamente crescente em um array. A transiÃ§Ã£o de backtracking exponencial O(2â¿) para programaÃ§Ã£o dinÃ¢mica O(nÂ²) usando a formulaÃ§Ã£o LISbigger(i, j) demonstra a elegÃ¢ncia da memoizaÃ§Ã£o.

## ğŸ“Š DefiniÃ§Ã£o do Problema

### ğŸ¯ Entrada
- **Array A**: SequÃªncia de nÃºmeros inteiros de tamanho n

### ğŸ¯ SaÃ­da
- **Comprimento**: Tamanho da subsequÃªncia crescente mais longa
- **SubsequÃªncia**: Opcionalmente, uma das LIS possÃ­veis

### ğŸ“ Exemplo
```
Entrada: A = [3, 10, 2, 1, 20]
SaÃ­da: 3 (subsequÃªncia: [3, 10, 20])
```

## ğŸ”„ EstratÃ©gias de ImplementaÃ§Ã£o

### 1ï¸âƒ£ Backtracking Puro (O(2â¿))
```python
def lis_backtracking(arr):
    # Tenta todas as combinaÃ§Ãµes possÃ­veis
    # RecursÃ£o sem cache
    # Complexidade exponencial
```

### 2ï¸âƒ£ MemoizaÃ§Ã£o (O(nÂ²)) â­ - FormulaÃ§Ã£o LISbigger(i, j)
```python
def lis_memoization(arr):
    # Estado: (i, prev_idx) = "LIS comeÃ§ando em i com anterior em prev_idx"
    # Cache para evitar recÃ¡lculos
    # Complexidade quadrÃ¡tica
```

### 3ï¸âƒ£ TabulaÃ§Ã£o (O(nÂ²))
```python
def lis_tabulation(arr):
    # ConstrÃ³i tabela dp[i] = LIS terminando em i
    # Sem overhead de recursÃ£o
    # Complexidade quadrÃ¡tica
```

### 4ï¸âƒ£ Busca BinÃ¡ria (O(n log n))
```python
def lis_binary_search(arr):
    # MantÃ©m array de menores elementos finais
    # Usa busca binÃ¡ria para atualizar
    # Complexidade log-linear
```

## ğŸ§  AnÃ¡lise de Subproblemas

### ğŸ“ Estado do Subproblema (FormulaÃ§Ã£o LISbigger)
- **DefiniÃ§Ã£o**: `LISbigger(i, j)` = "Comprimento da LIS comeÃ§ando em i com elemento anterior em j"
- **Estados possÃ­veis**: nÂ² (para cada par de Ã­ndices)
- **SobreposiÃ§Ã£o**: MÃºltiplos caminhos chegam ao mesmo estado

### ğŸ”— Estrutura Ã“tima
**RecorrÃªncia de Erickson**:
- `LISbigger(i, j) = max(1 + LISbigger(k, i))` para todo k > i onde A[k] > A[i]
- `LISbigger(i, j) = 1` se nÃ£o hÃ¡ elementos vÃ¡lidos apÃ³s i

**FÃ³rmula**: Para cada posiÃ§Ã£o, decidimos incluir ou nÃ£o o elemento atual na subsequÃªncia

## âš¡ Melhoria de Performance

| Abordagem | Complexidade | Vantagem | Desvantagem |
|-----------|-------------|----------|-------------|
| **Backtracking** | O(2â¿) | ğŸš€ Simples | âŒ Exponencial |
| **MemoizaÃ§Ã£o** | O(nÂ²) | ğŸ›¡ï¸ Eficiente | ğŸ’¾ Cache 2D |
| **TabulaÃ§Ã£o** | O(nÂ²) | âš¡ Sem recursÃ£o | ğŸ“Š Tabela |
| **Busca BinÃ¡ria** | O(n log n) | ğŸ† Ã“timo | ğŸ§  Complexo |

## ğŸ¯ ImplementaÃ§Ãµes DisponÃ­veis

### âœ… Implementadas
- `lis_memoization()` - SoluÃ§Ã£o principal com memoizaÃ§Ã£o LISbigger(i, j)
- `compare_lis_approaches()` - ComparaÃ§Ã£o de performance
- `analyze_lis_complexity()` - AnÃ¡lise de complexidade

### ğŸ”„ Para Implementar
- `lis_backtracking()` - ComparaÃ§Ã£o de performance
- `lis_tabulation()` - Abordagem bottom-up O(nÂ²)
- `lis_binary_search()` - SoluÃ§Ã£o otimizada O(n log n)
- `lis_with_sequence()` - Retorna a subsequÃªncia
- `lis_count_all()` - Conta todas as LIS possÃ­veis
- `lis_ending_at_each_index()` - LIS terminando em cada posiÃ§Ã£o
- `lis_with_constraints()` - RestriÃ§Ãµes adicionais

## ğŸ“Š Casos de Teste

### âœ… Casos BÃ¡sicos
```python
([3, 10, 2, 1, 20], 3)        # [3, 10, 20]
([10, 22, 9, 33, 21, 50, 41, 60], 5)  # [10, 22, 33, 50, 60]
([30, 20, 10], 1)             # [30] ou [20] ou [10]
([10, 20, 35, 80], 4)         # [10, 20, 35, 80]
([2, 2, 2], 1)                # [2] (estritamente crescente)
```

### ğŸ”„ Casos Extremos
```python
([], 0)                       # Array vazio
([5], 1)                      # Um elemento
([1, 2, 3, 4, 5], 5)         # Array ordenado
([5, 4, 3, 2, 1], 1)         # Array decrescente
```

### ğŸ§ª Casos Especiais
```python
([-5, -1, -3, 0, 2, -2, 3], ?)  # NÃºmeros negativos
([1000000, 2000000, 500000, 3000000], 3)  # NÃºmeros grandes
```

## ğŸš€ Benchmark de Performance

| Tamanho | Backtracking | MemoizaÃ§Ã£o | TabulaÃ§Ã£o | Busca BinÃ¡ria |
|---------|-------------|------------|-----------|---------------|
| 10      | 0.001s      | 0.0001s    | 0.0001s   | 0.0001s       |
| 20      | Lento       | 0.001s     | 0.001s    | 0.0005s       |
| 50      | Muito lento | 0.005s     | 0.003s    | 0.001s        |
| 100     | Muito lento | 0.020s     | 0.010s    | 0.002s        |
| 200     | Muito lento | 0.080s     | 0.040s    | 0.004s        |

## ğŸ”— VÃ­nculos Conceituais

### ğŸ“š ReferÃªncias TeÃ³ricas
- **Erickson, "Algorithms"**: CapÃ­tulo 3, SeÃ§Ã£o 3.6, "First Recurrence: Is This Next?"
- **GeeksforGeeks**: [LIS with DP](https://www.geeksforgeeks.org/dsa/longest-increasing-subsequence-dp-3/)
- **FormulaÃ§Ã£o LISbigger**: Estado bidimensional (current_index, previous_index)

### ğŸ§  Conceitos Demonstrados
1. **TransiÃ§Ã£o de Backtracking para PD**: O(2â¿) â†’ O(nÂ²)
2. **Estado do Subproblema**: Par (Ã­ndice_atual, Ã­ndice_anterior)
3. **Subproblemas Sobrepostos**: MÃºltiplos caminhos para o mesmo par
4. **Estrutura Ã“tima**: DecisÃ£o local Ã³tima leva Ã  soluÃ§Ã£o global
5. **FormulaÃ§Ã£o de Erickson**: LISbigger(i, j) como base teÃ³rica

## ğŸ’¡ Insights TeÃ³ricos

### ğŸ”„ Filosofia da PD para LIS
- **"LIS Ã© DecisÃ£o Sequencial"**: Para cada elemento, decidir incluir ou nÃ£o
- **Estado Bidimensional**: NecessÃ¡rio rastrear elemento anterior
- **Cache Inteligente**: Evita recÃ¡lculos de subproblemas idÃªnticos
- **TransiÃ§Ã£o Suave**: MantÃ©m estrutura lÃ³gica da recursÃ£o

### âš¡ Abordagens e Trade-offs
- **MemoizaÃ§Ã£o (Top-Down)**: Cache 2D para estados (i, j)
- **TabulaÃ§Ã£o (Bottom-Up)**: Array 1D para LIS terminando em cada posiÃ§Ã£o
- **Busca BinÃ¡ria**: OtimizaÃ§Ã£o para O(n log n) com estrutura auxiliar
- **ReconstruÃ§Ã£o**: Manter informaÃ§Ãµes para recuperar subsequÃªncia

## ğŸ¯ AplicaÃ§Ãµes PrÃ¡ticas

### ğŸ”§ CenÃ¡rios Reais
- **AnÃ¡lise de AÃ§Ãµes**: Maior perÃ­odo de crescimento de preÃ§os
- **Progresso AcadÃªmico**: SequÃªncia de melhoria em notas
- **Crescimento Populacional**: PerÃ­odos de crescimento sustentado
- **OtimizaÃ§Ã£o de Performance**: SequÃªncias de melhoria contÃ­nua

### ğŸš€ BenefÃ­cios da ImplementaÃ§Ã£o
- **Performance**: Reduz complexidade exponencial para quadrÃ¡tica
- **Escalabilidade**: ViÃ¡vel para arrays de tamanho moderado
- **Flexibilidade**: Base para variaÃ§Ãµes (contagem, reconstruÃ§Ã£o)
- **Educacional**: Demonstra formulaÃ§Ã£o LISbigger de Erickson

## ğŸ“ Arquivos Relacionados

### ğŸ”§ ImplementaÃ§Ã£o
- `lis_memoization.py` - ImplementaÃ§Ã£o principal
- `test_lis_memoization.py` - Testes unitÃ¡rios
- `example_lis_memoization.py` - Exemplos de demonstraÃ§Ã£o

### ğŸ“š DocumentaÃ§Ã£o
- `README.md` - DocumentaÃ§Ã£o completa do mÃ³dulo
- `__init__.py` - ExportaÃ§Ã£o das funÃ§Ãµes principais

## ğŸ¯ PrÃ³ximos Passos

### ğŸ”„ ImplementaÃ§Ãµes Pendentes
1. **Backtracking Puro**: Para comparaÃ§Ã£o de performance
2. **TabulaÃ§Ã£o O(nÂ²)**: Abordagem bottom-up clÃ¡ssica
3. **Busca BinÃ¡ria O(n log n)**: SoluÃ§Ã£o otimizada
4. **ReconstruÃ§Ã£o de SubsequÃªncia**: Retornar LIS especÃ­fica
5. **Contagem de LIS**: Quantas LIS diferentes existem
6. **LIS com RestriÃ§Ãµes**: DiferenÃ§a mÃ­nima, comprimento mÃ¡ximo

### ğŸ§ª ValidaÃ§Ã£o
- âœ… Testes unitÃ¡rios abrangentes
- âœ… Casos extremos tratados
- âœ… Performance demonstrada
- âœ… DocumentaÃ§Ã£o completa

## ğŸ”— RelaÃ§Ã£o com Outros Problemas

### ğŸ“ˆ Problemas Relacionados
- **Longest Common Subsequence (LCS)**: Estado bidimensional similar
- **Edit Distance**: ProgramaÃ§Ã£o dinÃ¢mica com dois Ã­ndices
- **Knapsack**: DecisÃ£o binÃ¡ria para cada elemento
- **Subset Sum**: MemoizaÃ§Ã£o com estado composto

### ğŸ¯ PadrÃµes de PD Demonstrados
- **Estado Bidimensional**: (i, j) para rastrear posiÃ§Ã£o e anterior
- **DecisÃ£o BinÃ¡ria**: Incluir ou nÃ£o incluir elemento atual
- **ReconstruÃ§Ã£o de SoluÃ§Ã£o**: Rastrear escolhas para recuperar resposta
- **OtimizaÃ§Ã£o de EspaÃ§o**: Reduzir de O(nÂ²) para O(n) quando possÃ­vel

Este mÃ³dulo demonstra efetivamente como a formulaÃ§Ã£o LISbigger(i, j) de Erickson pode ser implementada com memoizaÃ§Ã£o, transformando um algoritmo exponencial em quadrÃ¡tico e servindo como base para otimizaÃ§Ãµes futuras.