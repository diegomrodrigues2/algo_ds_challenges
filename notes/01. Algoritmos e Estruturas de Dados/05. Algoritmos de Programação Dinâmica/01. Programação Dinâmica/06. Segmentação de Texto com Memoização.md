# ğŸ§  SegmentaÃ§Ã£o de Texto com MemoizaÃ§Ã£o

## ğŸ¯ VisÃ£o Geral

O problema de **SegmentaÃ§Ã£o de Texto (Word Break)** consiste em determinar se uma string sem espaÃ§os pode ser segmentada em uma sequÃªncia de palavras vÃ¡lidas usando um dicionÃ¡rio. A transiÃ§Ã£o de backtracking exponencial O(2â¿) para programaÃ§Ã£o dinÃ¢mica O(nÂ²) demonstra a essÃªncia da PD.

## ğŸ“Š DefiniÃ§Ã£o do Problema

### ğŸ¯ Entrada
- **String S**: Texto sem espaÃ§os de comprimento n
- **DicionÃ¡rio D**: Conjunto de palavras vÃ¡lidas

### ğŸ¯ SaÃ­da
- **SegmentaÃ§Ã£o vÃ¡lida**: Lista [wâ‚, wâ‚‚, ..., wâ‚–] onde S = wâ‚ + wâ‚‚ + ... + wâ‚–
- **None**: Se nÃ£o existir segmentaÃ§Ã£o vÃ¡lida

### ğŸ“ Exemplo
```
Entrada: S = "ilikegfg", D = {"i", "like", "gfg"}
SaÃ­da: ["i", "like", "gfg"]
```

## ğŸ”„ EstratÃ©gias de ImplementaÃ§Ã£o

### 1ï¸âƒ£ wordbreak_memo (Lilian Weng) â­
```python
def wordbreak_memo(text: str, dictionary: Set[str]) -> Optional[List[str]]:
    """
    ImplementaÃ§Ã£o direta da soluÃ§Ã£o recursiva com dicionÃ¡rio para memoizaÃ§Ã£o.
    Baseada em: https://github.com/lilianweng/LeetcodePython/blob/master/word_break.py
    """
    memo = {}
    
    def can_break(s: str) -> Optional[List[str]]:
        if s in memo:
            return memo[s]
        
        if s == "":
            return []
        
        for i in range(1, len(s) + 1):
            prefix = s[:i]
            if prefix in dictionary:
                suffix_result = can_break(s[i:])
                if suffix_result is not None:
                    result = [prefix] + suffix_result
                    memo[s] = result
                    return result
        
        memo[s] = None
        return None
    
    return can_break(text)
```

### 2ï¸âƒ£ HashMap Approach (Tutorial Horizon) â­
```python
def wordbreak_hashmap(text: str, dictionary: Set[str]) -> Optional[List[str]]:
    """
    Usa HashMap para armazenar resultados de substrings jÃ¡ processadas.
    Baseada em: https://tutorialhorizon.com/algorithms/the-word-break-problem/
    """
    memo = {}
    
    def can_segment(start: int) -> Optional[List[str]]:
        if start in memo:
            return memo[start]
        
        if start == len(text):
            return []
        
        for end in range(start + 1, len(text) + 1):
            word = text[start:end]
            if word in dictionary:
                remaining = can_segment(end)
                if remaining is not None:
                    result = [word] + remaining
                    memo[start] = result
                    return result
        
        memo[start] = None
        return None
    
    return can_segment(0)
```

### 3ï¸âƒ£ Subproblemas Sobrepostos (GeeksforGeeks) â­
```python
def wordbreak_subproblems(text: str, dictionary: Set[str]) -> bool:
    """
    AnÃ¡lise de subproblemas sobrepostos com foco em complexidade.
    Baseada em: https://www.geeksforgeeks.org/dsa/word-break-problem-dp-32/
    """
    n = len(text)
    dp = [False] * (n + 1)
    dp[0] = True  # String vazia Ã© sempre segmentÃ¡vel
    
    for i in range(1, n + 1):
        for j in range(i):
            if dp[j] and text[j:i] in dictionary:
                dp[i] = True
                break
    
    return dp[n]
```

## ğŸ§  AnÃ¡lise de Subproblemas

### ğŸ“ Estado do Subproblema
- **DefiniÃ§Ã£o**: `dp[i]` = "O sufixo text[i..n] pode ser segmentado?"
- **Estados possÃ­veis**: n (um para cada posiÃ§Ã£o inicial)
- **SobreposiÃ§Ã£o**: MÃºltiplos caminhos chegam ao mesmo estado

### ğŸ”— Estrutura Ã“tima
Se `text[i..j]` Ã© palavra vÃ¡lida e `text[j..n]` pode ser segmentado,
entÃ£o `text[i..n]` pode ser segmentado.

**FÃ³rmula**: `dp[i] = OR(dp[j] AND is_word(text[i..j]))` para todo j > i

## âš¡ Melhoria de Performance

| Abordagem | Complexidade | Vantagem | Desvantagem |
|-----------|-------------|----------|-------------|
| **Backtracking** | O(2â¿) | ğŸš€ Simples | âŒ Exponencial |
| **wordbreak_memo** | O(nÂ²) | ğŸ›¡ï¸ String como chave | ğŸ’¾ Cache |
| **HashMap Approach** | O(nÂ²) | âš¡ Ãndice como chave | ğŸ“Š MemÃ³ria |
| **Subproblemas** | O(nÂ²) | ğŸ”„ Bottom-up | ğŸ“ˆ Array |

## ğŸ¯ ImplementaÃ§Ãµes DisponÃ­veis

### âœ… Implementadas
- `wordbreak_memo()` - SoluÃ§Ã£o recursiva com string como chave
- `wordbreak_hashmap()` - SoluÃ§Ã£o recursiva com Ã­ndice como chave  
- `wordbreak_subproblems()` - Abordagem bottom-up com array

### ğŸ”„ Para Implementar
- `text_segmentation_optimized_memoization()` - OrdenaÃ§Ã£o decrescente
- `text_segmentation_with_trie()` - OtimizaÃ§Ã£o com Trie
- `text_segmentation_with_bfs()` - Busca em largura
- `text_segmentation_with_dfs()` - Busca em profundidade
- `text_segmentation_all_solutions()` - Todas as segmentaÃ§Ãµes
- `text_segmentation_count_solutions()` - Contagem de soluÃ§Ãµes
- `text_segmentation_with_constraints()` - RestriÃ§Ãµes adicionais

## ğŸ“Š Casos de Teste

### âœ… Casos BÃ¡sicos
```python
("ilike", {"i", "like", "gfg"}, ["i", "like"])
("ilikegfg", {"i", "like", "gfg"}, ["i", "like", "gfg"])
("ilikemangoes", {"i", "like", "gfg"}, None)
```

### ğŸ”„ Casos com MÃºltiplas SoluÃ§Ãµes
```python
("catsanddog", {"cat", "cats", "and", "sand", "dog"}, ["cat", "sand", "dog"])
```

### âš ï¸ Casos Extremos
```python
("", {"a", "b"}, [])
("a", {"a"}, ["a"])
("a", {"b"}, None)
```

## ğŸš€ Benchmark de Performance

| Tamanho | Backtracking | wordbreak_memo | HashMap | Subproblemas |
|---------|-------------|----------------|---------|--------------|
| 10      | 0.0016s     | 0.0000s        | 0.0000s | 0.0000s      |
| 20      | 0.0000s     | 0.0000s        | 0.0000s | 0.0000s      |
| 30      | Muito lento | 0.0000s        | 0.0000s | 0.0000s      |
| 40      | Muito lento | 0.0000s        | 0.0000s | 0.0000s      |
| 50      | Muito lento | 0.0000s        | 0.0021s | 0.0015s      |

## ğŸ”— VÃ­nculos Conceituais

### ğŸ“š ReferÃªncias TeÃ³ricas
- **Erickson, "Algorithms"**: CapÃ­tulo 3, SeÃ§Ã£o 3.3, "Interpunctio Verborum Redux"
- **Lilian Weng**: [wordbreak_memo](https://github.com/lilianweng/LeetcodePython/blob/master/word_break.py)
- **Tutorial Horizon**: [HashMap Approach](https://tutorialhorizon.com/algorithms/the-word-break-problem/)
- **GeeksforGeeks**: [Subproblemas Sobrepostos](https://www.geeksforgeeks.org/dsa/word-break-problem-dp-32/)

### ğŸ§  Conceitos Demonstrados
1. **TransiÃ§Ã£o de Backtracking para PD**: O(2â¿) â†’ O(nÂ²)
2. **Estado do Subproblema**: Ãndice inicial do sufixo
3. **Subproblemas Sobrepostos**: MÃºltiplos caminhos para o mesmo estado
4. **Estrutura Ã“tima**: DecomposiÃ§Ã£o em subproblemas menores
5. **TÃ©cnicas de OtimizaÃ§Ã£o**: OrdenaÃ§Ã£o de tentativas, cache eficiente

## ğŸ’¡ Insights TeÃ³ricos

### ğŸ”„ Filosofia da PD
- **"PD Ã© RecursÃ£o Inteligente"**: OtimizaÃ§Ã£o de algoritmos recursivos
- **TransiÃ§Ã£o Suave**: MantÃ©m estrutura lÃ³gica da recursÃ£o original
- **Cache Inteligente**: Adiciona cache para evitar recÃ¡lculos
- **IdentificaÃ§Ã£o de Estado**: RepresentaÃ§Ã£o Ãºnica de subproblemas

### âš¡ Abordagens Fundamentais
- **MemoizaÃ§Ã£o (Top-Down)**: Cache de resultados durante recursÃ£o
- **TabelaÃ§Ã£o (Bottom-Up)**: ConstruÃ§Ã£o iterativa da tabela de soluÃ§Ãµes
- **Subestrutura Ã“tima**: Propriedade que permite decomposiÃ§Ã£o
- **SobreposiÃ§Ã£o de Subproblemas**: Justificativa para cache

## ğŸ¯ AplicaÃ§Ãµes PrÃ¡ticas

### ğŸ”§ CenÃ¡rios Reais
- **Processamento de Texto**: SegmentaÃ§Ã£o de texto sem espaÃ§os
- **Compiladores**: AnÃ¡lise lÃ©xica e parsing
- **IA e NLP**: Processamento de linguagem natural
- **Sistemas de Busca**: IndexaÃ§Ã£o e recuperaÃ§Ã£o de texto

### ğŸš€ BenefÃ­cios da ImplementaÃ§Ã£o
- **Performance**: Reduz complexidade exponencial para quadrÃ¡tica
- **Escalabilidade**: ViÃ¡vel para strings de tamanho moderado
- **Flexibilidade**: Suporta diferentes estratÃ©gias de otimizaÃ§Ã£o
- **Educacional**: Demonstra princÃ­pios fundamentais da PD

## ğŸ¯ PrÃ³ximos Passos

### ğŸ”„ ImplementaÃ§Ãµes Pendentes
1. **MemoizaÃ§Ã£o Otimizada**: OrdenaÃ§Ã£o decrescente de tentativas
2. **SoluÃ§Ã£o com Trie**: OtimizaÃ§Ã£o de busca de palavras
3. **BFS/DFS**: Abordagens alternativas de busca
4. **Todas as SoluÃ§Ãµes**: Encontrar mÃºltiplas segmentaÃ§Ãµes
5. **Contagem de SoluÃ§Ãµes**: ProgramaÃ§Ã£o dinÃ¢mica para contagem
6. **RestriÃ§Ãµes**: Adicionar limitaÃ§Ãµes especÃ­ficas

## ğŸ§  AnÃ¡lise de Especialista

### ğŸ“Š Estado do Subproblema
- **DefiniÃ§Ã£o Ãšnica**: `dp[i]` = "O sufixo text[i..n] pode ser segmentado?"
- **Estados Limitados**: Apenas n sufixos possÃ­veis
- **Cache Eficiente**: Array 1D ou dicionÃ¡rio suficiente

### âš¡ Complexidade Justificada
- **Tempo O(nÂ²)**: Para cada estado i, loop interno itera atÃ© n-i vezes
- **IsWord O(k)**: Cada verificaÃ§Ã£o de palavra leva tempo proporcional ao comprimento
- **Total O(nÂ²)**: Soma das iteraÃ§Ãµes para todos os estados

### ğŸ”„ Subproblemas Sobrepostos
- **MÃºltiplos Caminhos**: Diferentes prefixos levam ao mesmo sufixo
- **RecÃ¡lculos Evitados**: Cache elimina trabalho redundante
- **EficiÃªncia Garantida**: Cada subproblema resolvido apenas uma vez

Este mÃ³dulo demonstra efetivamente como a memoizaÃ§Ã£o pode transformar um algoritmo exponencial em um algoritmo polinomial, seguindo exatamente os princÃ­pios descritos por Erickson em "Algorithms". 