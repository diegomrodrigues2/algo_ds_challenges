# ğŸ” DetecÃ§Ã£o de Ciclos com DFS

## ğŸ¯ O que Ã© DetecÃ§Ã£o de Ciclos?

**DetecÃ§Ã£o de ciclos** Ã© o processo de identificar se um grafo contÃ©m **ciclos** (caminhos que voltam ao ponto inicial). DFS Ã© especialmente eficiente para essa tarefa.

### ğŸŒŸ **Conceito Central**
```
Ciclo: A â†’ B â†’ C â†’ A (caminho que retorna ao inÃ­cio)
```

## ğŸ”„ Como DFS Detecta Ciclos

### ğŸ“Š **EstratÃ©gia Fundamental**
DFS detecta ciclos atravÃ©s do **sistema de cores** dos vÃ©rtices:
- **ğŸŸ¢ Branco**: NÃ£o visitado
- **ğŸŸ¡ Cinza**: Em processamento (na pilha de recursÃ£o)
- **âš« Preto**: Processado completamente

### ğŸ¯ **Regra de DetecÃ§Ã£o**
```
Se encontrar um vÃ©rtice CINZA durante a busca â†’ CICLO DETECTADO
```

## ğŸ¨ Sistema de Cores Detalhado

### ğŸ“Š **Estados e TransiÃ§Ãµes**
| Estado | Significado | Quando Ocorre |
|--------|-------------|---------------|
| **ğŸŸ¢ Branco** | NÃ£o visitado | Estado inicial de todos os vÃ©rtices |
| **ğŸŸ¡ Cinza** | Em processamento | VÃ©rtice na pilha de recursÃ£o |
| **âš« Preto** | Processado | VÃ©rtice completamente explorado |

### ğŸ”„ **Fluxo de TransiÃ§Ãµes**
```
ğŸŸ¢ Branco â†’ ğŸŸ¡ Cinza (quando DFS entra no vÃ©rtice)
ğŸŸ¡ Cinza â†’ âš« Preto (quando DFS sai do vÃ©rtice)
```

## ğŸ“ ImplementaÃ§Ã£o BÃ¡sica

### ğŸ” **DetecÃ§Ã£o em Grafos Direcionados**
```python
def has_cycle(grafo):
    cores = {vertice: 'branco' for vertice in grafo}
    
    def dfs_detect_cycle(vertice):
        cores[vertice] = 'cinza'  # Entrando no vÃ©rtice
        
        for vizinho in grafo[vertice]:
            if cores[vizinho] == 'cinza':
                return True  # Ciclo detectado!
            elif cores[vizinho] == 'branco':
                if dfs_detect_cycle(vizinho):
                    return True
        
        cores[vertice] = 'preto'  # Saindo do vÃ©rtice
        return False
    
    # Testa todos os vÃ©rtices (para grafos desconectados)
    for vertice in grafo:
        if cores[vertice] == 'branco':
            if dfs_detect_cycle(vertice):
                return True
    
    return False
```

### ğŸ” **DetecÃ§Ã£o em Grafos NÃ£o-Direcionados**
```python
def has_cycle_undirected(grafo):
    visitados = set()
    
    def dfs_detect_cycle(vertice, pai):
        visitados.add(vertice)
        
        for vizinho in grafo[vertice]:
            if vizinho not in visitados:
                if dfs_detect_cycle(vizinho, vertice):
                    return True
            elif vizinho != pai:  # Evita voltar pelo mesmo caminho
                return True  # Ciclo detectado
        
        return False
    
    for vertice in grafo:
        if vertice not in visitados:
            if dfs_detect_cycle(vertice, None):
                return True
    
    return False
```

## ğŸ“Š Tipos de Ciclos

### ğŸ”„ **Ciclos em Grafos Direcionados**
- **ğŸ”„ Self-loop**: A â†’ A
- **ğŸ”„ Ciclo simples**: A â†’ B â†’ C â†’ A
- **ğŸ”„ Ciclo complexo**: A â†’ B â†’ C â†’ D â†’ B

### ğŸ”„ **Ciclos em Grafos NÃ£o-Direcionados**
- **ğŸ”„ Ciclo simples**: A â€” B â€” C â€” A
- **ğŸ”„ Ciclo com cruzamentos**: A â€” B â€” C â€” D â€” A

## ğŸ¯ AplicaÃ§Ãµes da DetecÃ§Ã£o de Ciclos

### ğŸ“Š **OrdenaÃ§Ã£o TopolÃ³gica**
- **ğŸ¯ Objetivo**: Ordenar vÃ©rtices respeitando dependÃªncias
- **âŒ Problema**: Ciclos impedem ordenaÃ§Ã£o
- **âœ… SoluÃ§Ã£o**: Detectar ciclos primeiro

### ğŸ”§ **Sistemas de Build**
- **ğŸ“¦ DependÃªncias**: A depende de B, B depende de C
- **âŒ Ciclo**: A â†’ B â†’ C â†’ A (impossÃ­vel de resolver)
- **âœ… DetecÃ§Ã£o**: Identificar dependÃªncias circulares

### ğŸ—ï¸ **AnÃ¡lise de DependÃªncias**
- **ğŸ“š Cursos**: PrÃ©-requisitos acadÃªmicos
- **ğŸ’¼ Projetos**: Tarefas que dependem umas das outras
- **ğŸ”— Redes**: ConexÃµes que formam loops

## âš¡ Complexidade e Performance

### ğŸ“ˆ **AnÃ¡lise de Complexidade**
| Aspecto | Complexidade | ExplicaÃ§Ã£o |
|---------|--------------|------------|
| **â° Tempo** | O(V + E) | Visita cada vÃ©rtice e aresta uma vez |
| **ğŸ’¾ EspaÃ§o** | O(V) | Pilha de recursÃ£o + cores |
| **ğŸ§  MemÃ³ria** | O(V) | Para armazenar estados dos vÃ©rtices |

### ğŸ”§ **OtimizaÃ§Ãµes**
- **âš¡ Early termination**: Pare no primeiro ciclo encontrado
- **ğŸ’¾ Union-Find**: Para grafos nÃ£o-direcionados
- **ğŸ“Š Tarjan's algorithm**: Para componentes fortemente conectados

## ğŸ¯ VariaÃ§Ãµes Importantes

### ğŸ” **Contagem de Ciclos**
```python
def count_cycles(grafo):
    cores = {vertice: 'branco' for vertice in grafo}
    ciclos = 0
    
    def dfs_count_cycles(vertice):
        nonlocal ciclos
        cores[vertice] = 'cinza'
        
        for vizinho in grafo[vertice]:
            if cores[vizinho] == 'cinza':
                ciclos += 1
            elif cores[vizinho] == 'branco':
                dfs_count_cycles(vizinho)
        
        cores[vertice] = 'preto'
    
    for vertice in grafo:
        if cores[vertice] == 'branco':
            dfs_count_cycles(vertice)
    
    return ciclos
```

### ğŸ” **Encontrar Ciclos**
```python
def find_cycle(grafo):
    cores = {vertice: 'branco' for vertice in grafo}
    caminho = []
    
    def dfs_find_cycle(vertice):
        cores[vertice] = 'cinza'
        caminho.append(vertice)
        
        for vizinho in grafo[vertice]:
            if cores[vizinho] == 'cinza':
                # Encontrou ciclo, retorna o caminho
                idx = caminho.index(vizinho)
                return caminho[idx:] + [vizinho]
            elif cores[vizinho] == 'branco':
                resultado = dfs_find_cycle(vizinho)
                if resultado:
                    return resultado
        
        cores[vertice] = 'preto'
        caminho.pop()
        return None
    
    for vertice in grafo:
        if cores[vertice] == 'branco':
            ciclo = dfs_find_cycle(vertice)
            if ciclo:
                return ciclo
    
    return None
```

## ğŸ’¡ Dicas de ImplementaÃ§Ã£o

### ğŸ¯ **Pontos-Chave**
- **ğŸ¨ Use cores**: Sistema de 3 estados Ã© fundamental
- **ğŸ”„ Considere direÃ§Ã£o**: Grafos direcionados vs nÃ£o-direcionados
- **âš¡ Early termination**: Pare no primeiro ciclo
- **ğŸ“Š Grafos desconectados**: Teste todos os componentes

### ğŸ”§ **Casos Especiais**
- **ğŸ”„ Self-loops**: Ciclos de tamanho 1
- **ğŸ“Š Grafos vazios**: Sem vÃ©rtices
- **ğŸ”— Grafos desconectados**: MÃºltiplos componentes
- **ğŸ¯ Grafos bipartidos**: Sem ciclos Ã­mpares 