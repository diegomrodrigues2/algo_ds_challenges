# 🔄 Implementações do DFS

## 🎯 Visão Geral

DFS pode ser implementado de **duas formas principais**: **recursiva** (natural) e **iterativa** (com pilha explícita). Ambas produzem o mesmo resultado, mas com características diferentes.

## 🔄 DFS Recursivo

### 🌟 **Características**
- **🔄 Backtracking natural** através da pilha de recursão
- **📝 Código mais simples** e intuitivo
- **💾 Memória automática** gerenciada pelo sistema

### 📊 **Estrutura Básica**
```python
def dfs_recursivo(grafo, inicio):
    visitados = set()
    resultado = []
    
    def dfs_recursivo_aux(vertice):
        if vertice in visitados:
            return
        
        visitados.add(vertice)
        resultado.append(vertice)
        
        for vizinho in grafo[vertice]:
            dfs_recursivo_aux(vizinho)
    
    dfs_recursivo_aux(inicio)
    return resultado
```

### ✅ **Vantagens**
- **🎯 Simplicidade**: Código mais limpo e legível
- **🔄 Natural**: Backtracking acontece automaticamente
- **📝 Menos código**: Menos linhas para implementar

### ❌ **Desvantagens**
- **💥 Stack overflow**: Pode estourar em grafos muito profundos
- **🔧 Debugging**: Mais difícil de debugar
- **⚡ Performance**: Overhead de chamadas de função

## 📊 DFS Iterativo

### 🌟 **Características**
- **📦 Pilha explícita** para controle manual
- **🔧 Mais controle** sobre o processo
- **💾 Memória previsível** e controlável

### 📊 **Estrutura Básica**
```python
def dfs_iterativo(grafo, inicio):
    visitados = set()
    resultado = []
    pilha = [inicio]
    
    while pilha:
        vertice = pilha.pop()
        
        if vertice in visitados:
            continue
            
        visitados.add(vertice)
        resultado.append(vertice)
        
        # Adiciona vizinhos na ordem reversa para manter ordem
        for vizinho in reversed(grafo[vertice]):
            if vizinho not in visitados:
                pilha.append(vizinho)
    
    return resultado
```

### ✅ **Vantagens**
- **💾 Controle de memória**: Evita stack overflow
- **🔧 Debugging**: Mais fácil de debugar e rastrear
- **⚡ Performance**: Menos overhead de função

### ❌ **Desvantagens**
- **📝 Mais código**: Implementação mais verbosa
- **🔄 Menos intuitivo**: Backtracking manual
- **🎯 Complexidade**: Mais fácil de cometer erros

## 📈 Comparação Detalhada

| Aspecto | 🔄 Recursivo | 📊 Iterativo |
|---------|--------------|--------------|
| **📝 Linhas de código** | ~15 | ~20 |
| **🧠 Memória** | Pilha de recursão | Pilha explícita |
| **⚡ Performance** | Mais lento | Mais rápido |
| **🔧 Debugging** | Difícil | Fácil |
| **🎯 Legibilidade** | Alta | Média |
| **💥 Stack overflow** | Possível | Improvável |

## 🎯 Quando Usar Cada Um

### 🔄 **Use Recursivo Quando**
- **📝 Prototipagem rápida**: Para testar ideias
- **🎯 Grafos pequenos**: Profundidade limitada
- **📚 Aprendizado**: Para entender o conceito
- **🔄 Backtracking**: Quando precisa de backtracking natural

### 📊 **Use Iterativo Quando**
- **🏗️ Produção**: Código que vai para produção
- **📊 Grafos grandes**: Profundidade imprevisível
- **🔧 Debugging**: Precisa debugar o processo
- **⚡ Performance**: Otimização é crítica

## 🔧 Variações Importantes

### 🎯 **DFS com Objetivo**
```python
def dfs_com_objetivo(grafo, inicio, objetivo):
    visitados = set()
    
    def dfs_aux(vertice):
        if vertice == objetivo:
            return True
        
        visitados.add(vertice)
        
        for vizinho in grafo[vertice]:
            if vizinho not in visitados:
                if dfs_aux(vizinho):
                    return True
        
        return False
    
    return dfs_aux(inicio)
```

### 📊 **DFS com Caminho**
```python
def dfs_com_caminho(grafo, inicio, objetivo):
    visitados = set()
    caminho = []
    
    def dfs_aux(vertice):
        visitados.add(vertice)
        caminho.append(vertice)
        
        if vertice == objetivo:
            return True
        
        for vizinho in grafo[vertice]:
            if vizinho not in visitados:
                if dfs_aux(vizinho):
                    return True
        
        caminho.pop()  # Backtrack
        return False
    
    dfs_aux(inicio)
    return caminho if objetivo in visitados else []
```

## 💡 Dicas de Implementação

### 🎯 **Pontos-Chave**
- **📊 Sempre controle visitados**: Evite loops infinitos
- **🔄 Considere ordem**: A ordem dos vizinhos importa
- **💾 Otimize memória**: Use sets para visitados
- **⚡ Early termination**: Pare quando encontrar objetivo

### 🔧 **Otimizações**
- **📊 Bidirecional**: Busca de ambos os lados
- **🎯 Heurísticas**: Direcione a busca
- **💾 Memoização**: Cache resultados intermediários
- **🔄 Iterative deepening**: Combine com BFS 