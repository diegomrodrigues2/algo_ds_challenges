# ğŸ¯ Tuple Sort

## ğŸ¯ Conceito Fundamental

### ğŸ“Š OrdenaÃ§Ã£o por MÃºltiplas Chaves
- **EstratÃ©gia**: Ordenar por mÃºltiplas colunas com prioridade
- **Analogia**: Planilha Excel com mÃºltiplas colunas
- **Estabilidade**: Ordem relativa preservada entre itens iguais
- **PriorizaÃ§Ã£o**: Colunas mais importantes tÃªm precedÃªncia

### ğŸ”‘ Premissas
- **Estrutura de Dados**: Tuplas com mÃºltiplos campos
- **Ordem de Prioridade**: DefiniÃ§Ã£o clara de importÃ¢ncia das colunas
- **Algoritmo EstÃ¡vel**: NecessÃ¡rio para preservar trabalho anterior

## âš™ï¸ Algoritmo Detalhado

### ğŸ“ EstratÃ©gia Fundamental
```
TupleSort(tuples, priorities):
    // priorities = [col1, col2, col3, ...] em ordem de importÃ¢ncia
    for i = len(priorities)-1 downto 0:
        column = priorities[i]
        tuples = StableSort(tuples, column)
    return tuples
```

### ğŸ”§ PseudocÃ³digo Completo
```
TupleSort(A, priorities):
    // A = array de tuplas
    // priorities = array com Ã­ndices das colunas em ordem de importÃ¢ncia
    
    for i = len(priorities)-1 downto 0:
        col = priorities[i]
        A = CountingSort(A, col)  // ou qualquer algoritmo estÃ¡vel
    return A

CountingSort(A, column):
    n = length(A)
    max_val = max(A[j][column] for j = 0 to n-1)
    
    count = array[0...max_val] inicializado com 0
    output = array[0...n]
    
    // Contar frequÃªncia
    for j = 0 to n-1:
        val = A[j][column]
        count[val]++
    
    // Acumular
    for i = 1 to max_val:
        count[i] += count[i-1]
    
    // Construir output estÃ¡vel
    for j = n-1 downto 0:
        val = A[j][column]
        output[count[val]-1] = A[j]
        count[val]--
    
    return output
```

## ğŸ“ˆ AnÃ¡lise de Complexidade

### â±ï¸ Tempo de ExecuÃ§Ã£o
| Componente | Tempo | Justificativa |
|------------|-------|---------------|
| **IteraÃ§Ãµes** | O(k) | k = nÃºmero de colunas |
| **Stable Sort** | O(n + u) | counting sort por coluna |
| **Total** | **O(k Ã— (n + u))** | k iteraÃ§Ãµes de stable sort |

### ğŸ’¾ EspaÃ§o
- **Counting Sort**: O(n + u) por iteraÃ§Ã£o
- **ReutilizaÃ§Ã£o**: Mesmo espaÃ§o pode ser reutilizado
- **Total**: **O(n + u)** - espaÃ§o linear

### ğŸ¯ OtimizaÃ§Ãµes
- **Early Termination**: Parar se array jÃ¡ ordenado
- **In-place**: Modificar array original
- **Adaptativo**: Escolher algoritmo baseado no tamanho da coluna

## ğŸ”¬ ImplementaÃ§Ã£o PrÃ¡tica

### ğŸ Python
```python
def tuple_sort(tuples, priorities):
    """
    Ordena tuplas por mÃºltiplas colunas com prioridade
    
    Args:
        tuples: Lista de tuplas
        priorities: Lista de Ã­ndices das colunas em ordem de importÃ¢ncia
    
    Returns:
        Lista ordenada de tuplas
    """
    if not tuples or not priorities:
        return tuples
    
    # Ordenar da coluna menos importante para mais importante
    for col in reversed(priorities):
        tuples = counting_sort_by_column(tuples, col)
    
    return tuples

def counting_sort_by_column(tuples, column):
    """OrdenaÃ§Ã£o estÃ¡vel por coluna especÃ­fica"""
    if not tuples:
        return tuples
    
    n = len(tuples)
    
    # Encontrar mÃ¡ximo na coluna
    max_val = max(tuple_[column] for tuple_ in tuples)
    
    # Contar frequÃªncia
    count = [0] * (max_val + 1)
    for tuple_ in tuples:
        count[tuple_[column]] += 1
    
    # Acumular
    for i in range(1, max_val + 1):
        count[i] += count[i-1]
    
    # Construir output estÃ¡vel
    output = [None] * n
    for i in range(n-1, -1, -1):
        val = tuples[i][column]
        output[count[val]-1] = tuples[i]
        count[val] -= 1
    
    return output

# Exemplo de uso
def example_usage():
    # Dados: (idade, salÃ¡rio, departamento)
    employees = [
        (25, 50000, "TI"),
        (30, 60000, "RH"),
        (25, 55000, "TI"),
        (35, 70000, "TI"),
        (30, 65000, "RH")
    ]
    
    # Prioridade: departamento (2), idade (0), salÃ¡rio (1)
    priorities = [2, 0, 1]
    
    sorted_employees = tuple_sort(employees, priorities)
    return sorted_employees
```

## ğŸ“Š Exemplo Detalhado

### ğŸ”¢ Dados de Entrada
```
Tuplas: [(3,2), (0,3), (4,4), (4,2), (2,2)]
n = 5, base = 5
Prioridades: [1, 0] (coluna 1 mais importante)
```

### ğŸ“ Passo a Passo

#### Passo 1: Ordenar por coluna menos importante (coluna 0)
```
Coluna 0: [3, 0, 4, 4, 2]
Ordenado: [(0,3), (2,2), (3,2), (4,4), (4,2)]
```

#### Passo 2: Ordenar por coluna mais importante (coluna 1)
```
Coluna 1: [3, 2, 2, 4, 2]
Resultado: [(2,2), (3,2), (4,2), (0,3), (4,4)]
```

## ğŸ¯ AplicaÃ§Ãµes PrÃ¡ticas

### âœ… Casos Ideais
- **Planilhas Excel**: OrdenaÃ§Ã£o por mÃºltiplas colunas
- **Bancos de Dados**: ORDER BY mÃºltiplas colunas
- **Sistemas de Arquivos**: OrdenaÃ§Ã£o por nome, data, tamanho
- **AnÃ¡lise de Dados**: EstatÃ­sticas por mÃºltiplos critÃ©rios
- **Radix Sort**: ImplementaÃ§Ã£o usando tuple sort

### âŒ Casos NÃ£o Recomendados
- **Muitas Colunas**: k muito grande (complexidade O(k Ã— n))
- **Colunas Muito Grandes**: u muito grande (espaÃ§o O(u))
- **OrdenaÃ§Ã£o DinÃ¢mica**: Prioridades que mudam frequentemente

## ğŸ”¬ RelaÃ§Ã£o com Radix Sort

### ğŸ“Š Radix Sort como Tuple Sort
```
RadixSort(A, n, u):
    // Decompor nÃºmeros em dÃ­gitos
    tuples = [(a//n, a%n) for a in A]  // base n
    
    // Tuple sort com prioridade: dÃ­gito mais significativo
    priorities = [1, 0]  // coluna 1 (MSD) mais importante
    sorted_tuples = TupleSort(tuples, priorities)
    
    // Reconstruir nÃºmeros
    return [t[0]*n + t[1] for t in sorted_tuples]
```

### ğŸ¯ Vantagens da Abordagem
- **Conceito Unificado**: Radix sort Ã© caso especial de tuple sort
- **Flexibilidade**: Prioridades configurÃ¡veis
- **ReutilizaÃ§Ã£o**: Mesmo algoritmo para diferentes problemas

## ğŸ’¡ Insights TeÃ³ricos

### ğŸš€ Por que Funciona?
- **Estabilidade**: Preserva ordem de iteraÃ§Ãµes anteriores
- **PriorizaÃ§Ã£o**: Colunas mais importantes tÃªm precedÃªncia
- **DecomposiÃ§Ã£o**: Problema complexo â†’ problemas simples

### ğŸ¯ Trade-offs
- **Flexibilidade vs Performance**: Mais colunas = mais tempo
- **Simplicidade vs EficiÃªncia**: Algoritmo simples mas especializado
- **EspaÃ§o vs Tempo**: O(n + u) espaÃ§o para O(k Ã— (n + u)) tempo

### ğŸ”¬ LimitaÃ§Ãµes
- **NÃºmero de Colunas**: k afeta performance linearmente
- **Tamanho das Colunas**: u afeta espaÃ§o linearmente
- **DistribuiÃ§Ã£o**: Performance depende da distribuiÃ§Ã£o dos dados

## ğŸ“Š ComparaÃ§Ã£o com Outros Algoritmos

| Aspecto | Tuple Sort | Merge Sort | Quick Sort |
|---------|------------|------------|------------|
| **Tempo** | O(k Ã— (n + u)) | O(n log n) | O(n log n) |
| **EspaÃ§o** | O(n + u) | O(n) | O(log n) |
| **EstÃ¡vel** | âœ… | âœ… | âŒ |
| **Flexibilidade** | âœ… | âŒ | âŒ |
| **RestriÃ§Ãµes** | Colunas pequenas | Nenhuma | Nenhuma | 