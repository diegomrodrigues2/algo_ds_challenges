# ğŸ”¢ Radix Sort

## ğŸ¯ Conceito Fundamental

### ğŸ“Š OrdenaÃ§Ã£o por DÃ­gitos
- **EstratÃ©gia**: Ordenar nÃºmeros dÃ­gito por dÃ­gito
- **Base**: Usar base n para decomposiÃ§Ã£o eficiente
- **Estabilidade**: Ordem relativa preservada entre itens iguais
- **DecomposiÃ§Ã£o**: Quebrar nÃºmeros grandes em dÃ­gitos menores

### ğŸ”‘ Premissas
- **Chaves Inteiras**: NÃºmeros naturais ou inteiros
- **Faixa Limitada**: u â‰¤ n^c para constante c
- **Acesso AleatÃ³rio**: Modelo de computaÃ§Ã£o com indexaÃ§Ã£o O(1)

## âš™ï¸ Algoritmo Detalhado

### ğŸ“ PseudocÃ³digo
```
RadixSort(A, n, u):
    d = log_n(u)  // nÃºmero de dÃ­gitos
    for i = 0 to d-1:
        A = CountingSort(A, n, i)  // ordenar por dÃ­gito i
    return A

CountingSort(A, n, digit):
    // Ordenar array A pelo dÃ­gito especificado
    count = array[0...n-1] inicializado com 0
    output = array[0...n-1]
    
    // Contar frequÃªncia de cada dÃ­gito
    for j = 0 to n-1:
        d = getDigit(A[j], digit)
        count[d]++
    
    // Acumular contadores
    for i = 1 to n-1:
        count[i] += count[i-1]
    
    // Construir output estÃ¡vel
    for j = n-1 downto 0:
        d = getDigit(A[j], digit)
        output[count[d]-1] = A[j]
        count[d]--
    
    return output
```

### ğŸ”§ FunÃ§Ã£o Auxiliar
```
getDigit(number, position):
    return (number // n^position) % n
```

## ğŸ“ˆ AnÃ¡lise de Complexidade

### â±ï¸ Tempo de ExecuÃ§Ã£o
| Componente | Tempo | Justificativa |
|------------|-------|---------------|
| **DecomposiÃ§Ã£o** | O(n Ã— d) | n nÃºmeros Ã— d dÃ­gitos cada |
| **Counting Sort** | O(n) por dÃ­gito | Algoritmo linear estÃ¡vel |
| **Total** | **O(n Ã— d)** | d iteraÃ§Ãµes de counting sort |

### ğŸ’¾ EspaÃ§o
- **Counting Sort**: O(n) para arrays auxiliares
- **DecomposiÃ§Ã£o**: O(1) por nÃºmero (in-place)
- **Total**: **O(n)** - espaÃ§o linear

### ğŸ¯ Quando Ã© Linear?
- **CondiÃ§Ã£o**: u â‰¤ n^c para constante c
- **Resultado**: d = log_n(u) â‰¤ log_n(n^c) = c
- **Complexidade**: O(n Ã— c) = **O(n)**

## ğŸ”¬ ImplementaÃ§Ã£o PrÃ¡tica

### ğŸ Python
```python
def radix_sort(arr, base=None):
    if not arr:
        return arr
    
    n = len(arr)
    if base is None:
        base = n
    
    # Encontrar mÃ¡ximo para determinar dÃ­gitos
    max_val = max(arr)
    if max_val == 0:
        return arr
    
    # Calcular nÃºmero de dÃ­gitos
    digits = 0
    temp = max_val
    while temp > 0:
        digits += 1
        temp //= base
    
    # Ordenar por cada dÃ­gito
    for digit in range(digits):
        arr = counting_sort_by_digit(arr, base, digit)
    
    return arr

def counting_sort_by_digit(arr, base, digit):
    n = len(arr)
    count = [0] * base
    output = [0] * n
    
    # Contar frequÃªncia
    for num in arr:
        d = (num // (base ** digit)) % base
        count[d] += 1
    
    # Acumular
    for i in range(1, base):
        count[i] += count[i-1]
    
    # Construir output
    for i in range(n-1, -1, -1):
        d = (arr[i] // (base ** digit)) % base
        output[count[d]-1] = arr[i]
        count[d] -= 1
    
    return output
```

### âš¡ OtimizaÃ§Ãµes
- **Base Adaptativa**: Escolher base baseada no tamanho dos dados
- **Early Termination**: Parar quando array jÃ¡ ordenado
- **In-place**: Modificar array original em vez de criar cÃ³pias

## ğŸ“Š Exemplo Detalhado

### ğŸ”¢ Dados de Entrada
```
Array: [170, 45, 75, 90, 802, 24, 2, 66]
n = 8, base = 8, max = 802
dÃ­gitos = log_8(802) â‰ˆ 3
```

### ğŸ“ Passo a Passo

#### Passo 1: Ordenar por dÃ­gito menos significativo (posiÃ§Ã£o 0)
```
DÃ­gitos: [0, 5, 3, 2, 2, 0, 2, 2]
Ordenado: [170, 90, 802, 24, 2, 75, 45, 66]
```

#### Passo 2: Ordenar por dÃ­gito do meio (posiÃ§Ã£o 1)
```
DÃ­gitos: [1, 1, 0, 2, 0, 1, 5, 8]
Ordenado: [802, 2, 24, 45, 66, 170, 75, 90]
```

#### Passo 3: Ordenar por dÃ­gito mais significativo (posiÃ§Ã£o 2)
```
DÃ­gitos: [8, 0, 0, 0, 0, 1, 0, 0]
Resultado: [2, 24, 45, 66, 75, 90, 170, 802]
```

## ğŸ¯ AplicaÃ§Ãµes PrÃ¡ticas

### âœ… Casos Ideais
- **IDs de UsuÃ¡rio**: NÃºmeros sequenciais pequenos
- **Timestamps**: Datas em formato compacto (YYYYMMDD)
- **Cores RGB**: Valores de 0-255 para cada canal
- **Scores**: PontuaÃ§Ãµes em escala limitada
- **Telefones**: NÃºmeros com formato padronizado

### âŒ Casos NÃ£o Recomendados
- **NÃºmeros Muito Grandes**: u exponencial em n
- **Strings**: Sem ordem numÃ©rica natural
- **NÃºmeros Negativos**: Requer tratamento especial
- **Ponto Flutuante**: PrecisÃ£o e representaÃ§Ã£o complexas

## ğŸ”¬ VariaÃ§Ãµes e ExtensÃµes

### ğŸ“Š MSD (Most Significant Digit)
- **EstratÃ©gia**: Ordenar dÃ­gito mais significativo primeiro
- **Vantagem**: Pode terminar cedo se dÃ­gitos diferentes
- **Desvantagem**: Mais complexo, nÃ£o estÃ¡vel

### ğŸ”¢ Base Mista
- **Conceito**: Usar bases diferentes para diferentes posiÃ§Ãµes
- **AplicaÃ§Ã£o**: Otimizar para distribuiÃ§Ã£o especÃ­fica dos dados
- **Exemplo**: Base 10 para humanos, base 2 para computadores

### ğŸ¨ OrdenaÃ§Ã£o de Strings
- **AdaptaÃ§Ã£o**: Usar caracteres como dÃ­gitos
- **Base**: Tamanho do alfabeto (ASCII: 256)
- **Estabilidade**: MantÃ©m ordem lexicogrÃ¡fica

## ğŸ’¡ Insights TeÃ³ricos

### ğŸš€ Por que Funciona?
- **DecomposiÃ§Ã£o**: Problema grande â†’ problemas pequenos
- **Estabilidade**: Preserva trabalho de iteraÃ§Ãµes anteriores
- **Acesso AleatÃ³rio**: O(1) para indexaÃ§Ã£o por dÃ­gito

### ğŸ¯ Trade-offs
- **EspaÃ§o vs Tempo**: O(n) espaÃ§o para O(n) tempo
- **Flexibilidade vs Performance**: RestriÃ§Ãµes especÃ­ficas
- **Simplicidade vs EficiÃªncia**: Algoritmo especializado

### ğŸ”¬ LimitaÃ§Ãµes
- **Modelo de ComputaÃ§Ã£o**: Depende de acesso aleatÃ³rio
- **Tamanho das Chaves**: Limitado por memÃ³ria disponÃ­vel
- **DistribuiÃ§Ã£o**: Performance pode variar com dados

## ğŸ“Š ComparaÃ§Ã£o com Outros Algoritmos

| Aspecto | Radix Sort | Merge Sort | Quick Sort |
|---------|------------|------------|------------|
| **Tempo** | O(n Ã— d) | O(n log n) | O(n log n) |
| **EspaÃ§o** | O(n) | O(n) | O(log n) |
| **EstÃ¡vel** | âœ… | âœ… | âŒ |
| **Adaptativo** | âŒ | âŒ | âœ… |
| **RestriÃ§Ãµes** | Chaves inteiras | Nenhuma | Nenhuma | 