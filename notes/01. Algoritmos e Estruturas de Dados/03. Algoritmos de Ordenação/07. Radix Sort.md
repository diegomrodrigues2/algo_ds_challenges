# 🔢 Radix Sort

## 🎯 Conceito Fundamental

### 📊 Ordenação por Dígitos
- **Estratégia**: Ordenar números dígito por dígito
- **Base**: Usar base n para decomposição eficiente
- **Estabilidade**: Ordem relativa preservada entre itens iguais
- **Decomposição**: Quebrar números grandes em dígitos menores

### 🔑 Premissas
- **Chaves Inteiras**: Números naturais ou inteiros
- **Faixa Limitada**: u ≤ n^c para constante c
- **Acesso Aleatório**: Modelo de computação com indexação O(1)

## ⚙️ Algoritmo Detalhado

### 📝 Pseudocódigo
```
RadixSort(A, n, u):
    d = log_n(u)  // número de dígitos
    for i = 0 to d-1:
        A = CountingSort(A, n, i)  // ordenar por dígito i
    return A

CountingSort(A, n, digit):
    // Ordenar array A pelo dígito especificado
    count = array[0...n-1] inicializado com 0
    output = array[0...n-1]
    
    // Contar frequência de cada dígito
    for j = 0 to n-1:
        d = getDigit(A[j], digit)
        count[d]++
    
    // Acumular contadores
    for i = 1 to n-1:
        count[i] += count[i-1]
    
    // Construir output estável
    for j = n-1 downto 0:
        d = getDigit(A[j], digit)
        output[count[d]-1] = A[j]
        count[d]--
    
    return output
```

### 🔧 Função Auxiliar
```
getDigit(number, position):
    return (number // n^position) % n
```

## 📈 Análise de Complexidade

### ⏱️ Tempo de Execução
| Componente | Tempo | Justificativa |
|------------|-------|---------------|
| **Decomposição** | O(n × d) | n números × d dígitos cada |
| **Counting Sort** | O(n) por dígito | Algoritmo linear estável |
| **Total** | **O(n × d)** | d iterações de counting sort |

### 💾 Espaço
- **Counting Sort**: O(n) para arrays auxiliares
- **Decomposição**: O(1) por número (in-place)
- **Total**: **O(n)** - espaço linear

### 🎯 Quando é Linear?
- **Condição**: u ≤ n^c para constante c
- **Resultado**: d = log_n(u) ≤ log_n(n^c) = c
- **Complexidade**: O(n × c) = **O(n)**

## 🔬 Implementação Prática

### 🐍 Python
```python
def radix_sort(arr, base=None):
    if not arr:
        return arr
    
    n = len(arr)
    if base is None:
        base = n
    
    # Encontrar máximo para determinar dígitos
    max_val = max(arr)
    if max_val == 0:
        return arr
    
    # Calcular número de dígitos
    digits = 0
    temp = max_val
    while temp > 0:
        digits += 1
        temp //= base
    
    # Ordenar por cada dígito
    for digit in range(digits):
        arr = counting_sort_by_digit(arr, base, digit)
    
    return arr

def counting_sort_by_digit(arr, base, digit):
    n = len(arr)
    count = [0] * base
    output = [0] * n
    
    # Contar frequência
    for num in arr:
        d = (num // (base ** digit)) % base
        count[d] += 1
    
    # Acumular
    for i in range(1, base):
        count[i] += count[i-1]
    
    # Construir output
    for i in range(n-1, -1, -1):
        d = (arr[i] // (base ** digit)) % base
        output[count[d]-1] = arr[i]
        count[d] -= 1
    
    return output
```

### ⚡ Otimizações
- **Base Adaptativa**: Escolher base baseada no tamanho dos dados
- **Early Termination**: Parar quando array já ordenado
- **In-place**: Modificar array original em vez de criar cópias

## 📊 Exemplo Detalhado

### 🔢 Dados de Entrada
```
Array: [170, 45, 75, 90, 802, 24, 2, 66]
n = 8, base = 8, max = 802
dígitos = log_8(802) ≈ 3
```

### 📝 Passo a Passo

#### Passo 1: Ordenar por dígito menos significativo (posição 0)
```
Dígitos: [0, 5, 3, 2, 2, 0, 2, 2]
Ordenado: [170, 90, 802, 24, 2, 75, 45, 66]
```

#### Passo 2: Ordenar por dígito do meio (posição 1)
```
Dígitos: [1, 1, 0, 2, 0, 1, 5, 8]
Ordenado: [802, 2, 24, 45, 66, 170, 75, 90]
```

#### Passo 3: Ordenar por dígito mais significativo (posição 2)
```
Dígitos: [8, 0, 0, 0, 0, 1, 0, 0]
Resultado: [2, 24, 45, 66, 75, 90, 170, 802]
```

## 🎯 Aplicações Práticas

### ✅ Casos Ideais
- **IDs de Usuário**: Números sequenciais pequenos
- **Timestamps**: Datas em formato compacto (YYYYMMDD)
- **Cores RGB**: Valores de 0-255 para cada canal
- **Scores**: Pontuações em escala limitada
- **Telefones**: Números com formato padronizado

### ❌ Casos Não Recomendados
- **Números Muito Grandes**: u exponencial em n
- **Strings**: Sem ordem numérica natural
- **Números Negativos**: Requer tratamento especial
- **Ponto Flutuante**: Precisão e representação complexas

## 🔬 Variações e Extensões

### 📊 MSD (Most Significant Digit)
- **Estratégia**: Ordenar dígito mais significativo primeiro
- **Vantagem**: Pode terminar cedo se dígitos diferentes
- **Desvantagem**: Mais complexo, não estável

### 🔢 Base Mista
- **Conceito**: Usar bases diferentes para diferentes posições
- **Aplicação**: Otimizar para distribuição específica dos dados
- **Exemplo**: Base 10 para humanos, base 2 para computadores

### 🎨 Ordenação de Strings
- **Adaptação**: Usar caracteres como dígitos
- **Base**: Tamanho do alfabeto (ASCII: 256)
- **Estabilidade**: Mantém ordem lexicográfica

## 💡 Insights Teóricos

### 🚀 Por que Funciona?
- **Decomposição**: Problema grande → problemas pequenos
- **Estabilidade**: Preserva trabalho de iterações anteriores
- **Acesso Aleatório**: O(1) para indexação por dígito

### 🎯 Trade-offs
- **Espaço vs Tempo**: O(n) espaço para O(n) tempo
- **Flexibilidade vs Performance**: Restrições específicas
- **Simplicidade vs Eficiência**: Algoritmo especializado

### 🔬 Limitações
- **Modelo de Computação**: Depende de acesso aleatório
- **Tamanho das Chaves**: Limitado por memória disponível
- **Distribuição**: Performance pode variar com dados

## 📊 Comparação com Outros Algoritmos

| Aspecto | Radix Sort | Merge Sort | Quick Sort |
|---------|------------|------------|------------|
| **Tempo** | O(n × d) | O(n log n) | O(n log n) |
| **Espaço** | O(n) | O(n) | O(log n) |
| **Estável** | ✅ | ✅ | ❌ |
| **Adaptativo** | ❌ | ❌ | ✅ |
| **Restrições** | Chaves inteiras | Nenhuma | Nenhuma | 