# ğŸš€ Quicksort - Divide & Conquer Inteligente

## ğŸ¯ Conceito Central
**Quicksort** Ã© um algoritmo de ordenaÃ§Ã£o **divide-and-conquer** que escolhe um **pivÃ´** e particiona o array em torno dele, recursivamente ordenando as duas metades.

## ğŸ”§ MecÃ¢nica da PartiÃ§Ã£o de Lomuto

### ğŸ“‹ PseudocÃ³digo Essencial
```
LOMUTO-PARTITION(A, low, high):
    pivot = A[high]           # ğŸ¯ Escolhe Ãºltimo elemento
    i = low - 1               # ğŸ“ Ãndice para elementos menores
    
    for j = low to high - 1:  # ğŸ”„ Percorre array
        if A[j] â‰¤ pivot:      # âœ… Elemento menor/igual
            i = i + 1          # ğŸ“ˆ AvanÃ§a posiÃ§Ã£o
            swap A[i] â†” A[j]   # ğŸ”„ Troca elementos
    
    swap A[i + 1] â†” A[high]   # ğŸ¯ Coloca pivÃ´ na posiÃ§Ã£o final
    return i + 1               # ğŸ“ Retorna posiÃ§Ã£o do pivÃ´
```

### ğŸ¨ VisualizaÃ§Ã£o da PartiÃ§Ã£o
```mermaid
graph LR
    A[Array Original] --> B[Escolher PivÃ´]
    B --> C[PartiÃ§Ã£o Lomuto]
    C --> D[Elementos â‰¤ PivÃ´]
    C --> E[PivÃ´ na PosiÃ§Ã£o]
    C --> F[Elementos > PivÃ´]
    D --> G[RecursÃ£o Esquerda]
    E --> H[PivÃ´ Ordenado]
    F --> I[RecursÃ£o Direita]
```

## âš¡ AnÃ¡lise de Complexidade

### ğŸ“Š Tabela de Performance
| CenÃ¡rio | â±ï¸ Tempo | ğŸ’¾ EspaÃ§o | ğŸ“ˆ Estabilidade |
|---------|-----------|-----------|-----------------|
| **Melhor Caso** | $O(n \log n)$ | $O(\log n)$ | âŒ NÃ£o EstÃ¡vel |
| **Caso MÃ©dio** | $O(n \log n)$ | $O(\log n)$ | âŒ NÃ£o EstÃ¡vel |
| **Pior Caso** | $O(n^2)$ | $O(n)$ | âŒ NÃ£o EstÃ¡vel |

### ğŸ” AnÃ¡lise Detalhada
- **ğŸ”„ RecorrÃªncia**: $T(n) = T(k) + T(n-k-1) + O(n)$
- **ğŸ¯ PivÃ´ Ã“timo**: $k = n/2$ â†’ $O(n \log n)$
- **âš ï¸ PivÃ´ Ruim**: $k = 0$ ou $k = n-1$ â†’ $O(n^2)$

## ğŸ¯ Vantagens vs Desvantagens

### âœ… Vantagens
- **ğŸš€ RÃ¡pido no caso mÃ©dio**: $O(n \log n)$
- **ğŸ’¾ In-place**: Modifica array original
- **ğŸ¯ Cache-friendly**: Boa localidade de referÃªncia
- **ğŸ”§ Simples**: FÃ¡cil de implementar

### âŒ Desvantagens
- **âš ï¸ Pior caso**: $O(n^2)$ com dados jÃ¡ ordenados
- **ğŸ”„ NÃ£o estÃ¡vel**: Pode trocar elementos iguais
- **ğŸ² SensÃ­vel ao pivÃ´**: Performance depende da escolha

## ğŸ”§ ImplementaÃ§Ã£o Python

### ğŸ¯ PartiÃ§Ã£o de Lomuto
```python
def lomuto_partition(arr, low, high):
    pivot = arr[high]         # ğŸ¯ Ãšltimo elemento
    i = low - 1               # ğŸ“ PosiÃ§Ã£o para menores
    
    for j in range(low, high):
        if arr[j] <= pivot:   # âœ… Elemento menor/igual
            i += 1            # ğŸ“ˆ AvanÃ§a posiÃ§Ã£o
            arr[i], arr[j] = arr[j], arr[i]  # ğŸ”„ Troca
    
    arr[i + 1], arr[high] = arr[high], arr[i + 1]  # ğŸ¯ PivÃ´ final
    return i + 1              # ğŸ“ Retorna posiÃ§Ã£o
```

### ğŸš€ Quicksort Completo
```python
def quicksort_lomuto(arr, low=None, high=None):
    if low is None:
        low = 0
    if high is None:
        high = len(arr) - 1
    
    if low < high:            # ğŸ”„ Caso recursivo
        pivot_idx = lomuto_partition(arr, low, high)
        quicksort_lomuto(arr, low, pivot_idx - 1)    # â¬…ï¸ Esquerda
        quicksort_lomuto(arr, pivot_idx + 1, high)   # â¡ï¸ Direita
    
    return arr                # âœ… Array ordenado
```

## ğŸ² OtimizaÃ§Ãµes PrÃ¡ticas

### ğŸ¯ Escolha Inteligente do PivÃ´
- **ğŸ“Š Mediana de 3**: Escolhe mediana entre primeiro, meio e Ãºltimo
- **ğŸ² PivÃ´ aleatÃ³rio**: Evita pior caso determinÃ­stico
- **ğŸ“ˆ Mediana de 5**: Melhor estimativa para arrays grandes

### ğŸ”„ Tratamento de Duplicatas
- **ğŸ”„ Three-way partition**: Separa elementos iguais ao pivÃ´
- **ğŸ“Š Lomuto modificado**: Agrupa elementos iguais
- **âš¡ Hoare partition**: Mais eficiente para duplicatas

## ğŸ† ComparaÃ§Ã£o com Outros Algoritmos

### ğŸ“Š Tabela Comparativa
| Algoritmo | â±ï¸ Tempo MÃ©dio | â±ï¸ Pior Caso | ğŸ’¾ EspaÃ§o | ğŸ”„ EstÃ¡vel |
|-----------|----------------|---------------|-----------|------------|
| **Quicksort** | $O(n \log n)$ | $O(n^2)$ | $O(\log n)$ | âŒ |
| **Merge Sort** | $O(n \log n)$ | $O(n \log n)$ | $O(n)$ | âœ… |
| **Heap Sort** | $O(n \log n)$ | $O(n \log n)$ | $O(1)$ | âŒ |
| **Tim Sort** | $O(n \log n)$ | $O(n \log n)$ | $O(n)$ | âœ… |

## ğŸ¯ AplicaÃ§Ãµes PrÃ¡ticas

### ğŸš€ Casos de Uso Ideais
- **ğŸ“Š OrdenaÃ§Ã£o geral**: Quando estabilidade nÃ£o importa
- **âš¡ Sistemas em tempo real**: Performance mÃ©dia excelente
- **ğŸ’¾ MemÃ³ria limitada**: In-place sorting
- **ğŸ² Dados aleatÃ³rios**: Evita pior caso

### âš ï¸ Casos a Evitar
- **ğŸ“ˆ Dados jÃ¡ ordenados**: Pior caso $O(n^2)$
- **ğŸ”„ Estabilidade necessÃ¡ria**: Use Merge Sort
- **ğŸ¯ OrdenaÃ§Ã£o parcial**: Use Heap Sort

## ğŸ’¡ Insights TeÃ³ricos

### ğŸ” Por que Funciona?
- **ğŸ¯ Invariante**: ApÃ³s partiÃ§Ã£o, pivÃ´ estÃ¡ na posiÃ§Ã£o final
- **ğŸ”„ RecursÃ£o**: Subproblemas menores garantem convergÃªncia
- **ğŸ“Š Probabilidade**: PivÃ´ aleatÃ³rio evita pior caso

### ğŸ² AnÃ¡lise ProbabilÃ­stica
- **ğŸ“ˆ Caso mÃ©dio**: $O(n \log n)$ com pivÃ´ aleatÃ³rio
- **ğŸ¯ EsperanÃ§a**: $\frac{1}{n} \sum_{i=1}^{n} (T(i-1) + T(n-i)) + O(n)$
- **ğŸ“Š Resultado**: $T(n) = O(n \log n)$ em esperanÃ§a

## ğŸš€ EvoluÃ§Ã£o HistÃ³rica

### ğŸ“… Desenvolvimento
- **1959**: Tony Hoare desenvolve Quicksort
- **1961**: PublicaÃ§Ã£o em Communications of the ACM
- **1975**: Sedgewick resolve problemas de anÃ¡lise
- **1993**: Bentley e McIlroy otimizam para bibliotecas

### ğŸ”§ VariaÃ§Ãµes Modernas
- **ğŸ”„ Dual-pivot**: Escolhe dois pivÃ´s
- **ğŸ“Š Introspective**: Combina com Heap Sort
- **âš¡ Block Quicksort**: OtimizaÃ§Ã£o para cache
- **ğŸ¯ Adaptive**: Escolhe algoritmo baseado nos dados 