# üî¢ Counting Sort

## üéØ Conceito Fundamental

### üìä Ordena√ß√£o por Contagem
- **Estrat√©gia**: Contar frequ√™ncia de cada valor e reconstruir ordenado
- **Estabilidade**: Ordem relativa preservada entre itens iguais
- **Acesso Direto**: Usar valores como √≠ndices para contagem
- **Sem Compara√ß√µes**: N√£o compara elementos entre si

### üîë Premissas
- **Chaves Inteiras**: Valores naturais ou inteiros n√£o-negativos
- **Faixa Limitada**: u = O(n) para efici√™ncia
- **Acesso Aleat√≥rio**: Modelo de computa√ß√£o com indexa√ß√£o O(1)

## ‚öôÔ∏è Algoritmo Detalhado

### üìù Pseudoc√≥digo
```
CountingSort(A, n):
    // Encontrar m√°ximo para determinar faixa
    max_val = max(A)
    
    // Inicializar array de contagem
    count = array[0...max_val] inicializado com 0
    
    // Contar frequ√™ncia de cada valor
    for i = 0 to n-1:
        count[A[i]]++
    
    // Acumular contadores (prefix sum)
    for i = 1 to max_val:
        count[i] += count[i-1]
    
    // Construir output est√°vel
    output = array[0...n]
    for i = n-1 downto 0:
        val = A[i]
        output[count[val]-1] = A[i]
        count[val]--
    
    return output
```

### üîß Vers√£o com Faixa Espec√≠fica
```
CountingSort(A, n, min_val, max_val):
    range_size = max_val - min_val + 1
    count = array[0...range_size-1] inicializado com 0
    
    // Contar frequ√™ncia (ajustar para faixa)
    for i = 0 to n-1:
        count[A[i] - min_val]++
    
    // Acumular
    for i = 1 to range_size-1:
        count[i] += count[i-1]
    
    // Construir output est√°vel
    output = array[0...n]
    for i = n-1 downto 0:
        adjusted_val = A[i] - min_val
        output[count[adjusted_val]-1] = A[i]
        count[adjusted_val]--
    
    return output
```

## üìà An√°lise de Complexidade

### ‚è±Ô∏è Tempo de Execu√ß√£o
| Componente | Tempo | Justificativa |
|------------|-------|---------------|
| **Encontrar M√°ximo** | O(n) | Percorrer array uma vez |
| **Contagem** | O(n) | n itera√ß√µes |
| **Acumula√ß√£o** | O(u) | u = max_val + 1 |
| **Reconstru√ß√£o** | O(n) | n itera√ß√µes |
| **Total** | **O(n + u)** | Soma de todos os componentes |

### üíæ Espa√ßo
- **Array de Contagem**: O(u) onde u = max_val + 1
- **Array de Sa√≠da**: O(n)
- **Total**: **O(n + u)** - espa√ßo linear

### üéØ Quando √© Linear?
- **Condi√ß√£o**: u = O(n)
- **Resultado**: O(n + u) = O(n + O(n)) = **O(n)**
- **Exemplo**: Valores de 0 a n-1

## üî¨ Implementa√ß√£o Pr√°tica

### üêç Python
```python
def counting_sort(arr, min_val=None, max_val=None):
    """
    Ordena√ß√£o por contagem est√°vel
    
    Args:
        arr: Lista de inteiros n√£o-negativos
        min_val: Valor m√≠nimo (opcional)
        max_val: Valor m√°ximo (opcional)
    
    Returns:
        Lista ordenada
    """
    if not arr:
        return arr
    
    n = len(arr)
    
    # Determinar faixa se n√£o fornecida
    if min_val is None:
        min_val = min(arr)
    if max_val is None:
        max_val = max(arr)
    
    range_size = max_val - min_val + 1
    
    # Contar frequ√™ncia
    count = [0] * range_size
    for num in arr:
        count[num - min_val] += 1
    
    # Acumular contadores
    for i in range(1, range_size):
        count[i] += count[i-1]
    
    # Construir output est√°vel
    output = [0] * n
    for i in range(n-1, -1, -1):
        adjusted_val = arr[i] - min_val
        output[count[adjusted_val]-1] = arr[i]
        count[adjusted_val] -= 1
    
    return output

def counting_sort_simple(arr):
    """Vers√£o simplificada para valores de 0 a max_val"""
    if not arr:
        return arr
    
    max_val = max(arr)
    count = [0] * (max_val + 1)
    
    # Contar
    for num in arr:
        count[num] += 1
    
    # Reconstruir
    output = []
    for i in range(max_val + 1):
        output.extend([i] * count[i])
    
    return output

# Exemplo de uso
def example_usage():
    # Dados com duplicatas
    data = [4, 2, 1, 4, 1, 3, 2, 4, 1]
    sorted_data = counting_sort(data)
    
    # Dados com faixa espec√≠fica
    grades = [85, 92, 78, 95, 85, 88, 92, 78]
    sorted_grades = counting_sort(grades, 0, 100)
    
    return sorted_data, sorted_grades
```

## üìä Exemplo Detalhado

### üî¢ Dados de Entrada
```
Array: [4, 2, 1, 4, 1, 3, 2, 4, 1]
n = 9, max_val = 4
```

### üìù Passo a Passo

#### Passo 1: Contar Frequ√™ncia
```
Valor:    0  1  2  3  4
Frequ√™ncia: 0  3  2  1  3
```

#### Passo 2: Acumular Contadores
```
Valor:    0  1  2  3  4
Acumulado: 0  3  5  6  9
```

#### Passo 3: Reconstruir (est√°vel)
```
i=8: A[8]=1 ‚Üí output[3-1]=1 ‚Üí output[2]=1
i=7: A[7]=2 ‚Üí output[5-1]=2 ‚Üí output[4]=2
i=6: A[6]=3 ‚Üí output[6-1]=3 ‚Üí output[5]=3
...
Resultado: [1, 1, 1, 2, 2, 3, 4, 4, 4]
```

## üéØ Aplica√ß√µes Pr√°ticas

### ‚úÖ Casos Ideais
- **Dados com Duplicatas**: M√∫ltiplos itens com mesma chave
- **Chaves Pequenas**: u = O(n) ou u ‚â§ 1000
- **Ordena√ß√£o Est√°vel**: Preservar ordem relativa
- **Algoritmo Auxiliar**: Para radix sort e tuple sort
- **Estat√≠sticas**: Contagem de frequ√™ncias

### ‚ùå Casos N√£o Recomendados
- **Chaves Muito Grandes**: u >> n (espa√ßo excessivo)
- **N√∫meros Negativos**: Requer ajuste de faixa
- **Ponto Flutuante**: Precis√£o e representa√ß√£o complexas
- **Strings**: Sem ordem num√©rica natural

## üî¨ Varia√ß√µes e Extens√µes

### üìä Counting Sort com Objetos
```python
def counting_sort_objects(arr, key_func):
    """Ordenar objetos por chave num√©rica"""
    if not arr:
        return arr
    
    # Extrair chaves
    keys = [key_func(obj) for obj in arr]
    max_key = max(keys)
    
    # Contar por chave
    count = [0] * (max_key + 1)
    for key in keys:
        count[key] += 1
    
    # Acumular
    for i in range(1, max_key + 1):
        count[i] += count[i-1]
    
    # Reconstruir est√°vel
    output = [None] * len(arr)
    for i in range(len(arr)-1, -1, -1):
        key = keys[i]
        output[count[key]-1] = arr[i]
        count[key] -= 1
    
    return output
```

### üé® Counting Sort para Strings
```python
def counting_sort_strings(strings, position):
    """Ordenar strings por caractere em posi√ß√£o espec√≠fica"""
    if not strings:
        return strings
    
    # ASCII range
    count = [0] * 256
    
    # Contar caracteres na posi√ß√£o
    for s in strings:
        if position < len(s):
            count[ord(s[position])] += 1
    
    # Acumular
    for i in range(1, 256):
        count[i] += count[i-1]
    
    # Reconstruir
    output = [None] * len(strings)
    for i in range(len(strings)-1, -1, -1):
        s = strings[i]
        if position < len(s):
            char = ord(s[position])
            output[count[char]-1] = s
            count[char] -= 1
    
    return output
```

## üí° Insights Te√≥ricos

### üöÄ Por que Funciona?
- **Sem Compara√ß√µes**: Usa valores como √≠ndices
- **Estabilidade**: Ordem de inser√ß√£o preservada
- **Acesso Direto**: O(1) para indexa√ß√£o por valor

### üéØ Trade-offs
- **Espa√ßo vs Tempo**: O(u) espa√ßo para O(n + u) tempo
- **Simplicidade vs Efici√™ncia**: Algoritmo simples mas especializado
- **Flexibilidade vs Performance**: Restri√ß√µes espec√≠ficas

### üî¨ Limita√ß√µes
- **Faixa de Valores**: u deve ser razo√°vel
- **Tipo de Dados**: Apenas inteiros n√£o-negativos
- **Distribui√ß√£o**: Performance depende da distribui√ß√£o

## üìä Compara√ß√£o com Outros Algoritmos

| Aspecto | Counting Sort | Merge Sort | Quick Sort |
|---------|---------------|------------|------------|
| **Tempo** | O(n + u) | O(n log n) | O(n log n) |
| **Espa√ßo** | O(n + u) | O(n) | O(log n) |
| **Est√°vel** | ‚úÖ | ‚úÖ | ‚ùå |
| **Compara√ß√µes** | 0 | O(n log n) | O(n log n) |
| **Restri√ß√µes** | u pequeno | Nenhuma | Nenhuma |

## üéØ Otimiza√ß√µes Pr√°ticas

### ‚ö° Melhorias de Performance
- **Early Exit**: Parar se array j√° ordenado
- **In-place**: Modificar array original quando poss√≠vel
- **Cache-friendly**: Acessos sequenciais √† mem√≥ria

### üîß Adapta√ß√µes Espec√≠ficas
- **Faixa Din√¢mica**: Ajustar baseado nos dados
- **Buckets**: Para distribui√ß√µes espec√≠ficas
- **H√≠brido**: Combinar com outros algoritmos 