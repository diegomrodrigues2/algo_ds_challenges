# ğŸš€ OrdenaÃ§Ã£o Linear

## ğŸ¯ Quebrando o Limite Inferior

### ğŸ“Š ComparaÃ§Ã£o vs Acesso AleatÃ³rio
- **Modelo de ComparaÃ§Ã£o**: Î©(n log n) - limite fundamental
- **Modelo de Acesso AleatÃ³rio**: O(n) - possÃ­vel com restriÃ§Ãµes
- **Chave**: Usar propriedades dos dados, nÃ£o apenas comparaÃ§Ãµes

### ğŸ”‘ Premissas para OrdenaÃ§Ã£o Linear
- **Chaves Ãšnicas**: Evitar colisÃµes
- **Chaves Inteiras**: Permitir indexaÃ§Ã£o direta
- **Faixa Limitada**: u = O(n) ou u = n^c

## ğŸ¯ Direct Access Array Sort

### âš¡ Algoritmo BÃ¡sico
```
1. Criar array de tamanho u
2. Para cada item x: array[x.key] = x
3. Percorrer array retornando itens em ordem
```

### ğŸ“ˆ Complexidade
| OperaÃ§Ã£o | Tempo | EspaÃ§o |
|----------|-------|--------|
| ConstruÃ§Ã£o | O(n) | O(u) |
| Leitura | O(u) | - |
| **Total** | **O(n + u)** | **O(u)** |

### âœ… Vantagens
- ğŸš€ **Simples**: ImplementaÃ§Ã£o direta
- âš¡ **RÃ¡pido**: O(n) quando u = O(n)
- ğŸ¯ **DeterminÃ­stico**: Sem aleatoriedade

### âŒ LimitaÃ§Ãµes
- ğŸ’¾ **EspaÃ§o**: O(u) pode ser enorme
- ğŸ”¢ **Chaves Ãšnicas**: NÃ£o suporta duplicatas
- ğŸ“ **Faixa Limitada**: u deve ser pequeno

## ğŸ”¢ Counting Sort

### ğŸ¯ ExtensÃ£o para Duplicatas
- **Estrutura**: Array de listas encadeadas
- **ColisÃµes**: MÃºltiplos itens por chave
- **Estabilidade**: MantÃ©m ordem relativa

### âš™ï¸ Funcionamento
```
1. Criar array de listas de tamanho u
2. Para cada item x: adicionar Ã  lista[x.key]
3. Percorrer arrays retornando itens em ordem
```

### ğŸ“Š Complexidade
| Aspecto | Tempo | EspaÃ§o |
|---------|-------|--------|
| InserÃ§Ã£o | O(1) amortizado | O(n) |
| Leitura | O(n) | - |
| **Total** | **O(n + u)** | **O(n + u)** |

### ğŸ¯ AplicaÃ§Ãµes
- ğŸ“Š **Dados com Duplicatas**: Chaves repetidas
- ğŸ”¢ **Chaves Pequenas**: u = O(n)
- ğŸ¨ **OrdenaÃ§Ã£o EstÃ¡vel**: Preserva ordem original

## ğŸ”¢ Radix Sort

### ğŸ¯ OrdenaÃ§Ã£o por DÃ­gitos
- **DecomposiÃ§Ã£o**: Quebrar nÃºmeros grandes em dÃ­gitos
- **Base n**: Cada dÃ­gito âˆˆ [0, n-1]
- **OrdenaÃ§Ã£o EstÃ¡vel**: DÃ­gito menos significativo primeiro

### âš™ï¸ Algoritmo
```
1. Decompor cada nÃºmero em log_n(u) dÃ­gitos
2. Para cada dÃ­gito (menos â†’ mais significativo):
   - Aplicar counting sort no dÃ­gito
3. Resultado final ordenado
```

### ğŸ“ˆ Complexidade
| Componente | Tempo |
|------------|-------|
| DecomposiÃ§Ã£o | O(n Ã— log_n(u)) |
| OrdenaÃ§Ã£o por DÃ­gito | O(n) |
| **Total** | **O(n Ã— log_n(u))** |

### ğŸ¯ Quando Ã© Linear?
- **u â‰¤ n^c**: Para constante c
- **log_n(u) â‰¤ c**: NÃºmero constante de dÃ­gitos
- **Resultado**: O(n) quando u Ã© polinomial

## ğŸ“Š ComparaÃ§Ã£o de Algoritmos

| Algoritmo | Tempo | EspaÃ§o | EstÃ¡vel | RestriÃ§Ãµes |
|-----------|-------|--------|---------|------------|
| **Direct Access** | O(n + u) | O(u) | âœ… | Chaves Ãºnicas, u pequeno |
| **Counting Sort** | O(n + u) | O(n + u) | âœ… | u pequeno |
| **Radix Sort** | O(n Ã— log_n(u)) | O(n + u) | âœ… | u polinomial |

## ğŸ¯ Casos de Uso

### âœ… Ideal para Radix Sort
- ğŸ”¢ **IDs de UsuÃ¡rio**: NÃºmeros pequenos
- ğŸ“… **Timestamps**: Datas em formato compacto
- ğŸ¨ **Cores RGB**: Valores de 0-255
- ğŸ“Š **Scores**: PontuaÃ§Ãµes limitadas

### âŒ NÃ£o Recomendado
- ğŸ”¢ **NÃºmeros Grandes**: u exponencial
- ğŸ“ **Strings**: Sem ordem numÃ©rica natural
- ğŸ¯ **Chaves Complexas**: Objetos compostos
- ğŸ”„ **Dados DinÃ¢micos**: InserÃ§Ãµes frequentes

## ğŸ’¡ Insights Fundamentais

### ğŸš€ Por que Funciona?
- **Acesso AleatÃ³rio**: O(1) para indexaÃ§Ã£o
- **Propriedades dos Dados**: Estrutura conhecida
- **DecomposiÃ§Ã£o**: Quebrar problemas grandes

### ğŸ¯ Trade-offs
- **EspaÃ§o vs Tempo**: Mais espaÃ§o, menos tempo
- **Flexibilidade vs Performance**: RestriÃ§Ãµes especÃ­ficas
- **Simplicidade vs EficiÃªncia**: Algoritmos especializados

### ğŸ”¬ LimitaÃ§Ãµes TeÃ³ricas
- **Modelo de ComputaÃ§Ã£o**: Depende de acesso aleatÃ³rio
- **Tamanho das Chaves**: Limitado por memÃ³ria
- **DistribuiÃ§Ã£o**: Pode nÃ£o ser uniforme 