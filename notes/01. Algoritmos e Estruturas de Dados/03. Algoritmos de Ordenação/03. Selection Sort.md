# ğŸ¯ Selection Sort

## ğŸ¯ EstratÃ©gia
**Seleciona** o maior elemento e o coloca na posiÃ§Ã£o correta, repetindo atÃ© ordenar

### ğŸ”„ Algoritmo
1. **Encontra** o maior elemento no array nÃ£o ordenado
2. **Troca** com o Ãºltimo elemento nÃ£o ordenado
3. **Repete** para o subarray restante

## ğŸ”§ ImplementaÃ§Ã£o Recursiva

### ğŸ“Š Prefix Max
```python
def prefix_max(A, i):
    if i == 0:
        return 0
    j = prefix_max(A, i-1)
    if A[i] > A[j]:
        return i
    return j
```

### ğŸ¯ Selection Sort
```python
def selection_sort(A, i):
    if i == 0:
        return
    j = prefix_max(A, i)  # Encontra maior
    A[i], A[j] = A[j], A[i]  # Troca
    selection_sort(A, i-1)  # RecursÃ£o
```

## âš¡ AnÃ¡lise de Complexidade

### ğŸ“ˆ Prefix Max
- **RecursÃ£o**: T(n) = T(n-1) + O(1)
- **SoluÃ§Ã£o**: T(n) = O(n)
- **Prova**: SubstituiÃ§Ã£o com T(n) = cn

### ğŸ¯ Selection Sort
- **RecursÃ£o**: T(n) = T(n-1) + O(n)
- **SoluÃ§Ã£o**: T(n) = O(nÂ²)
- **Prova**: Soma aritmÃ©tica 1+2+...+n = n(n+1)/2

## ğŸ” Exemplo Visual
```
[8, 2, 4, 9, 3] â†’ [8, 2, 4, 3, 9] â†’ [3, 2, 4, 8, 9] â†’ [2, 3, 4, 8, 9]
     â†‘                    â†‘                    â†‘
   Maior 9              Maior 8              Maior 4
```

## âœ… Vantagens
- **Simplicidade**: FÃ¡cil de entender e implementar
- **In-place**: NÃ£o requer espaÃ§o extra
- **EstÃ¡vel**: MantÃ©m ordem relativa de elementos iguais
- **Minimal swaps**: Apenas n-1 trocas

## âŒ LimitaÃ§Ãµes
- **Complexidade**: O(nÂ²) sempre
- **Ineficiente**: NÃ£o aproveita ordenaÃ§Ã£o parcial
- **ComparaÃ§Ãµes**: Sempre nÂ²/2 comparaÃ§Ãµes

## ğŸ¯ Casos de Uso
- **Educacional**: Primeiro algoritmo de ordenaÃ§Ã£o
- **Arrays pequenos**: n < 50 elementos
- **ImplementaÃ§Ã£o simples**: Quando simplicidade Ã© prioridade
- **Minimal swaps**: Quando trocas sÃ£o custosas

## ğŸ’¡ Insights TeÃ³ricos
- **RecursÃ£o**: Estrutura natural para anÃ¡lise
- **InduÃ§Ã£o**: Prova de correÃ§Ã£o por induÃ§Ã£o
- **SubstituiÃ§Ã£o**: MÃ©todo para resolver recorrÃªncias
- **Soma aritmÃ©tica**: PadrÃ£o comum em algoritmos quadrÃ¡ticos 