# 🔧 Aplicações Avançadas do Queue

## 🎯 Visão Geral

Queues são fundamentais para **muitos algoritmos avançados** e sistemas práticos. Sua propriedade FIFO torna-os ideais para processamento sequencial, busca em largura e sistemas de agendamento.

## 🔍 Breadth-First Search (BFS)

### 🌟 **Problema**
Explorar um grafo em **largura**, visitando todos os vértices em um nível antes de passar para o próximo.

### 📝 **Implementação**
```python
def bfs(graph, start):
    queue = [start]
    visited = set([start])
    result = []
    
    while queue:
        vertex = queue.pop(0)  # Dequeue
        result.append(vertex)
        
        # Adiciona vizinhos não visitados
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)  # Enqueue
    
    return result

def bfs_with_distance(graph, start):
    queue = [(start, 0)]  # (vertex, distance)
    visited = {start: 0}
    distances = {}
    
    while queue:
        vertex, distance = queue.pop(0)
        distances[vertex] = distance
        
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited[neighbor] = distance + 1
                queue.append((neighbor, distance + 1))
    
    return distances
```

### 🎯 **Exemplo Visual**
```
Grafo: A → B, C
       B → D, E
       C → F
       D, E, F → []

Queue: [A]
Visited: {A}
Result: []

Passo 1: Dequeue A → Queue: []
         Add B, C → Queue: [B, C]
         Result: [A]

Passo 2: Dequeue B → Queue: [C]
         Add D, E → Queue: [C, D, E]
         Result: [A, B]

Resultado: [A, B, C, D, E, F]
```

## 🎮 Sistemas de Agendamento

### 🌟 **Round Robin Scheduler**
```python
class RoundRobinScheduler:
    def __init__(self, time_quantum):
        self.ready_queue = []
        self.time_quantum = time_quantum
        self.current_process = None
        self.time_elapsed = 0
    
    def add_process(self, process_id, burst_time):
        self.ready_queue.append({
            'id': process_id,
            'burst_time': burst_time,
            'remaining_time': burst_time
        })
    
    def schedule(self):
        if not self.ready_queue and not self.current_process:
            return None
        
        # Se não há processo atual, pega o próximo da fila
        if not self.current_process and self.ready_queue:
            self.current_process = self.ready_queue.pop(0)
            self.time_elapsed = 0
        
        # Executa o processo atual
        if self.current_process:
            self.current_process['remaining_time'] -= 1
            self.time_elapsed += 1
            
            # Verifica se o processo terminou ou esgotou o quantum
            if (self.current_process['remaining_time'] <= 0 or 
                self.time_elapsed >= self.time_quantum):
                
                if self.current_process['remaining_time'] > 0:
                    # Processo não terminou, volta para a fila
                    self.ready_queue.append(self.current_process)
                
                self.current_process = None
                self.time_elapsed = 0
        
        return self.current_process['id'] if self.current_process else None
```

### 🎯 **Exemplo**
```
Processos: P1(6), P2(4), P3(2)
Quantum: 2

Tempo 0-2: P1 executa (resta 4)
Tempo 2-4: P2 executa (resta 2)
Tempo 4-6: P3 executa (termina)
Tempo 6-8: P1 executa (resta 2)
Tempo 8-10: P2 executa (termina)
Tempo 10-12: P1 executa (termina)
```

## 📊 Buffer de Processamento

### 🌟 **Producer-Consumer Pattern**
```python
import threading
import time
from collections import deque

class ProducerConsumer:
    def __init__(self, buffer_size):
        self.buffer = deque(maxlen=buffer_size)
        self.lock = threading.Lock()
        self.not_empty = threading.Condition(self.lock)
        self.not_full = threading.Condition(self.lock)
    
    def produce(self, item):
        with self.lock:
            while len(self.buffer) >= self.buffer.maxlen:
                self.not_full.wait()
            
            self.buffer.append(item)
            self.not_empty.notify()
    
    def consume(self):
        with self.lock:
            while len(self.buffer) == 0:
                self.not_empty.wait()
            
            item = self.buffer.popleft()
            self.not_full.notify()
            return item

# Exemplo de uso
def producer(pc, items):
    for item in items:
        pc.produce(item)
        time.sleep(0.1)

def consumer(pc, count):
    for _ in range(count):
        item = pc.consume()
        print(f"Consumido: {item}")
        time.sleep(0.2)
```

## 🔄 Simulação de Eventos

### 🌟 **Event-Driven Simulation**
```python
import heapq

class Event:
    def __init__(self, time, event_type, data):
        self.time = time
        self.event_type = event_type
        self.data = data
    
    def __lt__(self, other):
        return self.time < other.time

class EventSimulator:
    def __init__(self):
        self.event_queue = []
        self.current_time = 0
    
    def schedule_event(self, time, event_type, data):
        event = Event(time, event_type, data)
        heapq.heappush(self.event_queue, event)
    
    def run_simulation(self, end_time):
        while self.event_queue and self.current_time < end_time:
            event = heapq.heappop(self.event_queue)
            self.current_time = event.time
            
            # Processa o evento
            self.process_event(event)
    
    def process_event(self, event):
        if event.event_type == "arrival":
            print(f"Tempo {event.time}: Cliente {event.data} chegou")
            # Agenda próximo evento
            self.schedule_event(
                self.current_time + 5, 
                "departure", 
                event.data
            )
        elif event.event_type == "departure":
            print(f"Tempo {event.time}: Cliente {event.data} saiu")
```

## 🌐 Networking e Comunicação

### 🌟 **Message Queue**
```python
class MessageQueue:
    def __init__(self):
        self.high_priority = []
        self.normal_priority = []
        self.low_priority = []
    
    def send_message(self, message, priority="normal"):
        if priority == "high":
            self.high_priority.append(message)
        elif priority == "normal":
            self.normal_priority.append(message)
        else:
            self.low_priority.append(message)
    
    def receive_message(self):
        # Prioriza mensagens de alta prioridade
        if self.high_priority:
            return self.high_priority.pop(0)
        elif self.normal_priority:
            return self.normal_priority.pop(0)
        elif self.low_priority:
            return self.low_priority.pop(0)
        else:
            return None
    
    def has_messages(self):
        return bool(self.high_priority or self.normal_priority or self.low_priority)
```

### 🌟 **Packet Router**
```python
class PacketRouter:
    def __init__(self, num_queues):
        self.queues = [[] for _ in range(num_queues)]
        self.current_queue = 0
    
    def enqueue_packet(self, packet, queue_id=None):
        if queue_id is None:
            queue_id = self.current_queue
            self.current_queue = (self.current_queue + 1) % len(self.queues)
        
        self.queues[queue_id].append(packet)
    
    def dequeue_packet(self, queue_id):
        if self.queues[queue_id]:
            return self.queues[queue_id].pop(0)
        return None
    
    def get_queue_status(self):
        return [len(queue) for queue in self.queues]
```

## 🎯 Algoritmos de Busca

### 🌟 **Level-Order Traversal**
```python
def level_order_traversal(root):
    if not root:
        return []
    
    queue = [root]
    result = []
    
    while queue:
        level_size = len(queue)
        level = []
        
        for _ in range(level_size):
            node = queue.pop(0)
            level.append(node.value)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(level)
    
    return result
```

### 🌟 **Shortest Path (BFS)**
```python
def shortest_path_bfs(graph, start, end):
    queue = [(start, [start])]  # (vertex, path)
    visited = set([start])
    
    while queue:
        vertex, path = queue.pop(0)
        
        if vertex == end:
            return path
        
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                new_path = path + [neighbor]
                queue.append((neighbor, new_path))
    
    return None  # Caminho não encontrado
```

## 💡 Dicas de Implementação

### 🎯 **Pontos-Chave**
- **📊 Escolha queue adequada**: Baseada no problema
- **🔄 Considere prioridades**: Para sistemas complexos
- **⚡ Otimize performance**: Para aplicações em tempo real
- **📏 Controle memória**: Para sistemas com restrições

### 🔧 **Otimizações**
- **📊 Pre-allocation**: Para buffers fixos
- **🔄 Batch processing**: Para múltiplas operações
- **⚡ Memory pooling**: Reutilizar estruturas
- **📏 Lazy evaluation**: Calcular apenas quando necessário

### 🎯 **Casos Especiais**
- **📊 Queue vazia**: Trate adequadamente
- **🔄 Queue cheia**: Para capacidades fixas
- **⚡ Deadlock**: Para sistemas concorrentes
- **📏 Starvation**: Para sistemas com prioridades 