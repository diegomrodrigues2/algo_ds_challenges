# ğŸ”„ Queue

## ğŸ¯ O que Ã© uma Queue?

**Queue** Ã© uma estrutura de dados linear que segue o princÃ­pio **FIFO** (First In, First Out). Ã‰ como uma fila de pessoas onde o primeiro a chegar Ã© o primeiro a ser atendido.

### ğŸŒŸ **Propriedade Fundamental**
```
FIFO: First In, First Out
- Primeiro elemento inserido Ã© o primeiro a ser removido
- Acesso apenas ao elemento da frente
```

## ğŸ”„ Como Funciona

### ğŸ“Š **Analogia Simples**
> **Fila de Banco**: Como uma fila de pessoas no banco - quem chega primeiro Ã© atendido primeiro. NÃ£o Ã© possÃ­vel "furar" a fila.

### ğŸ¯ **OperaÃ§Ãµes Principais**
1. **ğŸ“¤ Enqueue**: Adiciona elemento no final
2. **ğŸ“¥ Dequeue**: Remove elemento do inÃ­cio
3. **ğŸ‘€ Peek/Front**: Visualiza primeiro elemento
4. **ğŸ“ Size**: Retorna nÃºmero de elementos
5. **ğŸ” Empty**: Verifica se estÃ¡ vazia

## ğŸ“Š ImplementaÃ§Ã£o com Array

### ğŸ¯ **Estrutura BÃ¡sica**
```python
class Queue:
    def __init__(self):
        self._data = []
        self._size = 0
    
    def enqueue(self, value):
        self._data.append(value)
        self._size += 1
    
    def dequeue(self):
        if self.is_empty():
            raise IndexError("Queue vazia")
        self._size -= 1
        return self._data.pop(0)
    
    def front(self):
        if self.is_empty():
            raise IndexError("Queue vazia")
        return self._data[0]
    
    def size(self):
        return self._size
    
    def is_empty(self):
        return self._size == 0
```

### ğŸ¨ **RepresentaÃ§Ã£o Visual**
```
Queue: [A, B, C, D]
       â†‘        â†‘
     Front    Back

Enqueue(E): [A, B, C, D, E]
             â†‘           â†‘
           Front       Back

Dequeue(): [B, C, D, E]
            â†‘        â†‘
          Front    Back
```

## âš¡ Complexidade das OperaÃ§Ãµes

### ğŸ“ˆ **AnÃ¡lise de Complexidade**
| OperaÃ§Ã£o | Complexidade | ExplicaÃ§Ã£o |
|----------|--------------|------------|
| **ğŸ“¤ Enqueue** | O(1) | InserÃ§Ã£o no final do array |
| **ğŸ“¥ Dequeue** | O(n) | RemoÃ§Ã£o do inÃ­cio (shift) |
| **ğŸ‘€ Peek/Front** | O(1) | Acesso ao primeiro elemento |
| **ğŸ“ Size** | O(1) | Contador mantido |
| **ğŸ” Empty** | O(1) | VerificaÃ§Ã£o de tamanho |

### ğŸ” **Problema do Dequeue O(n)**
- **ğŸ“Š Shift necessÃ¡rio**: ApÃ³s remover do inÃ­cio, todos os elementos se movem
- **ğŸ”„ IneficiÃªncia**: Para filas grandes, isso Ã© custoso
- **âš¡ SoluÃ§Ãµes**: Circular queue, linked list, ou duas stacks

## âœ… Vantagens vs âŒ Desvantagens

| Aspecto | âœ… Vantagem | âŒ Desvantagem |
|---------|-------------|----------------|
| **âš¡ Enqueue** | O(1) - rÃ¡pido | Dequeue O(n) - lento |
| **ğŸ’¾ MemÃ³ria** | Eficiente | Pode crescer dinamicamente |
| **ğŸ”„ Simplicidade** | FÃ¡cil de implementar | Dequeue ineficiente |
| **ğŸ“Š Flexibilidade** | Cresce automaticamente | NÃ£o permite acesso aleatÃ³rio |

## ğŸ¯ AplicaÃ§Ãµes PrÃ¡ticas

### ğŸ”§ **Sistemas de ComputaÃ§Ã£o**
- **ğŸŒ Networking**: Pacotes de rede em ordem
- **ğŸ® Game Loops**: Processamento de eventos
- **ğŸ“Š Print Spooler**: ImpressÃ£o de documentos
- **ğŸ”§ Task Scheduler**: Sistemas operacionais

### ğŸ“Š **Algoritmos**
- **ğŸ” Breadth-First Search**: ExploraÃ§Ã£o de grafos
- **ğŸ“ Level-order Traversal**: Percursos em Ã¡rvores
- **ğŸ”„ Simulation**: Eventos em ordem temporal
- **ğŸ¯ Buffer Management**: Dados em streaming

### ğŸ—ï¸ **Sistemas Reais**
- **ğŸ¥ Hospital**: Fila de pacientes
- **ğŸ¦ Banco**: Fila de atendimento
- **ğŸ¬ Cinema**: Fila de ingressos
- **ğŸš— TrÃ¢nsito**: Fila de carros

## ğŸ”„ Propriedades MatemÃ¡ticas

### ğŸ“Š **Invariantes**
- **ğŸ“ Tamanho**: Sempre nÃ£o-negativo
- **ğŸ”„ FIFO**: Ordem de remoÃ§Ã£o igual Ã  inserÃ§Ã£o
- **ğŸ“¦ Capacidade**: Pode crescer indefinidamente

### ğŸ¯ **OperaÃ§Ãµes VÃ¡lidas**
```
Enqueue â†’ Queue pode crescer
Dequeue â†’ Queue nÃ£o vazia
Peek â†’ Queue nÃ£o vazia
```

## ğŸ’¡ Dicas de ImplementaÃ§Ã£o

### ğŸ¯ **Pontos-Chave**
- **ğŸ“Š Use list**: ImplementaÃ§Ã£o mais simples
- **ğŸ”„ Controle tamanho**: Mantenha contador atualizado
- **âš¡ Verifique vazia**: Antes de dequeue/peek
- **ğŸ“ Otimize dequeue**: Considere implementaÃ§Ãµes alternativas

### ğŸ”§ **OtimizaÃ§Ãµes**
- **ğŸ“Š Pre-allocation**: Defina tamanho inicial se conhecido
- **ğŸ”„ Circular buffer**: Para evitar shift
- **âš¡ Linked list**: Para dequeue O(1)
- **ğŸ“ Capacity management**: Controlar crescimento

## ğŸ¯ ComparaÃ§Ã£o com Outras Estruturas

| Estrutura | InserÃ§Ã£o | RemoÃ§Ã£o | Acesso | Propriedade |
|-----------|----------|---------|--------|-------------|
| **ğŸ”„ Queue** | O(1) | O(n) | O(1) frente | FIFO |
| **ğŸ“Š Array** | O(1) | O(n) | O(1) | AleatÃ³rio |
| **ğŸ“¦ Stack** | O(1) | O(1) | O(1) topo | LIFO |
| **ğŸ”„ Deque** | O(1) | O(1) | O(1) | Ambos |

## ğŸ”„ VariaÃ§Ãµes Importantes

### ğŸ“Š **Queue com Capacidade Fixa**
```python
class FixedQueue:
    def __init__(self, capacity):
        self._data = [None] * capacity
        self._front = 0
        self._rear = 0
        self._size = 0
        self._capacity = capacity
    
    def enqueue(self, value):
        if self.is_full():
            raise OverflowError("Queue cheia")
        
        self._data[self._rear] = value
        self._rear = (self._rear + 1) % self._capacity
        self._size += 1
    
    def dequeue(self):
        if self.is_empty():
            raise IndexError("Queue vazia")
        
        value = self._data[self._front]
        self._front = (self._front + 1) % self._capacity
        self._size -= 1
        return value
```

### ğŸ”„ **Queue com Linked List**
```python
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

class LinkedListQueue:
    def __init__(self):
        self._front = None
        self._rear = None
        self._size = 0
    
    def enqueue(self, value):
        new_node = Node(value)
        
        if self.is_empty():
            self._front = self._rear = new_node
        else:
            self._rear.next = new_node
            self._rear = new_node
        
        self._size += 1
    
    def dequeue(self):
        if self.is_empty():
            raise IndexError("Queue vazia")
        
        value = self._front.value
        self._front = self._front.next
        
        if self._front is None:
            self._rear = None
        
        self._size -= 1
        return value
```

## ğŸ’¡ Dicas de Debugging

### ğŸ¯ **Problemas Comuns**
- **ğŸ“Š Queue underflow**: Dequeue em queue vazia
- **ğŸ”„ Queue overflow**: Enqueue em queue cheia
- **âš¡ Memory leaks**: NÃ£o limpar referÃªncias
- **ğŸ“ Size mismatch**: Contador desatualizado

### ğŸ”§ **SoluÃ§Ãµes**
- **ğŸ“Š Sempre verificar**: Empty antes de dequeue/peek
- **ğŸ”„ Usar try/catch**: Para operaÃ§Ãµes crÃ­ticas
- **âš¡ Validar entrada**: Verificar parÃ¢metros
- **ğŸ“ Testar extremos**: Queue vazia, um elemento 