# ğŸ”„ OperaÃ§Ãµes BÃ¡sicas do Queue

## ğŸ¯ VisÃ£o Geral

As operaÃ§Ãµes bÃ¡sicas do queue garantem o funcionamento correto da estrutura **FIFO**. Cada operaÃ§Ã£o tem complexidade especÃ­fica e mantÃ©m as propriedades fundamentais da fila.

## ğŸ“¤ Enqueue (InserÃ§Ã£o)

### ğŸŒŸ **Processo de InserÃ§Ã£o**
1. **ğŸ“ Adiciona elemento** no final do array
2. **ğŸ“ Incrementa contador** de tamanho
3. **âœ… Retorna sucesso** (ou exceÃ§Ã£o se cheia)

### ğŸ“ **ImplementaÃ§Ã£o**
```python
def enqueue(self, value):
    # Adiciona no final (back da fila)
    self._data.append(value)
    self._size += 1

def enqueue_with_capacity(self, value):
    # VersÃ£o com verificaÃ§Ã£o de capacidade
    if self._size >= self._capacity:
        raise OverflowError("Queue cheia")
    
    self._data.append(value)
    self._size += 1
```

### ğŸ¯ **Exemplo Visual**
```
Queue: [A, B, C]
       â†‘     â†‘
     Front  Back

Enqueue(D): [A, B, C, D]
             â†‘        â†‘
           Front    Back

Enqueue(E): [A, B, C, D, E]
             â†‘           â†‘
           Front       Back
```

## ğŸ“¥ Dequeue (RemoÃ§Ã£o)

### ğŸŒŸ **Processo de RemoÃ§Ã£o**
1. **ğŸ” Verifica se vazia** (queue underflow)
2. **ğŸ“ Remove elemento** do inÃ­cio do array
3. **ğŸ“ Decrementa contador** de tamanho
4. **ğŸ”„ Retorna elemento** removido

### ğŸ“ **ImplementaÃ§Ã£o**
```python
def dequeue(self):
    # Verifica se queue estÃ¡ vazia
    if self.is_empty():
        raise IndexError("Queue vazia")
    
    # Remove e retorna o primeiro elemento
    self._size -= 1
    return self._data.pop(0)

def dequeue_with_validation(self):
    # VersÃ£o com validaÃ§Ã£o adicional
    if self.is_empty():
        raise IndexError("Queue vazia")
    
    # Remove elemento
    value = self._data[0]
    self._data = self._data[1:]  # Shift todos os elementos
    self._size -= 1
    
    return value
```

### ğŸ¯ **Exemplo Visual**
```
Queue: [A, B, C, D, E]
        â†‘           â†‘
      Front       Back

Dequeue(): [B, C, D, E]  # Retorna A
            â†‘        â†‘
          Front    Back

Dequeue(): [C, D, E]     # Retorna B
             â†‘        â†‘
           Front    Back
```

## ğŸ‘€ Peek/Front (VisualizaÃ§Ã£o)

### ğŸŒŸ **Processo de VisualizaÃ§Ã£o**
1. **ğŸ” Verifica se vazia**
2. **ğŸ‘€ Retorna elemento** da frente sem remover
3. **âœ… MantÃ©m estrutura** inalterada

### ğŸ“ **ImplementaÃ§Ã£o**
```python
def front(self):
    if self.is_empty():
        raise IndexError("Queue vazia")
    
    return self._data[0]

def peek(self):
    # Alias para front()
    return self.front()

def front_with_index(self):
    # VersÃ£o que retorna Ã­ndice tambÃ©m
    if self.is_empty():
        raise IndexError("Queue vazia")
    
    return self._data[0], 0
```

### ğŸ¯ **Exemplo Visual**
```
Queue: [A, B, C, D]
        â†‘        â†‘
      Front    Back

Front(): Retorna A (queue inalterada)
         [A, B, C, D]
          â†‘        â†‘
        Front    Back
```

## ğŸ“ Size e Empty

### ğŸ“Š **VerificaÃ§Ã£o de Tamanho**
```python
def size(self):
    return self._size

def is_empty(self):
    return self._size == 0

def is_full(self):
    return self._size >= self._capacity  # Para queue com capacidade
```

### ğŸ¯ **VerificaÃ§Ãµes Ãšteis**
```python
def has_elements(self):
    return not self.is_empty()

def can_enqueue(self):
    return self._size < self._capacity  # Para queue com capacidade

def get_capacity(self):
    return self._capacity  # Para queue com capacidade
```

## ğŸ”„ ImplementaÃ§Ãµes Iterativas

### ğŸ“Š **IteraÃ§Ã£o sobre Queue**
```python
def __iter__(self):
    # Itera da frente para o final
    for i in range(self._size):
        yield self._data[i]

def iterate_reverse(self):
    # Itera do final para a frente
    for i in range(self._size - 1, -1, -1):
        yield self._data[i]

def to_list(self):
    # Converte para lista (frente primeiro)
    return self._data[:self._size]
```

### ğŸ¯ **Busca em Queue**
```python
def contains(self, value):
    # Busca linear O(n)
    for i in range(self._size):
        if self._data[i] == value:
            return True
    return False

def find(self, value):
    # Retorna posiÃ§Ã£o (da frente)
    for i in range(self._size):
        if self._data[i] == value:
            return i
    return -1
```

## ğŸ”§ OperaÃ§Ãµes AvanÃ§adas

### ğŸ—‘ï¸ **Clear (Limpar)**
```python
def clear(self):
    # Limpa todos os elementos
    self._data.clear()
    self._size = 0

def clear_with_capacity(self):
    # MantÃ©m capacidade, limpa elementos
    self._data = [None] * self._capacity
    self._size = 0
```

### ğŸ“Š **Copy (CÃ³pia)**
```python
def copy(self):
    # Cria cÃ³pia superficial
    new_queue = Queue()
    new_queue._data = self._data.copy()
    new_queue._size = self._size
    return new_queue

def deep_copy(self):
    # Cria cÃ³pia profunda (se necessÃ¡rio)
    import copy
    new_queue = Queue()
    new_queue._data = copy.deepcopy(self._data)
    new_queue._size = self._size
    return new_queue
```

### ğŸ”„ **Reverse (Inverter)**
```python
def reverse(self):
    # Inverte ordem dos elementos
    self._data[:self._size] = self._data[:self._size][::-1]

def reverse_without_mutation(self):
    # Retorna nova queue invertida
    new_queue = Queue()
    for item in reversed(list(self)):
        new_queue.enqueue(item)
    return new_queue
```

## âš¡ OtimizaÃ§Ãµes

### ğŸ”§ **Enqueue Otimizado**
```python
def enqueue_optimized(self, value):
    # Evita redimensionamento frequente
    if len(self._data) <= self._size:
        self._data.append(value)
    else:
        self._data[self._size] = value
    self._size += 1
```

### ğŸ”§ **Dequeue Otimizado**
```python
def dequeue_optimized(self):
    if self.is_empty():
        raise IndexError("Queue vazia")
    
    self._size -= 1
    value = self._data[0]
    
    # Shift otimizado
    for i in range(self._size):
        self._data[i] = self._data[i + 1]
    self._data[self._size] = None  # Ajuda GC
    
    return value
```

## ğŸ’¡ Dicas de ImplementaÃ§Ã£o

### ğŸ¯ **Pontos-Chave**
- **ğŸ“Š Sempre verifique vazia**: Antes de dequeue/peek
- **ğŸ”„ Mantenha contador**: Size sempre atualizado
- **âš¡ Use append**: Para enqueue eficiente
- **ğŸ“ Controle capacidade**: Para queues fixas

### ğŸ”§ **Casos Especiais**
- **ğŸ“Š Queue vazia**: Trate adequadamente
- **ğŸ”„ Queue cheia**: Para capacidades fixas
- **âš¡ Elemento Ãºnico**: Caso base
- **ğŸ“ Capacidade zero**: Queue invÃ¡lida

### ğŸ¯ **Debugging**
- **ğŸ“Š Valide Ã­ndices**: Evite out-of-bounds
- **ğŸ”„ Verifique contadores**: Size consistente
- **âš¡ Teste extremos**: Vazia, cheia, um elemento
- **ğŸ“ Trace operaÃ§Ãµes**: Para encontrar bugs 