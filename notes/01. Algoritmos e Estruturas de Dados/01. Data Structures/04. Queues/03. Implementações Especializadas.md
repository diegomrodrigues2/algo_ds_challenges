# 🔄 Implementações Especializadas do Queue

## 🎯 Visão Geral

Implementações especializadas resolvem problemas específicos do queue básico, como a ineficiência do dequeue O(n) e limitações de memória. As mais importantes são **Circular Queue** e **Queue com Duas Stacks**.

## 🔄 Circular Queue

### 🌟 **O que é?**
**Circular Queue** é uma fila com **capacidade fixa** que reutiliza espaço vazio, evitando o problema de shift O(n) do queue básico.

### 📝 **Implementação**
```python
class CircularQueue:
    def __init__(self, capacity):
        self.capacity = capacity
        self.data = [None] * capacity
        self.head = 0      # Índice do primeiro elemento
        self.tail = 0      # Índice do próximo espaço vazio
        self.count = 0     # Número de elementos
    
    def enqueue(self, item):
        if self.is_full():
            raise OverflowError("Queue cheia")
        
        self.data[self.tail] = item
        self.tail = (self.tail + 1) % self.capacity
        self.count += 1
    
    def dequeue(self):
        if self.is_empty():
            raise IndexError("Queue vazia")
        
        item = self.data[self.head]
        self.head = (self.head + 1) % self.capacity
        self.count -= 1
        return item
    
    def front(self):
        if self.is_empty():
            raise IndexError("Queue vazia")
        return self.data[self.head]
    
    def is_empty(self):
        return self.count == 0
    
    def is_full(self):
        return self.count == self.capacity
    
    def size(self):
        return self.count
```

### 🎯 **Exemplo Visual**
```
Capacidade: 5
Estado inicial: [None, None, None, None, None]
                ↑
              Head/Tail

Enqueue(A): [A, None, None, None, None]
             ↑  ↑
           Head Tail

Enqueue(B): [A, B, None, None, None]
             ↑     ↑
           Head   Tail

Dequeue(): [None, B, None, None, None]
                ↑  ↑
              Head Tail

Enqueue(C): [None, B, C, None, None]
                ↑     ↑
              Head   Tail
```

### ⚡ **Vantagens**
- **🔄 O(1)**: Enqueue e dequeue
- **💾 Eficiente**: Reutiliza espaço
- **📊 Previsível**: Capacidade fixa
- **⚡ Sem shift**: Não move elementos

## 📦 Queue com Duas Stacks

### 🌟 **O que é?**
**Queue com Duas Stacks** implementa uma fila usando duas pilhas, convertendo LIFO em FIFO através de transferência entre stacks.

### 📝 **Implementação**
```python
class QueueTwoStacks:
    def __init__(self):
        self._in = []   # Stack de entrada
        self._out = []  # Stack de saída
    
    def enqueue(self, item):
        # Sempre adiciona na stack de entrada
        self._in.append(item)
    
    def dequeue(self):
        # Se stack de saída está vazia, transfere da entrada
        if not self._out:
            if not self._in:
                raise IndexError("Queue vazia")
            
            # Transfere todos os elementos
            while self._in:
                self._out.append(self._in.pop())
        
        return self._out.pop()
    
    def front(self):
        # Similar ao dequeue, mas não remove
        if not self._out:
            if not self._in:
                raise IndexError("Queue vazia")
            
            while self._in:
                self._out.append(self._in.pop())
        
        return self._out[-1]
    
    def is_empty(self):
        return not self._in and not self._out
    
    def size(self):
        return len(self._in) + len(self._out)
```

### 🎯 **Exemplo Visual**
```
Enqueue(A): In: [A], Out: []
Enqueue(B): In: [A, B], Out: []
Enqueue(C): In: [A, B, C], Out: []

Dequeue(): 
  Passo 1: Transfere In → Out
  In: [], Out: [C, B, A]
  Passo 2: Remove do Out
  In: [], Out: [C, B]
  Retorna: A

Dequeue(): In: [], Out: [C]
  Retorna: B
```

### ⚡ **Análise de Complexidade**
- **📤 Enqueue**: O(1) - sempre
- **📥 Dequeue**: O(1) amortizado - transferência rara
- **👀 Front**: O(1) amortizado
- **💾 Memória**: O(n) - pode usar mais espaço

## 🔄 Deque (Double-Ended Queue)

### 🌟 **O que é?**
**Deque** permite inserção e remoção em **ambas as extremidades**, combinando funcionalidades de stack e queue.

### 📝 **Implementação**
```python
class Deque:
    def __init__(self):
        self._data = []
    
    def push_front(self, item):
        # Adiciona no início
        self._data.insert(0, item)
    
    def push_back(self, item):
        # Adiciona no final
        self._data.append(item)
    
    def pop_front(self):
        # Remove do início
        if self.is_empty():
            raise IndexError("Deque vazio")
        return self._data.pop(0)
    
    def pop_back(self):
        # Remove do final
        if self.is_empty():
            raise IndexError("Deque vazio")
        return self._data.pop()
    
    def front(self):
        if self.is_empty():
            raise IndexError("Deque vazio")
        return self._data[0]
    
    def back(self):
        if self.is_empty():
            raise IndexError("Deque vazio")
        return self._data[-1]
    
    def is_empty(self):
        return len(self._data) == 0
    
    def size(self):
        return len(self._data)
```

### 🎯 **Operações do Deque**
| Operação | Descrição | Complexidade |
|----------|-----------|--------------|
| **push_front** | Adiciona no início | O(n) |
| **push_back** | Adiciona no final | O(1) |
| **pop_front** | Remove do início | O(n) |
| **pop_back** | Remove do final | O(1) |
| **front** | Primeiro elemento | O(1) |
| **back** | Último elemento | O(1) |

## ⚡ Implementações Otimizadas

### 🔧 **Circular Queue Otimizada**
```python
class CircularQueueOptimized:
    def __init__(self, capacity):
        self.capacity = capacity
        self.data = [None] * capacity
        self.head = 0
        self.tail = 0
        self.count = 0
    
    def enqueue(self, item):
        if self.is_full():
            # Redimensiona se necessário
            self._resize()
        
        self.data[self.tail] = item
        self.tail = (self.tail + 1) % self.capacity
        self.count += 1
    
    def _resize(self):
        # Dobra a capacidade
        new_capacity = self.capacity * 2
        new_data = [None] * new_capacity
        
        # Copia elementos na ordem correta
        for i in range(self.count):
            new_data[i] = self.data[(self.head + i) % self.capacity]
        
        self.data = new_data
        self.capacity = new_capacity
        self.head = 0
        self.tail = self.count
```

### 🔧 **Queue com Stacks Otimizada**
```python
class QueueTwoStacksOptimized:
    def __init__(self):
        self._in = []
        self._out = []
    
    def enqueue(self, item):
        self._in.append(item)
    
    def dequeue(self):
        self._ensure_out_has_elements()
        return self._out.pop()
    
    def front(self):
        self._ensure_out_has_elements()
        return self._out[-1]
    
    def _ensure_out_has_elements(self):
        # Transfere apenas se necessário
        if not self._out:
            if not self._in:
                raise IndexError("Queue vazia")
            
            # Transfere todos de uma vez
            self._out = self._in[::-1]  # Inverte
            self._in.clear()
```

## 🎯 Variações Avançadas

### 📊 **Priority Queue com Deque**
```python
class PriorityDeque:
    def __init__(self):
        self._high_priority = []  # Deque para alta prioridade
        self._normal_priority = []  # Deque para prioridade normal
    
    def enqueue_high(self, item):
        self._high_priority.append(item)
    
    def enqueue_normal(self, item):
        self._normal_priority.append(item)
    
    def dequeue(self):
        # Prioriza elementos de alta prioridade
        if self._high_priority:
            return self._high_priority.pop(0)
        elif self._normal_priority:
            return self._normal_priority.pop(0)
        else:
            raise IndexError("Queue vazia")
```

### 📊 **Bounded Queue**
```python
class BoundedQueue:
    def __init__(self, max_size):
        self.max_size = max_size
        self.queue = []
    
    def enqueue(self, item):
        if len(self.queue) >= self.max_size:
            # Remove o mais antigo se cheia
            self.queue.pop(0)
        self.queue.append(item)
    
    def dequeue(self):
        if self.is_empty():
            raise IndexError("Queue vazia")
        return self.queue.pop(0)
    
    def is_empty(self):
        return len(self.queue) == 0
```

## 💡 Dicas de Implementação

### 🎯 **Pontos-Chave**
- **📊 Escolha a implementação**: Baseada no caso de uso
- **🔄 Considere complexidade**: Amortizada vs pior caso
- **⚡ Otimize memória**: Para sistemas com restrições
- **📏 Controle capacidade**: Para circular queue

### 🔧 **Casos Especiais**
- **📊 Queue vazia**: Trate adequadamente
- **🔄 Queue cheia**: Para capacidades fixas
- **⚡ Transferência**: Para queue com stacks
- **📏 Wraparound**: Para circular queue

### 🎯 **Debugging**
- **📊 Verifique índices**: Para circular queue
- **🔄 Valide transferência**: Para queue com stacks
- **⚡ Teste wraparound**: Para circular queue
- **📏 Monitore memória**: Para implementações complexas 