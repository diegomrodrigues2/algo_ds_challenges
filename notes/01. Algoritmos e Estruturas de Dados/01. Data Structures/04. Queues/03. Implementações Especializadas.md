# ğŸ”„ ImplementaÃ§Ãµes Especializadas do Queue

## ğŸ¯ VisÃ£o Geral

ImplementaÃ§Ãµes especializadas resolvem problemas especÃ­ficos do queue bÃ¡sico, como a ineficiÃªncia do dequeue O(n) e limitaÃ§Ãµes de memÃ³ria. As mais importantes sÃ£o **Circular Queue** e **Queue com Duas Stacks**.

## ğŸ”„ Circular Queue

### ğŸŒŸ **O que Ã©?**
**Circular Queue** Ã© uma fila com **capacidade fixa** que reutiliza espaÃ§o vazio, evitando o problema de shift O(n) do queue bÃ¡sico.

### ğŸ“ **ImplementaÃ§Ã£o**
```python
class CircularQueue:
    def __init__(self, capacity):
        self.capacity = capacity
        self.data = [None] * capacity
        self.head = 0      # Ãndice do primeiro elemento
        self.tail = 0      # Ãndice do prÃ³ximo espaÃ§o vazio
        self.count = 0     # NÃºmero de elementos
    
    def enqueue(self, item):
        if self.is_full():
            raise OverflowError("Queue cheia")
        
        self.data[self.tail] = item
        self.tail = (self.tail + 1) % self.capacity
        self.count += 1
    
    def dequeue(self):
        if self.is_empty():
            raise IndexError("Queue vazia")
        
        item = self.data[self.head]
        self.head = (self.head + 1) % self.capacity
        self.count -= 1
        return item
    
    def front(self):
        if self.is_empty():
            raise IndexError("Queue vazia")
        return self.data[self.head]
    
    def is_empty(self):
        return self.count == 0
    
    def is_full(self):
        return self.count == self.capacity
    
    def size(self):
        return self.count
```

### ğŸ¯ **Exemplo Visual**
```
Capacidade: 5
Estado inicial: [None, None, None, None, None]
                â†‘
              Head/Tail

Enqueue(A): [A, None, None, None, None]
             â†‘  â†‘
           Head Tail

Enqueue(B): [A, B, None, None, None]
             â†‘     â†‘
           Head   Tail

Dequeue(): [None, B, None, None, None]
                â†‘  â†‘
              Head Tail

Enqueue(C): [None, B, C, None, None]
                â†‘     â†‘
              Head   Tail
```

### âš¡ **Vantagens**
- **ğŸ”„ O(1)**: Enqueue e dequeue
- **ğŸ’¾ Eficiente**: Reutiliza espaÃ§o
- **ğŸ“Š PrevisÃ­vel**: Capacidade fixa
- **âš¡ Sem shift**: NÃ£o move elementos

## ğŸ“¦ Queue com Duas Stacks

### ğŸŒŸ **O que Ã©?**
**Queue com Duas Stacks** implementa uma fila usando duas pilhas, convertendo LIFO em FIFO atravÃ©s de transferÃªncia entre stacks.

### ğŸ“ **ImplementaÃ§Ã£o**
```python
class QueueTwoStacks:
    def __init__(self):
        self._in = []   # Stack de entrada
        self._out = []  # Stack de saÃ­da
    
    def enqueue(self, item):
        # Sempre adiciona na stack de entrada
        self._in.append(item)
    
    def dequeue(self):
        # Se stack de saÃ­da estÃ¡ vazia, transfere da entrada
        if not self._out:
            if not self._in:
                raise IndexError("Queue vazia")
            
            # Transfere todos os elementos
            while self._in:
                self._out.append(self._in.pop())
        
        return self._out.pop()
    
    def front(self):
        # Similar ao dequeue, mas nÃ£o remove
        if not self._out:
            if not self._in:
                raise IndexError("Queue vazia")
            
            while self._in:
                self._out.append(self._in.pop())
        
        return self._out[-1]
    
    def is_empty(self):
        return not self._in and not self._out
    
    def size(self):
        return len(self._in) + len(self._out)
```

### ğŸ¯ **Exemplo Visual**
```
Enqueue(A): In: [A], Out: []
Enqueue(B): In: [A, B], Out: []
Enqueue(C): In: [A, B, C], Out: []

Dequeue(): 
  Passo 1: Transfere In â†’ Out
  In: [], Out: [C, B, A]
  Passo 2: Remove do Out
  In: [], Out: [C, B]
  Retorna: A

Dequeue(): In: [], Out: [C]
  Retorna: B
```

### âš¡ **AnÃ¡lise de Complexidade**
- **ğŸ“¤ Enqueue**: O(1) - sempre
- **ğŸ“¥ Dequeue**: O(1) amortizado - transferÃªncia rara
- **ğŸ‘€ Front**: O(1) amortizado
- **ğŸ’¾ MemÃ³ria**: O(n) - pode usar mais espaÃ§o

## ğŸ”„ Deque (Double-Ended Queue)

### ğŸŒŸ **O que Ã©?**
**Deque** permite inserÃ§Ã£o e remoÃ§Ã£o em **ambas as extremidades**, combinando funcionalidades de stack e queue.

### ğŸ“ **ImplementaÃ§Ã£o**
```python
class Deque:
    def __init__(self):
        self._data = []
    
    def push_front(self, item):
        # Adiciona no inÃ­cio
        self._data.insert(0, item)
    
    def push_back(self, item):
        # Adiciona no final
        self._data.append(item)
    
    def pop_front(self):
        # Remove do inÃ­cio
        if self.is_empty():
            raise IndexError("Deque vazio")
        return self._data.pop(0)
    
    def pop_back(self):
        # Remove do final
        if self.is_empty():
            raise IndexError("Deque vazio")
        return self._data.pop()
    
    def front(self):
        if self.is_empty():
            raise IndexError("Deque vazio")
        return self._data[0]
    
    def back(self):
        if self.is_empty():
            raise IndexError("Deque vazio")
        return self._data[-1]
    
    def is_empty(self):
        return len(self._data) == 0
    
    def size(self):
        return len(self._data)
```

### ğŸ¯ **OperaÃ§Ãµes do Deque**
| OperaÃ§Ã£o | DescriÃ§Ã£o | Complexidade |
|----------|-----------|--------------|
| **push_front** | Adiciona no inÃ­cio | O(n) |
| **push_back** | Adiciona no final | O(1) |
| **pop_front** | Remove do inÃ­cio | O(n) |
| **pop_back** | Remove do final | O(1) |
| **front** | Primeiro elemento | O(1) |
| **back** | Ãšltimo elemento | O(1) |

## âš¡ ImplementaÃ§Ãµes Otimizadas

### ğŸ”§ **Circular Queue Otimizada**
```python
class CircularQueueOptimized:
    def __init__(self, capacity):
        self.capacity = capacity
        self.data = [None] * capacity
        self.head = 0
        self.tail = 0
        self.count = 0
    
    def enqueue(self, item):
        if self.is_full():
            # Redimensiona se necessÃ¡rio
            self._resize()
        
        self.data[self.tail] = item
        self.tail = (self.tail + 1) % self.capacity
        self.count += 1
    
    def _resize(self):
        # Dobra a capacidade
        new_capacity = self.capacity * 2
        new_data = [None] * new_capacity
        
        # Copia elementos na ordem correta
        for i in range(self.count):
            new_data[i] = self.data[(self.head + i) % self.capacity]
        
        self.data = new_data
        self.capacity = new_capacity
        self.head = 0
        self.tail = self.count
```

### ğŸ”§ **Queue com Stacks Otimizada**
```python
class QueueTwoStacksOptimized:
    def __init__(self):
        self._in = []
        self._out = []
    
    def enqueue(self, item):
        self._in.append(item)
    
    def dequeue(self):
        self._ensure_out_has_elements()
        return self._out.pop()
    
    def front(self):
        self._ensure_out_has_elements()
        return self._out[-1]
    
    def _ensure_out_has_elements(self):
        # Transfere apenas se necessÃ¡rio
        if not self._out:
            if not self._in:
                raise IndexError("Queue vazia")
            
            # Transfere todos de uma vez
            self._out = self._in[::-1]  # Inverte
            self._in.clear()
```

## ğŸ¯ VariaÃ§Ãµes AvanÃ§adas

### ğŸ“Š **Priority Queue com Deque**
```python
class PriorityDeque:
    def __init__(self):
        self._high_priority = []  # Deque para alta prioridade
        self._normal_priority = []  # Deque para prioridade normal
    
    def enqueue_high(self, item):
        self._high_priority.append(item)
    
    def enqueue_normal(self, item):
        self._normal_priority.append(item)
    
    def dequeue(self):
        # Prioriza elementos de alta prioridade
        if self._high_priority:
            return self._high_priority.pop(0)
        elif self._normal_priority:
            return self._normal_priority.pop(0)
        else:
            raise IndexError("Queue vazia")
```

### ğŸ“Š **Bounded Queue**
```python
class BoundedQueue:
    def __init__(self, max_size):
        self.max_size = max_size
        self.queue = []
    
    def enqueue(self, item):
        if len(self.queue) >= self.max_size:
            # Remove o mais antigo se cheia
            self.queue.pop(0)
        self.queue.append(item)
    
    def dequeue(self):
        if self.is_empty():
            raise IndexError("Queue vazia")
        return self.queue.pop(0)
    
    def is_empty(self):
        return len(self.queue) == 0
```

## ğŸ’¡ Dicas de ImplementaÃ§Ã£o

### ğŸ¯ **Pontos-Chave**
- **ğŸ“Š Escolha a implementaÃ§Ã£o**: Baseada no caso de uso
- **ğŸ”„ Considere complexidade**: Amortizada vs pior caso
- **âš¡ Otimize memÃ³ria**: Para sistemas com restriÃ§Ãµes
- **ğŸ“ Controle capacidade**: Para circular queue

### ğŸ”§ **Casos Especiais**
- **ğŸ“Š Queue vazia**: Trate adequadamente
- **ğŸ”„ Queue cheia**: Para capacidades fixas
- **âš¡ TransferÃªncia**: Para queue com stacks
- **ğŸ“ Wraparound**: Para circular queue

### ğŸ¯ **Debugging**
- **ğŸ“Š Verifique Ã­ndices**: Para circular queue
- **ğŸ”„ Valide transferÃªncia**: Para queue com stacks
- **âš¡ Teste wraparound**: Para circular queue
- **ğŸ“ Monitore memÃ³ria**: Para implementaÃ§Ãµes complexas 