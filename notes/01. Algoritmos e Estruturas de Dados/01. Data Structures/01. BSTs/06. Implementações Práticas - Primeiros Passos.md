# ğŸš€ ImplementaÃ§Ãµes PrÃ¡ticas: Primeiros Passos

## ğŸ¯ Objetivo

Implementar as **operaÃ§Ãµes fundamentais** da BST que demonstram o poder da propriedade de eliminaÃ§Ã£o binÃ¡ria.

## ğŸ“ Desafio 1: Busca BST (`search_bst.py`)

### ğŸ¯ EstratÃ©gia de ImplementaÃ§Ã£o

**Algoritmo:**
1. **Compare** com raiz atual
2. **Elimine** metade da Ã¡rvore
3. **RecursÃ£o** na subÃ¡rvore apropriada

### ğŸ” PseudocÃ³digo Detalhado

```python
def search_bst(root, target):
    # Caso base: Ã¡rvore vazia
    if root is None:
        return None
    
    # Encontrou o valor
    if root.value == target:
        return root
    
    # Elimina subÃ¡rvore direita (target < root.value)
    if target < root.value:
        return search_bst(root.left, target)
    
    # Elimina subÃ¡rvore esquerda (target > root.value)
    return search_bst(root.right, target)
```

### âš¡ AnÃ¡lise de Complexidade

| CenÃ¡rio | Complexidade | ExplicaÃ§Ã£o |
|---------|--------------|------------|
| **Melhor Caso** | O(1) | Valor na raiz |
| **Caso MÃ©dio** | O(log n) | Ãrvore balanceada |
| **Pior Caso** | O(n) | Ãrvore degenerada |

### ğŸ§ª Casos de Teste Essenciais

```python
# Ãrvore de teste
#       8
#      / \
#     3   10
#    / \    \
#   1   6    14
#      / \
#     4   7

# âœ… Casos de sucesso
assert search_bst(root, 8) == root
assert search_bst(root, 6) == root.left.right
assert search_bst(root, 14) == root.right.right

# âŒ Casos de falha
assert search_bst(root, 5) is None
assert search_bst(root, 15) is None
```

## ğŸ“ Desafio 2: MÃ­nimo e MÃ¡ximo (`tree_min_max.py`)

### ğŸ¯ EstratÃ©gia de ImplementaÃ§Ã£o

**MÃ­nimo:** Siga sempre Ã  esquerda atÃ© nÃ£o poder mais
**MÃ¡ximo:** Siga sempre Ã  direita atÃ© nÃ£o poder mais

### ğŸ” PseudocÃ³digo Detalhado

```python
def tree_min(root):
    # Caso base: Ã¡rvore vazia
    if root is None:
        raise ValueError("Ãrvore vazia")
    
    # Siga sempre Ã  esquerda
    current = root
    while current.left is not None:
        current = current.left
    
    return current.value

def tree_max(root):
    # Caso base: Ã¡rvore vazia
    if root is None:
        raise ValueError("Ãrvore vazia")
    
    # Siga sempre Ã  direita
    current = root
    while current.right is not None:
        current = current.right
    
    return current.value
```

### âš¡ AnÃ¡lise de Complexidade

| OperaÃ§Ã£o | Complexidade | ExplicaÃ§Ã£o |
|----------|--------------|------------|
| **tree_min()** | O(h) | h = altura da Ã¡rvore |
| **tree_max()** | O(h) | h = altura da Ã¡rvore |

**Onde h = log n (balanceada) ou h = n (degenerada)**

### ğŸ§ª Casos de Teste Essenciais

```python
# Ãrvore de teste
#       8
#      / \
#     3   10
#    / \    \
#   1   6    14
#      / \
#     4   7

# âœ… Testes de mÃ­nimo
assert tree_min(root) == 1
assert tree_min(root.right) == 10

# âœ… Testes de mÃ¡ximo
assert tree_max(root) == 14
assert tree_max(root.left) == 7

# âŒ Casos de erro
assert tree_min(None)  # ValueError
assert tree_max(None)  # ValueError
```

## ğŸ”„ PadrÃµes de RecursÃ£o vs IteraÃ§Ã£o

### ğŸ“Š ComparaÃ§Ã£o de Abordagens

| Aspecto | RecursÃ£o | IteraÃ§Ã£o |
|---------|----------|----------|
| **Legibilidade** | ğŸ¯ Mais clara | ğŸ”§ Mais explÃ­cita |
| **Stack Space** | ğŸ“š O(h) | âš¡ O(1) |
| **Debugging** | ğŸ› Mais complexo | ğŸ” Mais fÃ¡cil |

### ğŸ¯ RecomendaÃ§Ã£o

**Para entrevistas:** Use **recursÃ£o** (mais elegante)
**Para produÃ§Ã£o:** Use **iteraÃ§Ã£o** (mais eficiente)

## ğŸš€ PrÃ³ximos Passos

ApÃ³s dominar estas operaÃ§Ãµes fundamentais:

1. **InserÃ§Ã£o BST** - Manter propriedade durante inserÃ§Ã£o
2. **RemoÃ§Ã£o BST** - Casos complexos de reorganizaÃ§Ã£o
3. **Traversal** - In-order, pre-order, post-order
4. **ValidaÃ§Ã£o** - Verificar se Ã© BST vÃ¡lida

## ğŸ’¡ Dicas de ImplementaÃ§Ã£o

### ğŸ¯ Estrutura do NÃ³

```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
```

### ğŸ” VerificaÃ§Ã£o de Propriedade BST

```python
def is_bst_property(node, min_val=float('-inf'), max_val=float('inf')):
    if node is None:
        return True
    
    # Verifica propriedade atual
    if not (min_val < node.value < max_val):
        return False
    
    # Verifica subÃ¡rvores
    return (is_bst_property(node.left, min_val, node.value) and
            is_bst_property(node.right, node.value, max_val))
```

**LiÃ§Ã£o:** A propriedade BST Ã© a **base** de todas as operaÃ§Ãµes eficientes 