# 🚀 Implementações Práticas: Primeiros Passos

## 🎯 Objetivo

Implementar as **operações fundamentais** da BST que demonstram o poder da propriedade de eliminação binária.

## 📝 Desafio 1: Busca BST (`search_bst.py`)

### 🎯 Estratégia de Implementação

**Algoritmo:**
1. **Compare** com raiz atual
2. **Elimine** metade da árvore
3. **Recursão** na subárvore apropriada

### 🔍 Pseudocódigo Detalhado

```python
def search_bst(root, target):
    # Caso base: árvore vazia
    if root is None:
        return None
    
    # Encontrou o valor
    if root.value == target:
        return root
    
    # Elimina subárvore direita (target < root.value)
    if target < root.value:
        return search_bst(root.left, target)
    
    # Elimina subárvore esquerda (target > root.value)
    return search_bst(root.right, target)
```

### ⚡ Análise de Complexidade

| Cenário | Complexidade | Explicação |
|---------|--------------|------------|
| **Melhor Caso** | O(1) | Valor na raiz |
| **Caso Médio** | O(log n) | Árvore balanceada |
| **Pior Caso** | O(n) | Árvore degenerada |

### 🧪 Casos de Teste Essenciais

```python
# Árvore de teste
#       8
#      / \
#     3   10
#    / \    \
#   1   6    14
#      / \
#     4   7

# ✅ Casos de sucesso
assert search_bst(root, 8) == root
assert search_bst(root, 6) == root.left.right
assert search_bst(root, 14) == root.right.right

# ❌ Casos de falha
assert search_bst(root, 5) is None
assert search_bst(root, 15) is None
```

## 📝 Desafio 2: Mínimo e Máximo (`tree_min_max.py`)

### 🎯 Estratégia de Implementação

**Mínimo:** Siga sempre à esquerda até não poder mais
**Máximo:** Siga sempre à direita até não poder mais

### 🔍 Pseudocódigo Detalhado

```python
def tree_min(root):
    # Caso base: árvore vazia
    if root is None:
        raise ValueError("Árvore vazia")
    
    # Siga sempre à esquerda
    current = root
    while current.left is not None:
        current = current.left
    
    return current.value

def tree_max(root):
    # Caso base: árvore vazia
    if root is None:
        raise ValueError("Árvore vazia")
    
    # Siga sempre à direita
    current = root
    while current.right is not None:
        current = current.right
    
    return current.value
```

### ⚡ Análise de Complexidade

| Operação | Complexidade | Explicação |
|----------|--------------|------------|
| **tree_min()** | O(h) | h = altura da árvore |
| **tree_max()** | O(h) | h = altura da árvore |

**Onde h = log n (balanceada) ou h = n (degenerada)**

### 🧪 Casos de Teste Essenciais

```python
# Árvore de teste
#       8
#      / \
#     3   10
#    / \    \
#   1   6    14
#      / \
#     4   7

# ✅ Testes de mínimo
assert tree_min(root) == 1
assert tree_min(root.right) == 10

# ✅ Testes de máximo
assert tree_max(root) == 14
assert tree_max(root.left) == 7

# ❌ Casos de erro
assert tree_min(None)  # ValueError
assert tree_max(None)  # ValueError
```

## 🔄 Padrões de Recursão vs Iteração

### 📊 Comparação de Abordagens

| Aspecto | Recursão | Iteração |
|---------|----------|----------|
| **Legibilidade** | 🎯 Mais clara | 🔧 Mais explícita |
| **Stack Space** | 📚 O(h) | ⚡ O(1) |
| **Debugging** | 🐛 Mais complexo | 🔍 Mais fácil |

### 🎯 Recomendação

**Para entrevistas:** Use **recursão** (mais elegante)
**Para produção:** Use **iteração** (mais eficiente)

## 🚀 Próximos Passos

Após dominar estas operações fundamentais:

1. **Inserção BST** - Manter propriedade durante inserção
2. **Remoção BST** - Casos complexos de reorganização
3. **Traversal** - In-order, pre-order, post-order
4. **Validação** - Verificar se é BST válida

## 💡 Dicas de Implementação

### 🎯 Estrutura do Nó

```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
```

### 🔍 Verificação de Propriedade BST

```python
def is_bst_property(node, min_val=float('-inf'), max_val=float('inf')):
    if node is None:
        return True
    
    # Verifica propriedade atual
    if not (min_val < node.value < max_val):
        return False
    
    # Verifica subárvores
    return (is_bst_property(node.left, min_val, node.value) and
            is_bst_property(node.right, node.value, max_val))
```

**Lição:** A propriedade BST é a **base** de todas as operações eficientes 