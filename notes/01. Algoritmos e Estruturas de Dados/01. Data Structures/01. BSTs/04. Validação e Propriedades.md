# ✅ Validação e Propriedades de BSTs

## 📋 Visão Geral

Uma **Binary Search Tree válida** deve obedecer a propriedade fundamental: para qualquer nó, todos os elementos da subárvore esquerda são menores que o nó, e todos os elementos da subárvore direita são maiores.


## 🎯 Propriedade Fundamental da BST

### 📝 Definição Formal
Para cada nó `N` na árvore:
- **Subárvore esquerda**: Todos os valores < `N.value`
- **Subárvore direita**: Todos os valores > `N.value`

### 🎨 Exemplo Visual
```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \
     4   7

Validação:
- Nó 8: esquerda (1,3,4,6,7) < 8 ✓, direita (10,14) > 8 ✓
- Nó 3: esquerda (1) < 3 ✓, direita (4,6,7) > 3 ✓
- Nó 10: esquerda vazia ✓, direita (14) > 10 ✓
```


## ❌ Exemplos de BSTs Inválidas

### 🐛 Problema 1: Valor Maior na Esquerda
```
       8
      / \
     3   10
    / \    \
   1   9    14  ← 9 > 8, mas está na subárvore esquerda!
      / \
     4   7
```

### 🐛 Problema 2: Valor Menor na Direita
```
       8
      / \
     3   10
    / \    \
   1   6    5  ← 5 < 8, mas está na subárvore direita!
      / \
     4   7
```


## 🔍 Algoritmos de Validação

### 📝 Método 1: Validação com Range (Recomendado)

```python
def is_valid_bst(root):
    def validate(node, min_val, max_val):
        if node is None:
            return True
        
        if (min_val is not None and node.value <= min_val) or \
           (max_val is not None and node.value >= max_val):
            return False
        
        return (
            validate(node.left, min_val, node.value) and 
            validate(node.right, node.value, max_val)
        )
    
    return validate(root, None, None)
```

### 🎨 Como Funciona
```
       8
      / \
     3   10
    / \    \
   1   6    14

Validação:
1. Nó 8: range (None, None) → valor 8 ✓
2. Nó 3: range (None, 8) → valor 3 ✓
3. Nó 1: range (None, 3) → valor 1 ✓
4. Nó 6: range (3, 8) → valor 6 ✓
5. Nó 10: range (8, None) → valor 10 ✓
6. Nó 14: range (10, None) → valor 14 ✓
```

### 📝 Método 2: In-order Traversal

```python
def is_valid_bst_inorder(root):
    def inorder_traversal(node):
        if node is None:
            return []
        return inorder_traversal(node.left) + [node.value] + inorder_traversal(node.right)
    
    values = inorder_traversal(root)
    return values == sorted(values)
```

### ⚠️ Limitações do Método In-order
- **Não detecta duplicatas** se a BST permitir valores iguais
- **Menos eficiente** para árvores grandes
- **Não para cedo** quando encontra invalidez


## 🚀 Otimizações e Variações

### 🔄 Validação Iterativa

```python
def is_valid_bst_iterative(root):
    if root is None:
        return True
    
    stack = [(root, None, None)]
    
    while stack:
        node, min_val, max_val = stack.pop()
        
        if (min_val is not None and node.value <= min_val) or \
           (max_val is not None and node.value >= max_val):
            return False
        
        if node.right:
            stack.append((node.right, node.value, max_val))
        if node.left:
            stack.append((node.left, min_val, node.value))
    
    return True
```

### 🔄 Validação com Early Termination

```python
def is_valid_bst_early(root):
    def validate(node, min_val, max_val):
        if node is None:
            return True
        
        if (min_val is not None and node.value <= min_val) or \
           (max_val is not None and node.value >= max_val):
            return False
        
        if not validate(node.left, min_val, node.value):
            return False
        
        return validate(node.right, node.value, max_val)
    
    return validate(root, None, None)
```


## 🎯 Casos Especiais

### 📍 BSTs com Valores Duplicados

```python
def is_valid_bst_with_duplicates(root):
    def validate(node, min_val, max_val):
        if node is None:
            return True
        
        if (min_val is not None and node.value < min_val) or \
           (max_val is not None and node.value > max_val):
            return False
        
        return (
            validate(node.left, min_val, node.value) and 
            validate(node.right, node.value, max_val)
        )
    
    return validate(root, None, None)
```

### 📍 BSTs com Valores Nulos

```python
def is_valid_bst_with_nulls(root):
    def validate(node, min_val, max_val):
        if node is None or node.value is None:
            return True
        
        if (min_val is not None and node.value <= min_val) or \
           (max_val is not None and node.value >= max_val):
            return False
        
        return (
            validate(node.left, min_val, node.value) and 
            validate(node.right, node.value, max_val)
        )
    
    return validate(root, None, None)
```


## 🎯 Propriedades Adicionais

### 🌟 Propriedade de Ordenação
```python
def get_sorted_values(root):
    """Retorna valores em ordem crescente (in-order traversal)"""
    def inorder(node):
        if node is None:
            return []
        return inorder(node.left) + [node.value] + inorder(node.right)
    
    return inorder(root)
```

### 🌟 Propriedade de Altura
```python
def is_balanced_bst(root):
    """Verifica se a BST está balanceada (altura das subárvores difere no máximo 1)"""
    def get_height(node):
        if node is None:
            return 0
        return max(get_height(node.left), get_height(node.right)) + 1
    
    def check_balance(node):
        if node is None:
            return True
        
        left_height = get_height(node.left)
        right_height = get_height(node.right)
        
        if abs(left_height - right_height) > 1:
            return False
        
        return check_balance(node.left) and check_balance(node.right)
    
    return check_balance(root)
```

### 🌟 Propriedade de Completude
```python
def is_complete_bst(root):
    """Verifica se a BST está completa (todos os níveis preenchidos, exceto o último)"""
    if root is None:
        return True
    
    queue = [root]
    found_null = False
    
    while queue:
        node = queue.pop(0)
        
        if node is None:
            found_null = True
        else:
            if found_null:
                return False
            queue.append(node.left)
            queue.append(node.right)
    
    return True
```


## 💡 Dicas Importantes

### 🎓 Para Implementação
1. **Use o método de range** para validação eficiente
2. **Teste casos extremos** (árvore vazia, nó único)
3. **Considere valores duplicados** na especificação
4. **Use early termination** para melhor performance

### 🔍 Para Debugging
1. **Desenhe a árvore** e marque os ranges
2. **Verifique cada nó** individualmente
3. **Teste com BSTs inválidas** conhecidas
4. **Use validação visual** para entender a estrutura

### 🚀 Para Otimização
1. **Range validation** é mais eficiente que in-order
2. **Early termination** evita processamento desnecessário
3. **Iterativo** pode ser melhor para árvores muito profundas
4. **Cache de resultados** para validações repetidas
