# âœ… ValidaÃ§Ã£o e Propriedades de BSTs

## ğŸ“‹ VisÃ£o Geral

Uma **Binary Search Tree vÃ¡lida** deve obedecer a propriedade fundamental: para qualquer nÃ³, todos os elementos da subÃ¡rvore esquerda sÃ£o menores que o nÃ³, e todos os elementos da subÃ¡rvore direita sÃ£o maiores.


## ğŸ¯ Propriedade Fundamental da BST

### ğŸ“ DefiniÃ§Ã£o Formal
Para cada nÃ³ `N` na Ã¡rvore:
- **SubÃ¡rvore esquerda**: Todos os valores < `N.value`
- **SubÃ¡rvore direita**: Todos os valores > `N.value`

### ğŸ¨ Exemplo Visual
```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \
     4   7

ValidaÃ§Ã£o:
- NÃ³ 8: esquerda (1,3,4,6,7) < 8 âœ“, direita (10,14) > 8 âœ“
- NÃ³ 3: esquerda (1) < 3 âœ“, direita (4,6,7) > 3 âœ“
- NÃ³ 10: esquerda vazia âœ“, direita (14) > 10 âœ“
```


## âŒ Exemplos de BSTs InvÃ¡lidas

### ğŸ› Problema 1: Valor Maior na Esquerda
```
       8
      / \
     3   10
    / \    \
   1   9    14  â† 9 > 8, mas estÃ¡ na subÃ¡rvore esquerda!
      / \
     4   7
```

### ğŸ› Problema 2: Valor Menor na Direita
```
       8
      / \
     3   10
    / \    \
   1   6    5  â† 5 < 8, mas estÃ¡ na subÃ¡rvore direita!
      / \
     4   7
```


## ğŸ” Algoritmos de ValidaÃ§Ã£o

### ğŸ“ MÃ©todo 1: ValidaÃ§Ã£o com Range (Recomendado)

```python
def is_valid_bst(root):
    def validate(node, min_val, max_val):
        if node is None:
            return True
        
        if (min_val is not None and node.value <= min_val) or \
           (max_val is not None and node.value >= max_val):
            return False
        
        return (
            validate(node.left, min_val, node.value) and 
            validate(node.right, node.value, max_val)
        )
    
    return validate(root, None, None)
```

### ğŸ¨ Como Funciona
```
       8
      / \
     3   10
    / \    \
   1   6    14

ValidaÃ§Ã£o:
1. NÃ³ 8: range (None, None) â†’ valor 8 âœ“
2. NÃ³ 3: range (None, 8) â†’ valor 3 âœ“
3. NÃ³ 1: range (None, 3) â†’ valor 1 âœ“
4. NÃ³ 6: range (3, 8) â†’ valor 6 âœ“
5. NÃ³ 10: range (8, None) â†’ valor 10 âœ“
6. NÃ³ 14: range (10, None) â†’ valor 14 âœ“
```

### ğŸ“ MÃ©todo 2: In-order Traversal

```python
def is_valid_bst_inorder(root):
    def inorder_traversal(node):
        if node is None:
            return []
        return inorder_traversal(node.left) + [node.value] + inorder_traversal(node.right)
    
    values = inorder_traversal(root)
    return values == sorted(values)
```

### âš ï¸ LimitaÃ§Ãµes do MÃ©todo In-order
- **NÃ£o detecta duplicatas** se a BST permitir valores iguais
- **Menos eficiente** para Ã¡rvores grandes
- **NÃ£o para cedo** quando encontra invalidez


## ğŸš€ OtimizaÃ§Ãµes e VariaÃ§Ãµes

### ğŸ”„ ValidaÃ§Ã£o Iterativa

```python
def is_valid_bst_iterative(root):
    if root is None:
        return True
    
    stack = [(root, None, None)]
    
    while stack:
        node, min_val, max_val = stack.pop()
        
        if (min_val is not None and node.value <= min_val) or \
           (max_val is not None and node.value >= max_val):
            return False
        
        if node.right:
            stack.append((node.right, node.value, max_val))
        if node.left:
            stack.append((node.left, min_val, node.value))
    
    return True
```

### ğŸ”„ ValidaÃ§Ã£o com Early Termination

```python
def is_valid_bst_early(root):
    def validate(node, min_val, max_val):
        if node is None:
            return True
        
        if (min_val is not None and node.value <= min_val) or \
           (max_val is not None and node.value >= max_val):
            return False
        
        if not validate(node.left, min_val, node.value):
            return False
        
        return validate(node.right, node.value, max_val)
    
    return validate(root, None, None)
```


## ğŸ¯ Casos Especiais

### ğŸ“ BSTs com Valores Duplicados

```python
def is_valid_bst_with_duplicates(root):
    def validate(node, min_val, max_val):
        if node is None:
            return True
        
        if (min_val is not None and node.value < min_val) or \
           (max_val is not None and node.value > max_val):
            return False
        
        return (
            validate(node.left, min_val, node.value) and 
            validate(node.right, node.value, max_val)
        )
    
    return validate(root, None, None)
```

### ğŸ“ BSTs com Valores Nulos

```python
def is_valid_bst_with_nulls(root):
    def validate(node, min_val, max_val):
        if node is None or node.value is None:
            return True
        
        if (min_val is not None and node.value <= min_val) or \
           (max_val is not None and node.value >= max_val):
            return False
        
        return (
            validate(node.left, min_val, node.value) and 
            validate(node.right, node.value, max_val)
        )
    
    return validate(root, None, None)
```


## ğŸ¯ Propriedades Adicionais

### ğŸŒŸ Propriedade de OrdenaÃ§Ã£o
```python
def get_sorted_values(root):
    """Retorna valores em ordem crescente (in-order traversal)"""
    def inorder(node):
        if node is None:
            return []
        return inorder(node.left) + [node.value] + inorder(node.right)
    
    return inorder(root)
```

### ğŸŒŸ Propriedade de Altura
```python
def is_balanced_bst(root):
    """Verifica se a BST estÃ¡ balanceada (altura das subÃ¡rvores difere no mÃ¡ximo 1)"""
    def get_height(node):
        if node is None:
            return 0
        return max(get_height(node.left), get_height(node.right)) + 1
    
    def check_balance(node):
        if node is None:
            return True
        
        left_height = get_height(node.left)
        right_height = get_height(node.right)
        
        if abs(left_height - right_height) > 1:
            return False
        
        return check_balance(node.left) and check_balance(node.right)
    
    return check_balance(root)
```

### ğŸŒŸ Propriedade de Completude
```python
def is_complete_bst(root):
    """Verifica se a BST estÃ¡ completa (todos os nÃ­veis preenchidos, exceto o Ãºltimo)"""
    if root is None:
        return True
    
    queue = [root]
    found_null = False
    
    while queue:
        node = queue.pop(0)
        
        if node is None:
            found_null = True
        else:
            if found_null:
                return False
            queue.append(node.left)
            queue.append(node.right)
    
    return True
```


## ğŸ’¡ Dicas Importantes

### ğŸ“ Para ImplementaÃ§Ã£o
1. **Use o mÃ©todo de range** para validaÃ§Ã£o eficiente
2. **Teste casos extremos** (Ã¡rvore vazia, nÃ³ Ãºnico)
3. **Considere valores duplicados** na especificaÃ§Ã£o
4. **Use early termination** para melhor performance

### ğŸ” Para Debugging
1. **Desenhe a Ã¡rvore** e marque os ranges
2. **Verifique cada nÃ³** individualmente
3. **Teste com BSTs invÃ¡lidas** conhecidas
4. **Use validaÃ§Ã£o visual** para entender a estrutura

### ğŸš€ Para OtimizaÃ§Ã£o
1. **Range validation** Ã© mais eficiente que in-order
2. **Early termination** evita processamento desnecessÃ¡rio
3. **Iterativo** pode ser melhor para Ã¡rvores muito profundas
4. **Cache de resultados** para validaÃ§Ãµes repetidas
