# ğŸŒ³ Traversal de Ãrvores BinÃ¡rias

## ğŸ“‹ VisÃ£o Geral

**Traversal** (ou percurso) Ã© o processo de visitar todos os nÃ³s de uma Ã¡rvore de forma sistemÃ¡tica. Existem **quatro tipos principais** de traversal.


## ğŸ¯ Os Quatro Tipos de Traversal

### 1ï¸âƒ£ **Pre-order (PrÃ©-ordem)**: Raiz â†’ Esquerda â†’ Direita
### 2ï¸âƒ£ **In-order (Em-ordem)**: Esquerda â†’ Raiz â†’ Direita  
### 3ï¸âƒ£ **Post-order (PÃ³s-ordem)**: Esquerda â†’ Direita â†’ Raiz
### 4ï¸âƒ£ **Level-order (Por nÃ­vel)**: NÃ­vel por nÃ­vel, da esquerda para direita


## ğŸ” Pre-order (PrÃ©-ordem)

### ğŸ“ Algoritmo
```python
def pre_ordem(root):
    if root is None:
        return []
    
    return (
        [root.value] +           # Visita a raiz
        pre_ordem(root.left) +   # Visita subÃ¡rvore esquerda
        pre_ordem(root.right)    # Visita subÃ¡rvore direita
    )
```

### ğŸ¨ Exemplo Visual
```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \
     4   7

Pre-order: [8, 3, 1, 6, 4, 7, 10, 14]
```

### ğŸ› ï¸ AplicaÃ§Ãµes
- **CÃ³pia de Ã¡rvores**: Preserva a estrutura
- **SerializaÃ§Ã£o**: Converter Ã¡rvore para string
- **ExpressÃµes prefixas**: NotaÃ§Ã£o polonesa


## ğŸ” In-order (Em-ordem)

### ğŸ“ Algoritmo
```python
def in_ordem(root):
    if root is None:
        return []
    
    return (
        in_ordem(root.left) +    # Visita subÃ¡rvore esquerda
        [root.value] +           # Visita a raiz
        in_ordem(root.right)     # Visita subÃ¡rvore direita
    )
```

### ğŸ¨ Exemplo Visual
```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \
     4   7

In-order: [1, 3, 4, 6, 7, 8, 10, 14]
```

### ğŸ› ï¸ AplicaÃ§Ãµes
- **BST ordenado**: Sempre retorna elementos em ordem crescente
- **ValidaÃ§Ã£o de BST**: Verificar se estÃ¡ ordenado
- **Busca binÃ¡ria**: Encontrar k-Ã©simo menor elemento


## ğŸ” Post-order (PÃ³s-ordem)

### ğŸ“ Algoritmo
```python
def pos_ordem(root):
    if root is None:
        return []
    
    return (
        pos_ordem(root.left) +   # Visita subÃ¡rvore esquerda
        pos_ordem(root.right) +  # Visita subÃ¡rvore direita
        [root.value]             # Visita a raiz
    )
```

### ğŸ¨ Exemplo Visual
```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \
     4   7

Post-order: [1, 4, 7, 6, 3, 14, 10, 8]
```

### ğŸ› ï¸ AplicaÃ§Ãµes
- **DeleÃ§Ã£o de Ã¡rvores**: Liberar memÃ³ria dos filhos antes da raiz
- **CÃ¡lculo de altura**: Processar filhos antes de calcular altura da raiz
- **ExpressÃµes postfixas**: NotaÃ§Ã£o polonesa reversa


## ğŸ” Level-order (Por nÃ­vel)

### ğŸ“ Algoritmo
```python
from collections import deque

def nivel_ordem(root):
    if root is None:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        result.append(node.value)
        
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    
    return result
```

### ğŸ¨ Exemplo Visual
```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \
     4   7

Level-order: [8, 3, 10, 1, 6, 14, 4, 7]

NÃ­veis:
NÃ­vel 0: [8]
NÃ­vel 1: [3, 10]
NÃ­vel 2: [1, 6, 14]
NÃ­vel 3: [4, 7]
```

### ğŸ› ï¸ AplicaÃ§Ãµes
- **Breadth-First Search (BFS)**: Busca em largura
- **Caminho mais curto**: Encontrar menor caminho entre nÃ³s
- **ImpressÃ£o de Ã¡rvores**: VisualizaÃ§Ã£o por nÃ­veis


## ğŸš€ ImplementaÃ§Ãµes Iterativas

### ğŸ”„ Pre-order Iterativo
```python
def pre_ordem_iterativo(root):
    if root is None:
        return []
    
    result = []
    stack = [root]
    
    while stack:
        node = stack.pop()
        result.append(node.value)
        
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    
    return result
```

### ğŸ”„ In-order Iterativo
```python
def in_ordem_iterativo(root):
    result = []
    stack = []
    current = root
    
    while current or stack:
        while current:
            stack.append(current)
            current = current.left
        
        current = stack.pop()
        result.append(current.value)
        current = current.right
    
    return result
```

### ğŸ”„ Post-order Iterativo
```python
def pos_ordem_iterativo(root):
    if root is None:
        return []
    
    result = []
    stack = [root]
    
    while stack:
        node = stack.pop()
        result.insert(0, node.value)
        
        if node.left:
            stack.append(node.left)
        if node.right:
            stack.append(node.right)
    
    return result
```


## ğŸ“Š ComparaÃ§Ã£o dos Traversals

| Traversal | Ordem | AplicaÃ§Ã£o Principal | Complexidade |
|-----------|-------|-------------------|--------------|
| **Pre-order** | Raiz â†’ Esq â†’ Dir | SerializaÃ§Ã£o | O(n) |
| **In-order** | Esq â†’ Raiz â†’ Dir | BST ordenado | O(n) |
| **Post-order** | Esq â†’ Dir â†’ Raiz | DeleÃ§Ã£o | O(n) |
| **Level-order** | Por nÃ­vel | BFS | O(n) |


## ğŸ¯ Propriedades Especiais

### ğŸŒŸ In-order em BST
```python
# Sempre retorna elementos ordenados
bst = create_bst([8, 3, 10, 1, 6, 14, 4, 7])
print(in_ordem(bst))  # [1, 3, 4, 6, 7, 8, 10, 14]
```

### ğŸŒŸ Pre-order para SerializaÃ§Ã£o
```python
def serialize_bst(root):
    if root is None:
        return "null"
    return f"{root.value},{serialize_bst(root.left)},{serialize_bst(root.right)}"
```

### ğŸŒŸ Post-order para DeleÃ§Ã£o
```python
def delete_tree(root):
    if root is None:
        return
    
    delete_tree(root.left)
    delete_tree(root.right)
    del root
```


## ğŸ§ª Exemplos PrÃ¡ticos

### ğŸ“ ValidaÃ§Ã£o de BST
```python
def is_valid_bst(root):
    def inorder_traversal(node):
        if node is None:
            return []
        return inorder_traversal(node.left) + [node.value] + inorder_traversal(node.right)
    
    values = inorder_traversal(root)
    return values == sorted(values)
```

### ğŸ“ CÃ¡lculo de Altura
```python
def tree_height(root):
    if root is None:
        return 0
    
    left_height = tree_height(root.left)
    right_height = tree_height(root.right)
    return max(left_height, right_height) + 1
```

### ğŸ“ Contagem de NÃ³s
```python
def count_nodes(root):
    if root is None:
        return 0
    
    return 1 + count_nodes(root.left) + count_nodes(root.right)
```


## ğŸ’¡ Dicas Importantes

### ğŸ“ Para ImplementaÃ§Ã£o
1. **Use recursÃ£o** para clareza (exceto level-order)
2. **Sempre teste Ã¡rvore vazia** e nÃ³ Ãºnico
3. **Considere versÃ£o iterativa** para Ã¡rvores muito profundas
4. **Mantenha consistÃªncia** na ordem de processamento

### ğŸ” Para Debugging
1. **Desenhe a Ã¡rvore** e marque a ordem de visita
2. **Use casos pequenos** para verificar a lÃ³gica
3. **Verifique casos especiais** (Ã¡rvore vazia, nÃ³ Ãºnico)
4. **Compare com implementaÃ§Ã£o iterativa** para validar

### ğŸš€ Para OtimizaÃ§Ã£o
1. **Level-order** Ã© naturalmente iterativo
2. **In-order** Ã© mais eficiente para BSTs
3. **Pre-order** Ã© bom para serializaÃ§Ã£o
4. **Post-order** Ã© ideal para deleÃ§Ã£o
