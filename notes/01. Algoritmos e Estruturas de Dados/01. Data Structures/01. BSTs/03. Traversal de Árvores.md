# 🌳 Traversal de Árvores Binárias

## 📋 Visão Geral

**Traversal** (ou percurso) é o processo de visitar todos os nós de uma árvore de forma sistemática. Existem **quatro tipos principais** de traversal.


## 🎯 Os Quatro Tipos de Traversal

### 1️⃣ **Pre-order (Pré-ordem)**: Raiz → Esquerda → Direita
### 2️⃣ **In-order (Em-ordem)**: Esquerda → Raiz → Direita  
### 3️⃣ **Post-order (Pós-ordem)**: Esquerda → Direita → Raiz
### 4️⃣ **Level-order (Por nível)**: Nível por nível, da esquerda para direita


## 🔍 Pre-order (Pré-ordem)

### 📝 Algoritmo
```python
def pre_ordem(root):
    if root is None:
        return []
    
    return (
        [root.value] +           # Visita a raiz
        pre_ordem(root.left) +   # Visita subárvore esquerda
        pre_ordem(root.right)    # Visita subárvore direita
    )
```

### 🎨 Exemplo Visual
```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \
     4   7

Pre-order: [8, 3, 1, 6, 4, 7, 10, 14]
```

### 🛠️ Aplicações
- **Cópia de árvores**: Preserva a estrutura
- **Serialização**: Converter árvore para string
- **Expressões prefixas**: Notação polonesa


## 🔍 In-order (Em-ordem)

### 📝 Algoritmo
```python
def in_ordem(root):
    if root is None:
        return []
    
    return (
        in_ordem(root.left) +    # Visita subárvore esquerda
        [root.value] +           # Visita a raiz
        in_ordem(root.right)     # Visita subárvore direita
    )
```

### 🎨 Exemplo Visual
```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \
     4   7

In-order: [1, 3, 4, 6, 7, 8, 10, 14]
```

### 🛠️ Aplicações
- **BST ordenado**: Sempre retorna elementos em ordem crescente
- **Validação de BST**: Verificar se está ordenado
- **Busca binária**: Encontrar k-ésimo menor elemento


## 🔍 Post-order (Pós-ordem)

### 📝 Algoritmo
```python
def pos_ordem(root):
    if root is None:
        return []
    
    return (
        pos_ordem(root.left) +   # Visita subárvore esquerda
        pos_ordem(root.right) +  # Visita subárvore direita
        [root.value]             # Visita a raiz
    )
```

### 🎨 Exemplo Visual
```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \
     4   7

Post-order: [1, 4, 7, 6, 3, 14, 10, 8]
```

### 🛠️ Aplicações
- **Deleção de árvores**: Liberar memória dos filhos antes da raiz
- **Cálculo de altura**: Processar filhos antes de calcular altura da raiz
- **Expressões postfixas**: Notação polonesa reversa


## 🔍 Level-order (Por nível)

### 📝 Algoritmo
```python
from collections import deque

def nivel_ordem(root):
    if root is None:
        return []
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        result.append(node.value)
        
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    
    return result
```

### 🎨 Exemplo Visual
```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \
     4   7

Level-order: [8, 3, 10, 1, 6, 14, 4, 7]

Níveis:
Nível 0: [8]
Nível 1: [3, 10]
Nível 2: [1, 6, 14]
Nível 3: [4, 7]
```

### 🛠️ Aplicações
- **Breadth-First Search (BFS)**: Busca em largura
- **Caminho mais curto**: Encontrar menor caminho entre nós
- **Impressão de árvores**: Visualização por níveis


## 🚀 Implementações Iterativas

### 🔄 Pre-order Iterativo
```python
def pre_ordem_iterativo(root):
    if root is None:
        return []
    
    result = []
    stack = [root]
    
    while stack:
        node = stack.pop()
        result.append(node.value)
        
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    
    return result
```

### 🔄 In-order Iterativo
```python
def in_ordem_iterativo(root):
    result = []
    stack = []
    current = root
    
    while current or stack:
        while current:
            stack.append(current)
            current = current.left
        
        current = stack.pop()
        result.append(current.value)
        current = current.right
    
    return result
```

### 🔄 Post-order Iterativo
```python
def pos_ordem_iterativo(root):
    if root is None:
        return []
    
    result = []
    stack = [root]
    
    while stack:
        node = stack.pop()
        result.insert(0, node.value)
        
        if node.left:
            stack.append(node.left)
        if node.right:
            stack.append(node.right)
    
    return result
```


## 📊 Comparação dos Traversals

| Traversal | Ordem | Aplicação Principal | Complexidade |
|-----------|-------|-------------------|--------------|
| **Pre-order** | Raiz → Esq → Dir | Serialização | O(n) |
| **In-order** | Esq → Raiz → Dir | BST ordenado | O(n) |
| **Post-order** | Esq → Dir → Raiz | Deleção | O(n) |
| **Level-order** | Por nível | BFS | O(n) |


## 🎯 Propriedades Especiais

### 🌟 In-order em BST
```python
# Sempre retorna elementos ordenados
bst = create_bst([8, 3, 10, 1, 6, 14, 4, 7])
print(in_ordem(bst))  # [1, 3, 4, 6, 7, 8, 10, 14]
```

### 🌟 Pre-order para Serialização
```python
def serialize_bst(root):
    if root is None:
        return "null"
    return f"{root.value},{serialize_bst(root.left)},{serialize_bst(root.right)}"
```

### 🌟 Post-order para Deleção
```python
def delete_tree(root):
    if root is None:
        return
    
    delete_tree(root.left)
    delete_tree(root.right)
    del root
```


## 🧪 Exemplos Práticos

### 📝 Validação de BST
```python
def is_valid_bst(root):
    def inorder_traversal(node):
        if node is None:
            return []
        return inorder_traversal(node.left) + [node.value] + inorder_traversal(node.right)
    
    values = inorder_traversal(root)
    return values == sorted(values)
```

### 📝 Cálculo de Altura
```python
def tree_height(root):
    if root is None:
        return 0
    
    left_height = tree_height(root.left)
    right_height = tree_height(root.right)
    return max(left_height, right_height) + 1
```

### 📝 Contagem de Nós
```python
def count_nodes(root):
    if root is None:
        return 0
    
    return 1 + count_nodes(root.left) + count_nodes(root.right)
```


## 💡 Dicas Importantes

### 🎓 Para Implementação
1. **Use recursão** para clareza (exceto level-order)
2. **Sempre teste árvore vazia** e nó único
3. **Considere versão iterativa** para árvores muito profundas
4. **Mantenha consistência** na ordem de processamento

### 🔍 Para Debugging
1. **Desenhe a árvore** e marque a ordem de visita
2. **Use casos pequenos** para verificar a lógica
3. **Verifique casos especiais** (árvore vazia, nó único)
4. **Compare com implementação iterativa** para validar

### 🚀 Para Otimização
1. **Level-order** é naturalmente iterativo
2. **In-order** é mais eficiente para BSTs
3. **Pre-order** é bom para serialização
4. **Post-order** é ideal para deleção
