# ğŸ” OperaÃ§Ãµes BÃ¡sicas em BSTs

## ğŸ“‹ VisÃ£o Geral

As **trÃªs operaÃ§Ãµes fundamentais** em uma Binary Search Tree sÃ£o:
- **ğŸ” Busca (Search)**
- **â• InserÃ§Ã£o (Insert)** 
- **ğŸ—‘ï¸ RemoÃ§Ã£o (Delete)**


## ğŸ” Busca em BST

### ğŸ“ Algoritmo
```python
def search_bst(root, target):
    if root is None:
        return None
    
    if root.value == target:
        return root
    
    if target < root.value:
        return search_bst(root.left, target)
    
    return search_bst(root.right, target)
```

### ğŸ¨ Exemplo Visual
```
       8
      / \
     3   10
    / \    \
   1   6    14
      / \
     4   7

Busca por 6:
1. ComeÃ§a em 8 â†’ 6 < 8 â†’ vai para esquerda
2. Chega em 3 â†’ 6 > 3 â†’ vai para direita  
3. Chega em 6 â†’ 6 == 6 â†’ ENCONTRADO! âœ…
```

### âš¡ Complexidade
- **Melhor caso**: O(1) - elemento na raiz
- **Caso mÃ©dio**: O(log n) - Ã¡rvore balanceada
- **Pior caso**: O(n) - Ã¡rvore desbalanceada


## â• InserÃ§Ã£o em BST

### ğŸ“ Algoritmo
```python
def insert_bst(root, value):
    if root is None:
        return TreeNode(value)
    
    if value < root.value:
        root.left = insert_bst(root.left, value)
    elif value > root.value:
        root.right = insert_bst(root.right, value)
    
    return root
```

### ğŸ¨ Exemplo Visual
```
Inserindo 5 na Ã¡rvore:

Antes:        Depois:
   8             8
  / \           / \
 3   10        3   10
/ \    \      / \    \
1   6    14  1   6    14
    / \          / \
   4   7        4   7
                    \
                     5  â† Nova folha
```


## ğŸ—‘ï¸ RemoÃ§Ã£o em BST

### ğŸ“ Algoritmo
```python
def delete_bst_node(root, key):
    if root is None:
        return root
    
    if key < root.value:
        root.left = delete_bst_node(root.left, key)
    elif key > root.value:
        root.right = delete_bst_node(root.right, key)
    else:
        # Caso 1: NÃ³ Ã© uma folha
        if root.left is None and root.right is None:
            return None
        
        # Caso 2: NÃ³ tem apenas um filho
        elif root.left is None:
            return root.right
        elif root.right is None:
            return root.left
        
        # Caso 3: NÃ³ tem dois filhos
        else:
            successor = find_min(root.right)
            root.value = successor.value
            root.right = delete_bst_node(root.right, successor.value)
    
    return root

def find_min(node):
    while node.left is not None:
        node = node.left
    return node
```

### ğŸ¨ Os TrÃªs Casos de RemoÃ§Ã£o

#### ğŸ“ Caso 1: NÃ³ Folha
```
Remover 7:
   8             8
  / \           / \
 3   10        3   10
/ \    \      / \    \
1   6    14  1   6    14
    / \          /
   4   7        4
```

#### ğŸ“ Caso 2: NÃ³ com Um Filho
```
Remover 10:
   8             8
  / \           / \
 3   10        3   14
/ \    \      / \
1   6    14  1   6
    / \          / \
   4   7        4   7
```

#### ğŸ“ Caso 3: NÃ³ com Dois Filhos
```
Remover 8:
   8             9
  / \           / \
 3   10        3   10
/ \    \      / \    \
1   6    14  1   6    14
    / \          / \
   4   7        4   7

EstratÃ©gia: Substituir pelo sucessor inorder (9)
```


## ğŸš€ ImplementaÃ§Ã£o Iterativa

### ğŸ”„ Busca Iterativa
```python
def search_bst_iterative(root, target):
    current = root
    
    while current is not None:
        if current.value == target:
            return current
        elif target < current.value:
            current = current.left
        else:
            current = current.right
    
    return None
```

### ğŸ”„ InserÃ§Ã£o Iterativa
```python
def insert_bst_iterative(root, value):
    if root is None:
        return TreeNode(value)
    
    current = root
    while True:
        if value < current.value:
            if current.left is None:
                current.left = TreeNode(value)
                break
            current = current.left
        elif value > current.value:
            if current.right is None:
                current.right = TreeNode(value)
                break
            current = current.right
        else:
            break
    
    return root
```


## ğŸ¯ Vantagens e Desvantagens

### âœ… Vantagens
- **Busca eficiente**: O(log n) no caso mÃ©dio
- **InserÃ§Ã£o simples**: Sempre O(log n)
- **Dados ordenados**: Traversal inorder dÃ¡ elementos ordenados
- **Flexibilidade**: FÃ¡cil de implementar e modificar

### âŒ Desvantagens
- **RemoÃ§Ã£o complexa**: MÃºltiplos casos para tratar
- **Desbalanceamento**: Performance pode degradar para O(n)
- **MemÃ³ria**: Overhead de ponteiros
- **NÃ£o Ã© cache-friendly**: Acesso aleatÃ³rio Ã  memÃ³ria
