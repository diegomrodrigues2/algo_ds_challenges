# 🔗 Linked Lists

## 🎯 Definição
**Lista encadeada** = estrutura baseada em nós conectados por ponteiros

### 🏗️ Estrutura
- **Nó**: `{item, next_pointer}`
- **Cabeça**: Ponteiro para primeiro nó
- **Ordem**: Definida pelos ponteiros `next`

## ⚡ Operações e Complexidade

| Operação | Complexidade | Descrição |
|----------|-------------|-----------|
| `insert_first(x)` | O(1) | Adiciona no início |
| `delete_first()` | O(1) | Remove do início |
| `get_at(i)` | O(i) | Percorre i nós |
| `set_at(i, x)` | O(i) | Percorre + modifica |
| `insert_at(i, x)` | O(i) | Percorre + insere |
| `delete_at(i)` | O(i) | Percorre + remove |

## ✅ Vantagens
- **🚀 Inserção/remoção**: O(1) no início
- **🔄 Flexibilidade**: Reordenação sem mover dados
- **📏 Crescimento dinâmico**: Sem realocação
- **💾 Alocação incremental**: Só aloca quando necessário

## ❌ Limitações
- **🐌 Acesso aleatório**: O(n) no pior caso
- **💾 Overhead**: Ponteiros ocupam memória extra
- **🔄 Cache-unfriendly**: Dados espalhados na memória
- **📐 Complexidade**: Mais difícil de implementar

## 🔧 Implementação Básica
```python
class Node:
    def __init__(self, item):
        self.item = item
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.length = 0
    
    def insert_first(self, x):
        new_node = Node(x)
        new_node.next = self.head
        self.head = new_node
        self.length += 1
    
    def get_at(self, i):
        current = self.head
        for _ in range(i):
            current = current.next
        return current.item
```

## 🎯 Otimizações

### 🏁 Tail Pointer
- **Adiciona**: Ponteiro para último nó
- **Benefício**: `insert_last()` e `get_last()` em O(1)
- **Custo**: Manter ponteiro atualizado

### 🔄 Doubly Linked List
- **Estrutura**: `{prev, item, next}`
- **Benefício**: `delete_last()` em O(1)
- **Custo**: Mais memória e complexidade

## 💡 Insights Teóricos
- **Modelo Word RAM**: Ponteiros = endereços de memória
- **Alocação dinâmica**: Cada nó = array de tamanho 2
- **Trade-off fundamental**: Flexibilidade vs velocidade de acesso
- **Complementaridade**: Arrays vs listas têm vantagens opostas 