# ğŸ”„ Dynamic Arrays

## ğŸ¯ DefiniÃ§Ã£o
**Array dinÃ¢mico** = array que cresce automaticamente mantendo acesso O(1)

### ğŸ—ï¸ EstratÃ©gia
- **Relaxa restriÃ§Ã£o**: `size â‰¥ n` (nÃ£o `size = n`)
- **Fator de crescimento**: `size = Î¸(n)`
- **EspaÃ§o extra**: Permite inserÃ§Ãµes sem realocaÃ§Ã£o

## âš¡ OperaÃ§Ãµes e Complexidade

| OperaÃ§Ã£o | Complexidade | Tipo |
|----------|-------------|------|
| `get_at(i)` | O(1) | Pior caso |
| `set_at(i, x)` | O(1) | Pior caso |
| `insert_last(x)` | O(1) | Amortizado |
| `delete_last()` | O(1) | Amortizado |
| `insert_at(i, x)` | O(n) | Pior caso |
| `delete_at(i)` | O(n) | Pior caso |

## ğŸ”§ EstratÃ©gia de Crescimento

### ğŸ“ˆ Fator de Crescimento
- **OpÃ§Ã£o 1**: `new_size = 2 Ã— old_size` (dobrar)
- **OpÃ§Ã£o 2**: `new_size = old_size + c` (adicionar constante)
- **Escolha**: Dobrar Ã© melhor (anÃ¡lise amortizada)

### ğŸ¯ Por que Dobrar?
- **Adicionar constante**: Ainda O(n) por operaÃ§Ã£o
- **Dobrar**: O(1) amortizado por operaÃ§Ã£o
- **IntuiÃ§Ã£o**: Raramente realoca, custo diluÃ­do

## ğŸ“Š AnÃ¡lise Amortizada

### ğŸ”¢ Custo de RealocaÃ§Ã£o
```
RealocaÃ§Ãµes: 1, 2, 4, 8, 16, 32, ...
Custo total: 1 + 2 + 4 + 8 + 16 + ... = 2^(log n) - 1 â‰ˆ n
```

### âš–ï¸ DefiniÃ§Ã£o Amortizada
- **OperaÃ§Ã£o amortizada**: MÃ©dia sobre sequÃªncia de operaÃ§Ãµes
- **k operaÃ§Ãµes**: Custo total â‰¤ k Ã— custo amortizado
- **Resultado**: `insert_last()` = O(1) amortizado

## ğŸ”§ ImplementaÃ§Ã£o
```python
class DynamicArray:
    def __init__(self):
        self.size = 1  # Tamanho do array
        self.length = 0  # NÃºmero de elementos
        self.data = [None] * self.size
    
    def insert_last(self, x):
        if self.length == self.size:
            # Realoca com fator 2
            new_size = 2 * self.size
            new_data = [None] * new_size
            for i in range(self.length):
                new_data[i] = self.data[i]
            self.data = new_data
            self.size = new_size
        
        self.data[self.length] = x
        self.length += 1
```

## âœ… Vantagens
- **ğŸš€ Acesso rÃ¡pido**: O(1) para `get_at/set_at`
- **ğŸ“ Crescimento automÃ¡tico**: Sem preocupaÃ§Ã£o com tamanho
- **ğŸ’¾ EficiÃªncia**: `insert_last()` O(1) amortizado
- **ğŸ”„ Cache-friendly**: Dados contÃ­guos quando possÃ­vel

## âŒ LimitaÃ§Ãµes
- **ğŸŒ InserÃ§Ã£o no meio**: O(n) devido ao deslocamento
- **ğŸ’¾ EspaÃ§o extra**: Pode usar atÃ© 2Ã— memÃ³ria
- **ğŸ“ˆ Picos de latÃªncia**: RealocaÃ§Ãµes ocasionais

## ğŸ¯ AplicaÃ§Ãµes PrÃ¡ticas
- **Python Lists**: ImplementaÃ§Ã£o exata desta estrutura
- **Vectors (C++)**: Mesmo conceito
- **ArrayList (Java)**: VariaÃ§Ã£o similar
- **Uso geral**: Estrutura padrÃ£o para sequÃªncias dinÃ¢micas

## ğŸ’¡ Insights TeÃ³ricos
- **Trade-off ideal**: Combina melhor dos dois mundos
- **AnÃ¡lise amortizada**: Ferramenta poderosa para estruturas dinÃ¢micas
- **Fator 2**: Escolha Ã³tima para crescimento exponencial
- **Modelo prÃ¡tico**: Base para muitas estruturas de dados modernas 