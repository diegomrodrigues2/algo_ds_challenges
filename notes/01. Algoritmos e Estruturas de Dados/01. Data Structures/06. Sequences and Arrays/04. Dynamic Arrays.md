# 🔄 Dynamic Arrays

## 🎯 Definição
**Array dinâmico** = array que cresce automaticamente mantendo acesso O(1)

### 🏗️ Estratégia
- **Relaxa restrição**: `size ≥ n` (não `size = n`)
- **Fator de crescimento**: `size = θ(n)`
- **Espaço extra**: Permite inserções sem realocação

## ⚡ Operações e Complexidade

| Operação | Complexidade | Tipo |
|----------|-------------|------|
| `get_at(i)` | O(1) | Pior caso |
| `set_at(i, x)` | O(1) | Pior caso |
| `insert_last(x)` | O(1) | Amortizado |
| `delete_last()` | O(1) | Amortizado |
| `insert_at(i, x)` | O(n) | Pior caso |
| `delete_at(i)` | O(n) | Pior caso |

## 🔧 Estratégia de Crescimento

### 📈 Fator de Crescimento
- **Opção 1**: `new_size = 2 × old_size` (dobrar)
- **Opção 2**: `new_size = old_size + c` (adicionar constante)
- **Escolha**: Dobrar é melhor (análise amortizada)

### 🎯 Por que Dobrar?
- **Adicionar constante**: Ainda O(n) por operação
- **Dobrar**: O(1) amortizado por operação
- **Intuição**: Raramente realoca, custo diluído

## 📊 Análise Amortizada

### 🔢 Custo de Realocação
```
Realocações: 1, 2, 4, 8, 16, 32, ...
Custo total: 1 + 2 + 4 + 8 + 16 + ... = 2^(log n) - 1 ≈ n
```

### ⚖️ Definição Amortizada
- **Operação amortizada**: Média sobre sequência de operações
- **k operações**: Custo total ≤ k × custo amortizado
- **Resultado**: `insert_last()` = O(1) amortizado

## 🔧 Implementação
```python
class DynamicArray:
    def __init__(self):
        self.size = 1  # Tamanho do array
        self.length = 0  # Número de elementos
        self.data = [None] * self.size
    
    def insert_last(self, x):
        if self.length == self.size:
            # Realoca com fator 2
            new_size = 2 * self.size
            new_data = [None] * new_size
            for i in range(self.length):
                new_data[i] = self.data[i]
            self.data = new_data
            self.size = new_size
        
        self.data[self.length] = x
        self.length += 1
```

## ✅ Vantagens
- **🚀 Acesso rápido**: O(1) para `get_at/set_at`
- **📏 Crescimento automático**: Sem preocupação com tamanho
- **💾 Eficiência**: `insert_last()` O(1) amortizado
- **🔄 Cache-friendly**: Dados contíguos quando possível

## ❌ Limitações
- **🐌 Inserção no meio**: O(n) devido ao deslocamento
- **💾 Espaço extra**: Pode usar até 2× memória
- **📈 Picos de latência**: Realocações ocasionais

## 🎯 Aplicações Práticas
- **Python Lists**: Implementação exata desta estrutura
- **Vectors (C++)**: Mesmo conceito
- **ArrayList (Java)**: Variação similar
- **Uso geral**: Estrutura padrão para sequências dinâmicas

## 💡 Insights Teóricos
- **Trade-off ideal**: Combina melhor dos dois mundos
- **Análise amortizada**: Ferramenta poderosa para estruturas dinâmicas
- **Fator 2**: Escolha ótima para crescimento exponencial
- **Modelo prático**: Base para muitas estruturas de dados modernas 