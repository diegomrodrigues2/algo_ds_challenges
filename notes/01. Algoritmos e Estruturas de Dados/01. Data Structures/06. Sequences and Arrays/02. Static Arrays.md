# 🔒 Static Arrays

## 🎯 Definição
**Array estático** = bloco contíguo de memória com tamanho fixo

### 🏗️ Implementação
- **Memória**: Bloco consecutivo de palavras
- **Acesso**: `array[i] = memory[base_address + i]`
- **Tamanho**: Fixo durante toda vida útil

## ⚡ Operações e Complexidade

| Operação | Complexidade | Descrição |
|----------|-------------|-----------|
| `build(x)` | O(n) | Aloca e inicializa array |
| `get_at(i)` | O(1) | Acesso direto por índice |
| `set_at(i, x)` | O(1) | Modificação direta |
| `length()` | O(1) | Retorna tamanho fixo |
| `iter()` | O(n) | Percorre todos elementos |

## ✅ Vantagens
- **🚀 Acesso rápido**: O(1) para qualquer posição
- **💾 Eficiência espacial**: Sem overhead de ponteiros
- **🔄 Cache-friendly**: Dados contíguos na memória
- **📐 Simplicidade**: Implementação direta

## ❌ Limitações
- **🔒 Tamanho fixo**: Não pode crescer/diminuir
- **📏 Pré-alocação**: Deve conhecer tamanho antecipadamente
- **🔄 Inserção/remoção**: Requer realocação completa

## 🎯 Casos de Uso
- **Dados imutáveis**: Tamanho conhecido a priori
- **Acesso aleatório**: Padrão de acesso uniforme
- **Performance crítica**: Quando velocidade é essencial
- **Memória limitada**: Sem overhead de estruturas dinâmicas

## 🔧 Implementação Prática
```python
# Conceitual - não existe em Python puro
class StaticArray:
    def __init__(self, size):
        self.size = size
        self.data = [None] * size  # Simula alocação estática
    
    def get_at(self, i):
        return self.data[i]
    
    def set_at(self, i, x):
        self.data[i] = x
```

## 💡 Insights Teóricos
- **Modelo Word RAM**: Base para análise de complexidade
- **Acesso constante**: Possível devido à contiguidade
- **Alocação linear**: Custo inevitável para criação 