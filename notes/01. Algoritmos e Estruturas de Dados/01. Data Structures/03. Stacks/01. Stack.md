# ðŸ“¦ Stack

## ðŸŽ¯ O que Ã© uma Stack?

**Stack** Ã© uma estrutura de dados linear que segue o princÃ­pio **LIFO** (Last In, First Out). Ã‰ como uma pilha de pratos onde o Ãºltimo prato colocado Ã© o primeiro a ser removido.

### ðŸŒŸ **Propriedade Fundamental**
```
LIFO: Last In, First Out
- Ãšltimo elemento inserido Ã© o primeiro a ser removido
- Acesso apenas ao elemento do topo
```

## ðŸ”„ Como Funciona

### ðŸ“Š **Analogia Simples**
> **Pilha de Pratos**: Como empilhar pratos - vocÃª coloca um prato no topo e sÃ³ pode pegar o prato do topo. O Ãºltimo prato colocado Ã© o primeiro a ser usado.

### ðŸŽ¯ **OperaÃ§Ãµes Principais**
1. **ðŸ“¤ Push**: Adiciona elemento no topo
2. **ðŸ“¥ Pop**: Remove elemento do topo
3. **ðŸ‘€ Peek/Top**: Visualiza elemento do topo
4. **ðŸ“ Size**: Retorna nÃºmero de elementos
5. **ðŸ” Empty**: Verifica se estÃ¡ vazia

## ðŸ“Š ImplementaÃ§Ã£o com Array

### ðŸŽ¯ **Estrutura BÃ¡sica**
```python
class Stack:
    def __init__(self):
        self._data = []
        self._size = 0
    
    def push(self, value):
        self._data.append(value)
        self._size += 1
    
    def pop(self):
        if self.is_empty():
            raise IndexError("Stack vazia")
        self._size -= 1
        return self._data.pop()
    
    def top(self):
        if self.is_empty():
            raise IndexError("Stack vazia")
        return self._data[-1]
    
    def size(self):
        return self._size
    
    def is_empty(self):
        return self._size == 0
```

### ðŸŽ¨ **RepresentaÃ§Ã£o Visual**
```
Stack: [A, B, C, D]
       â†‘
      Top

Push(E): [A, B, C, D, E]
              â†‘
             Top

Pop(): [A, B, C, D]
       â†‘
      Top
```

## âš¡ Complexidade das OperaÃ§Ãµes

### ðŸ“ˆ **AnÃ¡lise de Complexidade**
| OperaÃ§Ã£o | Complexidade | ExplicaÃ§Ã£o |
|----------|--------------|------------|
| **ðŸ“¤ Push** | O(1) | InserÃ§Ã£o no final do array |
| **ðŸ“¥ Pop** | O(1) | RemoÃ§Ã£o do final do array |
| **ðŸ‘€ Peek/Top** | O(1) | Acesso ao Ãºltimo elemento |
| **ðŸ“ Size** | O(1) | Contador mantido |
| **ðŸ” Empty** | O(1) | VerificaÃ§Ã£o de tamanho |

### ðŸ” **Por que O(1)?**
- **ðŸ“Š Array dinÃ¢mico**: Python lista cresce automaticamente
- **ðŸ”„ OperaÃ§Ãµes no final**: Sem necessidade de shift
- **âš¡ Acesso direto**: Ãndice conhecido (Ãºltimo)

## âœ… Vantagens vs âŒ Desvantagens

| Aspecto | âœ… Vantagem | âŒ Desvantagem |
|---------|-------------|----------------|
| **âš¡ Performance** | O(1) push/pop | Acesso limitado ao topo |
| **ðŸ’¾ MemÃ³ria** | Eficiente | Pode crescer dinamicamente |
| **ðŸ”„ Simplicidade** | FÃ¡cil de implementar | Funcionalidade limitada |
| **ðŸ“Š Flexibilidade** | Cresce automaticamente | NÃ£o permite acesso aleatÃ³rio |

## ðŸŽ¯ AplicaÃ§Ãµes PrÃ¡ticas

### ðŸ”§ **Sistemas de ComputaÃ§Ã£o**
- **ðŸ“ž Call Stack**: Gerenciamento de chamadas de funÃ§Ã£o
- **ðŸ”„ Undo/Redo**: Sistemas de desfazer/repetir
- **ðŸŒ Browser History**: NavegaÃ§Ã£o web
- **ðŸ“ Text Editor**: OperaÃ§Ãµes de ediÃ§Ã£o

### ðŸ“Š **Algoritmos**
- **ðŸ” Depth-First Search**: ExploraÃ§Ã£o de grafos
- **ðŸ“ Expression Parsing**: AnÃ¡lise de expressÃµes
- **ðŸ”„ Backtracking**: Busca com retorno
- **ðŸŽ¨ Tree Traversal**: Percursos em Ã¡rvores

### ðŸ—ï¸ **Sistemas Reais**
- **ðŸ“¦ Package Managers**: InstalaÃ§Ã£o de dependÃªncias
- **ðŸŽ® Game States**: Estados de jogo
- **ðŸ“Š Calculators**: AvaliaÃ§Ã£o de expressÃµes
- **ðŸ”§ Compilers**: AnÃ¡lise sintÃ¡tica

## ðŸ”„ Propriedades MatemÃ¡ticas

### ðŸ“Š **Invariantes**
- **ðŸ“ Tamanho**: Sempre nÃ£o-negativo
- **ðŸ”„ LIFO**: Ordem de remoÃ§Ã£o oposta Ã  inserÃ§Ã£o
- **ðŸ“¦ Capacidade**: Pode crescer indefinidamente

### ðŸŽ¯ **OperaÃ§Ãµes VÃ¡lidas**
```
Push â†’ Stack nÃ£o vazia
Pop â†’ Stack nÃ£o vazia
Peek â†’ Stack nÃ£o vazia
```

## ðŸ’¡ Dicas de ImplementaÃ§Ã£o

### ðŸŽ¯ **Pontos-Chave**
- **ðŸ“Š Use list**: ImplementaÃ§Ã£o mais simples
- **ðŸ”„ Controle tamanho**: Mantenha contador atualizado
- **âš¡ Verifique vazia**: Antes de pop/peek
- **ðŸ“ Otimize memÃ³ria**: Considere capacidade inicial

### ðŸ”§ **OtimizaÃ§Ãµes**
- **ðŸ“Š Pre-allocation**: Defina tamanho inicial se conhecido
- **ðŸ”„ Lazy deletion**: Marcar como deletado
- **âš¡ Memory pooling**: Reutilizar arrays
- **ðŸ“ Capacity management**: Controlar crescimento

## ðŸŽ¯ ComparaÃ§Ã£o com Outras Estruturas

| Estrutura | InserÃ§Ã£o | RemoÃ§Ã£o | Acesso | Propriedade |
|-----------|----------|---------|--------|-------------|
| **ðŸ“¦ Stack** | O(1) | O(1) | O(1) topo | LIFO |
| **ðŸ“Š Array** | O(1) | O(n) | O(1) | AleatÃ³rio |
| **ðŸ”„ Queue** | O(1) | O(1) | O(1) frente | FIFO |
| **ðŸ“¦ Deque** | O(1) | O(1) | O(1) | Ambos |

## ðŸ”„ VariaÃ§Ãµes Importantes

### ðŸ“Š **Stack com Capacidade Fixa**
```python
class FixedStack:
    def __init__(self, capacity):
        self._data = [None] * capacity
        self._top = -1
        self._capacity = capacity
    
    def push(self, value):
        if self._top >= self._capacity - 1:
            raise OverflowError("Stack cheia")
        self._top += 1
        self._data[self._top] = value
    
    def pop(self):
        if self.is_empty():
            raise IndexError("Stack vazia")
        value = self._data[self._top]
        self._top -= 1
        return value
```

### ðŸ”„ **Stack com Duas Pilhas**
```python
class TwoStacks:
    def __init__(self, capacity):
        self._data = [None] * capacity
        self._top1 = -1
        self._top2 = capacity
        self._capacity = capacity
    
    def push1(self, value):
        if self._top1 < self._top2 - 1:
            self._top1 += 1
            self._data[self._top1] = value
        else:
            raise OverflowError("Stack 1 cheia")
    
    def push2(self, value):
        if self._top1 < self._top2 - 1:
            self._top2 -= 1
            self._data[self._top2] = value
        else:
            raise OverflowError("Stack 2 cheia")
```

## ðŸ’¡ Dicas de Debugging

### ðŸŽ¯ **Problemas Comuns**
- **ðŸ“Š Stack underflow**: Pop em stack vazia
- **ðŸ”„ Stack overflow**: Push em stack cheia
- **âš¡ Memory leaks**: NÃ£o limpar referÃªncias
- **ðŸ“ Size mismatch**: Contador desatualizado

### ðŸ”§ **SoluÃ§Ãµes**
- **ðŸ“Š Sempre verificar**: Empty antes de pop/peek
- **ðŸ”„ Usar try/catch**: Para operaÃ§Ãµes crÃ­ticas
- **âš¡ Validar entrada**: Verificar parÃ¢metros
- **ðŸ“ Testar extremos**: Stack vazia, um elemento 