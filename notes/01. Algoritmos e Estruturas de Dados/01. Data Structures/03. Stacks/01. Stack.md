# 📦 Stack

## 🎯 O que é uma Stack?

**Stack** é uma estrutura de dados linear que segue o princípio **LIFO** (Last In, First Out). É como uma pilha de pratos onde o último prato colocado é o primeiro a ser removido.

### 🌟 **Propriedade Fundamental**
```
LIFO: Last In, First Out
- Último elemento inserido é o primeiro a ser removido
- Acesso apenas ao elemento do topo
```

## 🔄 Como Funciona

### 📊 **Analogia Simples**
> **Pilha de Pratos**: Como empilhar pratos - você coloca um prato no topo e só pode pegar o prato do topo. O último prato colocado é o primeiro a ser usado.

### 🎯 **Operações Principais**
1. **📤 Push**: Adiciona elemento no topo
2. **📥 Pop**: Remove elemento do topo
3. **👀 Peek/Top**: Visualiza elemento do topo
4. **📏 Size**: Retorna número de elementos
5. **🔍 Empty**: Verifica se está vazia

## 📊 Implementação com Array

### 🎯 **Estrutura Básica**
```python
class Stack:
    def __init__(self):
        self._data = []
        self._size = 0
    
    def push(self, value):
        self._data.append(value)
        self._size += 1
    
    def pop(self):
        if self.is_empty():
            raise IndexError("Stack vazia")
        self._size -= 1
        return self._data.pop()
    
    def top(self):
        if self.is_empty():
            raise IndexError("Stack vazia")
        return self._data[-1]
    
    def size(self):
        return self._size
    
    def is_empty(self):
        return self._size == 0
```

### 🎨 **Representação Visual**
```
Stack: [A, B, C, D]
       ↑
      Top

Push(E): [A, B, C, D, E]
              ↑
             Top

Pop(): [A, B, C, D]
       ↑
      Top
```

## ⚡ Complexidade das Operações

### 📈 **Análise de Complexidade**
| Operação | Complexidade | Explicação |
|----------|--------------|------------|
| **📤 Push** | O(1) | Inserção no final do array |
| **📥 Pop** | O(1) | Remoção do final do array |
| **👀 Peek/Top** | O(1) | Acesso ao último elemento |
| **📏 Size** | O(1) | Contador mantido |
| **🔍 Empty** | O(1) | Verificação de tamanho |

### 🔍 **Por que O(1)?**
- **📊 Array dinâmico**: Python lista cresce automaticamente
- **🔄 Operações no final**: Sem necessidade de shift
- **⚡ Acesso direto**: Índice conhecido (último)

## ✅ Vantagens vs ❌ Desvantagens

| Aspecto | ✅ Vantagem | ❌ Desvantagem |
|---------|-------------|----------------|
| **⚡ Performance** | O(1) push/pop | Acesso limitado ao topo |
| **💾 Memória** | Eficiente | Pode crescer dinamicamente |
| **🔄 Simplicidade** | Fácil de implementar | Funcionalidade limitada |
| **📊 Flexibilidade** | Cresce automaticamente | Não permite acesso aleatório |

## 🎯 Aplicações Práticas

### 🔧 **Sistemas de Computação**
- **📞 Call Stack**: Gerenciamento de chamadas de função
- **🔄 Undo/Redo**: Sistemas de desfazer/repetir
- **🌐 Browser History**: Navegação web
- **📝 Text Editor**: Operações de edição

### 📊 **Algoritmos**
- **🔍 Depth-First Search**: Exploração de grafos
- **📝 Expression Parsing**: Análise de expressões
- **🔄 Backtracking**: Busca com retorno
- **🎨 Tree Traversal**: Percursos em árvores

### 🏗️ **Sistemas Reais**
- **📦 Package Managers**: Instalação de dependências
- **🎮 Game States**: Estados de jogo
- **📊 Calculators**: Avaliação de expressões
- **🔧 Compilers**: Análise sintática

## 🔄 Propriedades Matemáticas

### 📊 **Invariantes**
- **📏 Tamanho**: Sempre não-negativo
- **🔄 LIFO**: Ordem de remoção oposta à inserção
- **📦 Capacidade**: Pode crescer indefinidamente

### 🎯 **Operações Válidas**
```
Push → Stack não vazia
Pop → Stack não vazia
Peek → Stack não vazia
```

## 💡 Dicas de Implementação

### 🎯 **Pontos-Chave**
- **📊 Use list**: Implementação mais simples
- **🔄 Controle tamanho**: Mantenha contador atualizado
- **⚡ Verifique vazia**: Antes de pop/peek
- **📏 Otimize memória**: Considere capacidade inicial

### 🔧 **Otimizações**
- **📊 Pre-allocation**: Defina tamanho inicial se conhecido
- **🔄 Lazy deletion**: Marcar como deletado
- **⚡ Memory pooling**: Reutilizar arrays
- **📏 Capacity management**: Controlar crescimento

## 🎯 Comparação com Outras Estruturas

| Estrutura | Inserção | Remoção | Acesso | Propriedade |
|-----------|----------|---------|--------|-------------|
| **📦 Stack** | O(1) | O(1) | O(1) topo | LIFO |
| **📊 Array** | O(1) | O(n) | O(1) | Aleatório |
| **🔄 Queue** | O(1) | O(1) | O(1) frente | FIFO |
| **📦 Deque** | O(1) | O(1) | O(1) | Ambos |

## 🔄 Variações Importantes

### 📊 **Stack com Capacidade Fixa**
```python
class FixedStack:
    def __init__(self, capacity):
        self._data = [None] * capacity
        self._top = -1
        self._capacity = capacity
    
    def push(self, value):
        if self._top >= self._capacity - 1:
            raise OverflowError("Stack cheia")
        self._top += 1
        self._data[self._top] = value
    
    def pop(self):
        if self.is_empty():
            raise IndexError("Stack vazia")
        value = self._data[self._top]
        self._top -= 1
        return value
```

### 🔄 **Stack com Duas Pilhas**
```python
class TwoStacks:
    def __init__(self, capacity):
        self._data = [None] * capacity
        self._top1 = -1
        self._top2 = capacity
        self._capacity = capacity
    
    def push1(self, value):
        if self._top1 < self._top2 - 1:
            self._top1 += 1
            self._data[self._top1] = value
        else:
            raise OverflowError("Stack 1 cheia")
    
    def push2(self, value):
        if self._top1 < self._top2 - 1:
            self._top2 -= 1
            self._data[self._top2] = value
        else:
            raise OverflowError("Stack 2 cheia")
```

## 💡 Dicas de Debugging

### 🎯 **Problemas Comuns**
- **📊 Stack underflow**: Pop em stack vazia
- **🔄 Stack overflow**: Push em stack cheia
- **⚡ Memory leaks**: Não limpar referências
- **📏 Size mismatch**: Contador desatualizado

### 🔧 **Soluções**
- **📊 Sempre verificar**: Empty antes de pop/peek
- **🔄 Usar try/catch**: Para operações críticas
- **⚡ Validar entrada**: Verificar parâmetros
- **📏 Testar extremos**: Stack vazia, um elemento 