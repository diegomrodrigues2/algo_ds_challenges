# ğŸ¨ Stacks Especializadas

## ğŸ¯ VisÃ£o Geral

Stacks especializadas estendem a funcionalidade bÃ¡sica para resolver problemas especÃ­ficos. As mais comuns sÃ£o **Min Stack**, **Max Stack** e suas variaÃ§Ãµes, que permitem acesso O(1) aos extremos.

## ğŸ“‰ Min Stack

### ğŸŒŸ **O que Ã©?**
**Min Stack** Ã© uma pilha que permite obter o **menor elemento** em tempo O(1), mantendo todas as operaÃ§Ãµes bÃ¡sicas de stack.

### ğŸ“ **ImplementaÃ§Ã£o com Stack Auxiliar**
```python
class MinStack:
    def __init__(self):
        self._stack = []      # Stack principal
        self._mins = []       # Stack de mÃ­nimos
    
    def push(self, value):
        # Adiciona na stack principal
        self._stack.append(value)
        
        # Atualiza stack de mÃ­nimos
        if not self._mins or value <= self._mins[-1]:
            self._mins.append(value)
    
    def pop(self):
        if not self._stack:
            raise IndexError("Stack vazia")
        
        # Remove da stack principal
        value = self._stack.pop()
        
        # Remove da stack de mÃ­nimos se necessÃ¡rio
        if value == self._mins[-1]:
            self._mins.pop()
        
        return value
    
    def top(self):
        if not self._stack:
            raise IndexError("Stack vazia")
        return self._stack[-1]
    
    def get_min(self):
        if not self._mins:
            raise IndexError("Stack vazia")
        return self._mins[-1]
```

### ğŸ¯ **Exemplo Visual**
```
Stack: [3, 5, 2, 1, 4]
Mins:  [3, 2, 1]

Push(0): Stack: [3, 5, 2, 1, 4, 0]
         Mins:  [3, 2, 1, 0]

Pop():  Stack: [3, 5, 2, 1, 4]  # Remove 0
        Mins:  [3, 2, 1]        # Remove 0 dos mins

Get_min(): 1 (menor atual)
```

## ğŸ“ˆ Max Stack

### ğŸŒŸ **O que Ã©?**
**Max Stack** Ã© similar ao Min Stack, mas mantÃ©m o **maior elemento** em O(1).

### ğŸ“ **ImplementaÃ§Ã£o**
```python
class MaxStack:
    def __init__(self):
        self._stack = []      # Stack principal
        self._maxs = []       # Stack de mÃ¡ximos
    
    def push(self, value):
        self._stack.append(value)
        
        # Atualiza stack de mÃ¡ximos
        if not self._maxs or value >= self._maxs[-1]:
            self._maxs.append(value)
    
    def pop(self):
        if not self._stack:
            raise IndexError("Stack vazia")
        
        value = self._stack.pop()
        
        # Remove da stack de mÃ¡ximos se necessÃ¡rio
        if value == self._maxs[-1]:
            self._maxs.pop()
        
        return value
    
    def get_max(self):
        if not self._maxs:
            raise IndexError("Stack vazia")
        return self._maxs[-1]
```

## ğŸ“Š Min-Max Stack

### ğŸŒŸ **O que Ã©?**
**Min-Max Stack** combina as funcionalidades de Min e Max Stack, permitindo acesso O(1) a ambos os extremos.

### ğŸ“ **ImplementaÃ§Ã£o**
```python
class MinMaxStack:
    def __init__(self):
        self._stack = []      # Stack principal
        self._mins = []       # Stack de mÃ­nimos
        self._maxs = []       # Stack de mÃ¡ximos
    
    def push(self, value):
        self._stack.append(value)
        
        # Atualiza stack de mÃ­nimos
        if not self._mins or value <= self._mins[-1]:
            self._mins.append(value)
        
        # Atualiza stack de mÃ¡ximos
        if not self._maxs or value >= self._maxs[-1]:
            self._maxs.append(value)
    
    def pop(self):
        if not self._stack:
            raise IndexError("Stack vazia")
        
        value = self._stack.pop()
        
        # Remove das stacks auxiliares se necessÃ¡rio
        if value == self._mins[-1]:
            self._mins.pop()
        
        if value == self._maxs[-1]:
            self._maxs.pop()
        
        return value
    
    def get_min(self):
        if not self._mins:
            raise IndexError("Stack vazia")
        return self._mins[-1]
    
    def get_max(self):
        if not self._maxs:
            raise IndexError("Stack vazia")
        return self._maxs[-1]
```

### ğŸ¯ **Vantagens**
- **âš¡ O(1)**: Todas as operaÃ§Ãµes
- **ğŸ“Š Completo**: Min e max simultaneamente
- **ğŸ”„ Simples**: FÃ¡cil de implementar
- **ğŸ’¾ Eficiente**: Pouco overhead

## ğŸ”— Pair Stack

### ğŸŒŸ **O que Ã©?**
**Pair Stack** armazena pares de valores, Ãºtil para problemas que precisam manter informaÃ§Ãµes relacionadas.

### ğŸ“ **ImplementaÃ§Ã£o**
```python
class PairStack:
    def __init__(self):
        self._data = []  # Lista de tuplas
    
    def push(self, pair):
        if not isinstance(pair, tuple) or len(pair) != 2:
            raise ValueError("Deve ser um par (tuple de 2 elementos)")
        
        self._data.append(pair)
    
    def pop(self):
        if self.is_empty():
            raise IndexError("Stack vazia")
        return self._data.pop()
    
    def top(self):
        if self.is_empty():
            raise IndexError("Stack vazia")
        return self._data[-1]
    
    def is_empty(self):
        return len(self._data) == 0
    
    def size(self):
        return len(self._data)
```

### ğŸ¯ **AplicaÃ§Ãµes**
- **ğŸ“Š Coordenadas**: (x, y) para grÃ¡ficos
- **ğŸ”„ Estados**: (valor, Ã­ndice) para algoritmos
- **ğŸ“ˆ EstatÃ­sticas**: (mÃ©dia, contador)
- **ğŸ¯ Problemas**: (soma, elemento) para otimizaÃ§Ãµes

## âš¡ ImplementaÃ§Ãµes Otimizadas

### ğŸ”§ **Min Stack com Valor Ãšnico**
```python
class MinStackOptimized:
    def __init__(self):
        self._stack = []
        self._min = None
    
    def push(self, value):
        if self._min is None or value <= self._min:
            # Guarda o mÃ­nimo anterior
            self._stack.append(self._min)
            self._min = value
        
        self._stack.append(value)
    
    def pop(self):
        if not self._stack:
            raise IndexError("Stack vazia")
        
        value = self._stack.pop()
        
        if value == self._min:
            # Restaura o mÃ­nimo anterior
            self._min = self._stack.pop()
        
        return value
    
    def get_min(self):
        return self._min
```

### ğŸ”§ **Min Stack com Contagem**
```python
class MinStackWithCount:
    def __init__(self):
        self._stack = []
        self._mins = []  # (valor, contagem)
    
    def push(self, value):
        self._stack.append(value)
        
        if not self._mins or value < self._mins[-1][0]:
            self._mins.append((value, 1))
        elif value == self._mins[-1][0]:
            self._mins[-1] = (value, self._mins[-1][1] + 1)
    
    def pop(self):
        if not self._stack:
            raise IndexError("Stack vazia")
        
        value = self._stack.pop()
        
        if value == self._mins[-1][0]:
            if self._mins[-1][1] == 1:
                self._mins.pop()
            else:
                self._mins[-1] = (value, self._mins[-1][1] - 1)
        
        return value
```

## ğŸ¯ VariaÃ§Ãµes AvanÃ§adas

### ğŸ“Š **Stack com MÃ©dia**
```python
class AverageStack:
    def __init__(self):
        self._stack = []
        self._sum = 0
        self._count = 0
    
    def push(self, value):
        self._stack.append(value)
        self._sum += value
        self._count += 1
    
    def pop(self):
        if not self._stack:
            raise IndexError("Stack vazia")
        
        value = self._stack.pop()
        self._sum -= value
        self._count -= 1
        return value
    
    def get_average(self):
        if self._count == 0:
            raise IndexError("Stack vazia")
        return self._sum / self._count
```

### ğŸ“Š **Stack com Moda**
```python
class ModeStack:
    def __init__(self):
        self._stack = []
        self._freq = {}  # FrequÃªncia de cada valor
        self._max_freq = 0
        self._mode = None
    
    def push(self, value):
        self._stack.append(value)
        
        # Atualiza frequÃªncia
        self._freq[value] = self._freq.get(value, 0) + 1
        
        # Atualiza moda
        if self._freq[value] > self._max_freq:
            self._max_freq = self._freq[value]
            self._mode = value
    
    def pop(self):
        if not self._stack:
            raise IndexError("Stack vazia")
        
        value = self._stack.pop()
        self._freq[value] -= 1
        
        # Recalcula moda se necessÃ¡rio
        if value == self._mode and self._freq[value] < self._max_freq:
            self._recalculate_mode()
        
        return value
    
    def get_mode(self):
        return self._mode
    
    def _recalculate_mode(self):
        self._max_freq = 0
        self._mode = None
        for value, freq in self._freq.items():
            if freq > self._max_freq:
                self._max_freq = freq
                self._mode = value
```

## ğŸ’¡ Dicas de ImplementaÃ§Ã£o

### ğŸ¯ **Pontos-Chave**
- **ğŸ“Š Mantenha sincronizaÃ§Ã£o**: Entre stack principal e auxiliar
- **ğŸ”„ Considere duplicatas**: Como tratar valores iguais
- **âš¡ Otimize memÃ³ria**: Evite redundÃ¢ncia desnecessÃ¡ria
- **ğŸ“ Valide entrada**: Verifique tipos e valores

### ğŸ”§ **OtimizaÃ§Ãµes**
- **ğŸ“Š Lazy updates**: Atualize apenas quando necessÃ¡rio
- **ğŸ”„ Batch operations**: Para mÃºltiplas inserÃ§Ãµes
- **âš¡ Memory pooling**: Reutilize estruturas
- **ğŸ“ Early termination**: Pare quando possÃ­vel

### ğŸ¯ **Casos Especiais**
- **ğŸ“Š Stack vazia**: Trate adequadamente
- **ğŸ”„ Valores iguais**: Defina polÃ­tica clara
- **âš¡ Overflow**: Para stacks com capacidade
- **ğŸ“ Underflow**: Para operaÃ§Ãµes de remoÃ§Ã£o 