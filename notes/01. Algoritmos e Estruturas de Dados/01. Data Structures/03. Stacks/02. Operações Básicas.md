# 🔄 Operações Básicas do Stack

## 🎯 Visão Geral

As operações básicas do stack garantem o funcionamento correto da estrutura **LIFO**. Cada operação tem complexidade O(1) e mantém as propriedades fundamentais da pilha.

## 📤 Push (Inserção)

### 🌟 **Processo de Inserção**
1. **📝 Adiciona elemento** no final do array
2. **📏 Incrementa contador** de tamanho
3. **✅ Retorna sucesso** (ou exceção se cheia)

### 📝 **Implementação**
```python
def push(self, value):
    # Adiciona no final (topo da pilha)
    self._data.append(value)
    self._size += 1

def push_with_capacity(self, value):
    # Versão com verificação de capacidade
    if self._size >= self._capacity:
        raise OverflowError("Stack cheia")
    
    self._data.append(value)
    self._size += 1
```

### 🎯 **Exemplo Visual**
```
Stack: [A, B, C]
       ↑
      Top

Push(D): [A, B, C, D]
              ↑
             Top

Push(E): [A, B, C, D, E]
                 ↑
                Top
```

## 📥 Pop (Remoção)

### 🌟 **Processo de Remoção**
1. **🔍 Verifica se vazia** (stack underflow)
2. **📝 Remove elemento** do final do array
3. **📏 Decrementa contador** de tamanho
4. **🔄 Retorna elemento** removido

### 📝 **Implementação**
```python
def pop(self):
    # Verifica se stack está vazia
    if self.is_empty():
        raise IndexError("Stack vazia")
    
    # Remove e retorna o último elemento
    self._size -= 1
    return self._data.pop()

def pop_with_validation(self):
    # Versão com validação adicional
    if self.is_empty():
        raise IndexError("Stack vazia")
    
    # Remove elemento
    value = self._data[self._size - 1]
    self._data[self._size - 1] = None  # Limpa referência
    self._size -= 1
    
    return value
```

### 🎯 **Exemplo Visual**
```
Stack: [A, B, C, D, E]
                 ↑
                Top

Pop(): [A, B, C, D]  # Retorna E
              ↑
             Top

Pop(): [A, B, C]     # Retorna D
       ↑
      Top
```

## 👀 Peek/Top (Visualização)

### 🌟 **Processo de Visualização**
1. **🔍 Verifica se vazia**
2. **👀 Retorna elemento** do topo sem remover
3. **✅ Mantém estrutura** inalterada

### 📝 **Implementação**
```python
def top(self):
    if self.is_empty():
        raise IndexError("Stack vazia")
    
    return self._data[-1]

def peek(self):
    # Alias para top()
    return self.top()

def top_with_index(self):
    # Versão que retorna índice também
    if self.is_empty():
        raise IndexError("Stack vazia")
    
    return self._data[self._size - 1], self._size - 1
```

### 🎯 **Exemplo Visual**
```
Stack: [A, B, C, D]
              ↑
             Top

Top(): Retorna D (stack inalterada)
      [A, B, C, D]
              ↑
             Top
```

## 📏 Size e Empty

### 📊 **Verificação de Tamanho**
```python
def size(self):
    return self._size

def is_empty(self):
    return self._size == 0

def is_full(self):
    return self._size >= self._capacity  # Para stack com capacidade
```

### 🎯 **Verificações Úteis**
```python
def has_elements(self):
    return not self.is_empty()

def can_push(self):
    return self._size < self._capacity  # Para stack com capacidade

def get_capacity(self):
    return self._capacity  # Para stack com capacidade
```

## 🔄 Implementações Iterativas

### 📊 **Iteração sobre Stack**
```python
def __iter__(self):
    # Itera do topo para a base
    for i in range(self._size - 1, -1, -1):
        yield self._data[i]

def iterate_from_base(self):
    # Itera da base para o topo
    for i in range(self._size):
        yield self._data[i]

def to_list(self):
    # Converte para lista (topo primeiro)
    return self._data[:self._size][::-1]
```

### 🎯 **Busca em Stack**
```python
def contains(self, value):
    # Busca linear O(n)
    for i in range(self._size):
        if self._data[i] == value:
            return True
    return False

def find(self, value):
    # Retorna posição (do topo)
    for i in range(self._size - 1, -1, -1):
        if self._data[i] == value:
            return self._size - 1 - i
    return -1
```

## 🔧 Operações Avançadas

### 🗑️ **Clear (Limpar)**
```python
def clear(self):
    # Limpa todos os elementos
    self._data.clear()
    self._size = 0

def clear_with_capacity(self):
    # Mantém capacidade, limpa elementos
    self._data = [None] * self._capacity
    self._size = 0
```

### 📊 **Copy (Cópia)**
```python
def copy(self):
    # Cria cópia superficial
    new_stack = Stack()
    new_stack._data = self._data.copy()
    new_stack._size = self._size
    return new_stack

def deep_copy(self):
    # Cria cópia profunda (se necessário)
    import copy
    new_stack = Stack()
    new_stack._data = copy.deepcopy(self._data)
    new_stack._size = self._size
    return new_stack
```

### 🔄 **Reverse (Inverter)**
```python
def reverse(self):
    # Inverte ordem dos elementos
    self._data[:self._size] = self._data[:self._size][::-1]

def reverse_without_mutation(self):
    # Retorna nova stack invertida
    new_stack = Stack()
    for item in self:
        new_stack.push(item)
    return new_stack
```

## ⚡ Otimizações

### 🔧 **Push Otimizado**
```python
def push_optimized(self, value):
    # Evita redimensionamento frequente
    if len(self._data) <= self._size:
        self._data.append(value)
    else:
        self._data[self._size] = value
    self._size += 1
```

### 🔧 **Pop Otimizado**
```python
def pop_optimized(self):
    if self.is_empty():
        raise IndexError("Stack vazia")
    
    self._size -= 1
    value = self._data[self._size]
    self._data[self._size] = None  # Ajuda GC
    
    # Redimensiona se muito vazio
    if self._size < len(self._data) // 4:
        self._data = self._data[:self._size]
    
    return value
```

## 💡 Dicas de Implementação

### 🎯 **Pontos-Chave**
- **📊 Sempre verifique vazia**: Antes de pop/peek
- **🔄 Mantenha contador**: Size sempre atualizado
- **⚡ Use append/pop**: Mais eficiente que insert/del
- **📏 Controle capacidade**: Para stacks fixas

### 🔧 **Casos Especiais**
- **📊 Stack vazia**: Trate adequadamente
- **🔄 Stack cheia**: Para capacidades fixas
- **⚡ Elemento único**: Caso base
- **📏 Capacidade zero**: Stack inválida

### 🎯 **Debugging**
- **📊 Valide índices**: Evite out-of-bounds
- **🔄 Verifique contadores**: Size consistente
- **⚡ Teste extremos**: Vazia, cheia, um elemento
- **📏 Trace operações**: Para encontrar bugs 