# ğŸ”„ OperaÃ§Ãµes BÃ¡sicas do Stack

## ğŸ¯ VisÃ£o Geral

As operaÃ§Ãµes bÃ¡sicas do stack garantem o funcionamento correto da estrutura **LIFO**. Cada operaÃ§Ã£o tem complexidade O(1) e mantÃ©m as propriedades fundamentais da pilha.

## ğŸ“¤ Push (InserÃ§Ã£o)

### ğŸŒŸ **Processo de InserÃ§Ã£o**
1. **ğŸ“ Adiciona elemento** no final do array
2. **ğŸ“ Incrementa contador** de tamanho
3. **âœ… Retorna sucesso** (ou exceÃ§Ã£o se cheia)

### ğŸ“ **ImplementaÃ§Ã£o**
```python
def push(self, value):
    # Adiciona no final (topo da pilha)
    self._data.append(value)
    self._size += 1

def push_with_capacity(self, value):
    # VersÃ£o com verificaÃ§Ã£o de capacidade
    if self._size >= self._capacity:
        raise OverflowError("Stack cheia")
    
    self._data.append(value)
    self._size += 1
```

### ğŸ¯ **Exemplo Visual**
```
Stack: [A, B, C]
       â†‘
      Top

Push(D): [A, B, C, D]
              â†‘
             Top

Push(E): [A, B, C, D, E]
                 â†‘
                Top
```

## ğŸ“¥ Pop (RemoÃ§Ã£o)

### ğŸŒŸ **Processo de RemoÃ§Ã£o**
1. **ğŸ” Verifica se vazia** (stack underflow)
2. **ğŸ“ Remove elemento** do final do array
3. **ğŸ“ Decrementa contador** de tamanho
4. **ğŸ”„ Retorna elemento** removido

### ğŸ“ **ImplementaÃ§Ã£o**
```python
def pop(self):
    # Verifica se stack estÃ¡ vazia
    if self.is_empty():
        raise IndexError("Stack vazia")
    
    # Remove e retorna o Ãºltimo elemento
    self._size -= 1
    return self._data.pop()

def pop_with_validation(self):
    # VersÃ£o com validaÃ§Ã£o adicional
    if self.is_empty():
        raise IndexError("Stack vazia")
    
    # Remove elemento
    value = self._data[self._size - 1]
    self._data[self._size - 1] = None  # Limpa referÃªncia
    self._size -= 1
    
    return value
```

### ğŸ¯ **Exemplo Visual**
```
Stack: [A, B, C, D, E]
                 â†‘
                Top

Pop(): [A, B, C, D]  # Retorna E
              â†‘
             Top

Pop(): [A, B, C]     # Retorna D
       â†‘
      Top
```

## ğŸ‘€ Peek/Top (VisualizaÃ§Ã£o)

### ğŸŒŸ **Processo de VisualizaÃ§Ã£o**
1. **ğŸ” Verifica se vazia**
2. **ğŸ‘€ Retorna elemento** do topo sem remover
3. **âœ… MantÃ©m estrutura** inalterada

### ğŸ“ **ImplementaÃ§Ã£o**
```python
def top(self):
    if self.is_empty():
        raise IndexError("Stack vazia")
    
    return self._data[-1]

def peek(self):
    # Alias para top()
    return self.top()

def top_with_index(self):
    # VersÃ£o que retorna Ã­ndice tambÃ©m
    if self.is_empty():
        raise IndexError("Stack vazia")
    
    return self._data[self._size - 1], self._size - 1
```

### ğŸ¯ **Exemplo Visual**
```
Stack: [A, B, C, D]
              â†‘
             Top

Top(): Retorna D (stack inalterada)
      [A, B, C, D]
              â†‘
             Top
```

## ğŸ“ Size e Empty

### ğŸ“Š **VerificaÃ§Ã£o de Tamanho**
```python
def size(self):
    return self._size

def is_empty(self):
    return self._size == 0

def is_full(self):
    return self._size >= self._capacity  # Para stack com capacidade
```

### ğŸ¯ **VerificaÃ§Ãµes Ãšteis**
```python
def has_elements(self):
    return not self.is_empty()

def can_push(self):
    return self._size < self._capacity  # Para stack com capacidade

def get_capacity(self):
    return self._capacity  # Para stack com capacidade
```

## ğŸ”„ ImplementaÃ§Ãµes Iterativas

### ğŸ“Š **IteraÃ§Ã£o sobre Stack**
```python
def __iter__(self):
    # Itera do topo para a base
    for i in range(self._size - 1, -1, -1):
        yield self._data[i]

def iterate_from_base(self):
    # Itera da base para o topo
    for i in range(self._size):
        yield self._data[i]

def to_list(self):
    # Converte para lista (topo primeiro)
    return self._data[:self._size][::-1]
```

### ğŸ¯ **Busca em Stack**
```python
def contains(self, value):
    # Busca linear O(n)
    for i in range(self._size):
        if self._data[i] == value:
            return True
    return False

def find(self, value):
    # Retorna posiÃ§Ã£o (do topo)
    for i in range(self._size - 1, -1, -1):
        if self._data[i] == value:
            return self._size - 1 - i
    return -1
```

## ğŸ”§ OperaÃ§Ãµes AvanÃ§adas

### ğŸ—‘ï¸ **Clear (Limpar)**
```python
def clear(self):
    # Limpa todos os elementos
    self._data.clear()
    self._size = 0

def clear_with_capacity(self):
    # MantÃ©m capacidade, limpa elementos
    self._data = [None] * self._capacity
    self._size = 0
```

### ğŸ“Š **Copy (CÃ³pia)**
```python
def copy(self):
    # Cria cÃ³pia superficial
    new_stack = Stack()
    new_stack._data = self._data.copy()
    new_stack._size = self._size
    return new_stack

def deep_copy(self):
    # Cria cÃ³pia profunda (se necessÃ¡rio)
    import copy
    new_stack = Stack()
    new_stack._data = copy.deepcopy(self._data)
    new_stack._size = self._size
    return new_stack
```

### ğŸ”„ **Reverse (Inverter)**
```python
def reverse(self):
    # Inverte ordem dos elementos
    self._data[:self._size] = self._data[:self._size][::-1]

def reverse_without_mutation(self):
    # Retorna nova stack invertida
    new_stack = Stack()
    for item in self:
        new_stack.push(item)
    return new_stack
```

## âš¡ OtimizaÃ§Ãµes

### ğŸ”§ **Push Otimizado**
```python
def push_optimized(self, value):
    # Evita redimensionamento frequente
    if len(self._data) <= self._size:
        self._data.append(value)
    else:
        self._data[self._size] = value
    self._size += 1
```

### ğŸ”§ **Pop Otimizado**
```python
def pop_optimized(self):
    if self.is_empty():
        raise IndexError("Stack vazia")
    
    self._size -= 1
    value = self._data[self._size]
    self._data[self._size] = None  # Ajuda GC
    
    # Redimensiona se muito vazio
    if self._size < len(self._data) // 4:
        self._data = self._data[:self._size]
    
    return value
```

## ğŸ’¡ Dicas de ImplementaÃ§Ã£o

### ğŸ¯ **Pontos-Chave**
- **ğŸ“Š Sempre verifique vazia**: Antes de pop/peek
- **ğŸ”„ Mantenha contador**: Size sempre atualizado
- **âš¡ Use append/pop**: Mais eficiente que insert/del
- **ğŸ“ Controle capacidade**: Para stacks fixas

### ğŸ”§ **Casos Especiais**
- **ğŸ“Š Stack vazia**: Trate adequadamente
- **ğŸ”„ Stack cheia**: Para capacidades fixas
- **âš¡ Elemento Ãºnico**: Caso base
- **ğŸ“ Capacidade zero**: Stack invÃ¡lida

### ğŸ¯ **Debugging**
- **ğŸ“Š Valide Ã­ndices**: Evite out-of-bounds
- **ğŸ”„ Verifique contadores**: Size consistente
- **âš¡ Teste extremos**: Vazia, cheia, um elemento
- **ğŸ“ Trace operaÃ§Ãµes**: Para encontrar bugs 