# 🔧 Aplicações Avançadas do Stack

## 🎯 Visão Geral

Stacks são fundamentais para **muitos algoritmos avançados** e problemas práticos. Sua propriedade LIFO torna-os ideais para parsing, backtracking e processamento de expressões.

## 🔍 Validação de Parênteses

### 🌟 **Problema**
Verificar se uma string de parênteses está **bem-formada** (balanceada).

### 📝 **Implementação**
```python
def is_valid_parentheses(expression):
    stack = []
    pairs = {')': '(', '}': '{', ']': '['}
    
    for char in expression:
        if char in '({[':
            # Abre parêntese - empilha
            stack.append(char)
        elif char in ')}]':
            # Fecha parêntese - verifica correspondência
            if not stack or stack.pop() != pairs[char]:
                return False
    
    # Verifica se todos foram fechados
    return len(stack) == 0
```

### 🎯 **Exemplo Visual**
```
Expressão: "((()))"
Stack: []
Passo 1: "(" → Stack: ['(']
Passo 2: "(" → Stack: ['(', '(']
Passo 3: "(" → Stack: ['(', '(', '(']
Passo 4: ")" → Stack: ['(', '(']
Passo 5: ")" → Stack: ['(']
Passo 6: ")" → Stack: []
Resultado: True (válida)
```

## 📊 Avaliação de Expressões Pós-Fixas

### 🌟 **Problema**
Calcular o resultado de uma expressão em **notação pós-fixa** (RPN - Reverse Polish Notation).

### 📝 **Implementação**
```python
def evaluate_postfix(expression):
    stack = []
    operators = {
        '+': lambda x, y: x + y,
        '-': lambda x, y: x - y,
        '*': lambda x, y: x * y,
        '/': lambda x, y: x // y  # Divisão inteira
    }
    
    for token in expression.split():
        if token.isdigit():
            # Operando - empilha
            stack.append(int(token))
        elif token in operators:
            # Operador - aplica aos dois últimos operandos
            if len(stack) < 2:
                raise ValueError("Expressão inválida")
            
            b = stack.pop()
            a = stack.pop()
            result = operators[token](a, b)
            stack.append(result)
        else:
            raise ValueError(f"Token inválido: {token}")
    
    if len(stack) != 1:
        raise ValueError("Expressão inválida")
    
    return stack[0]
```

### 🎯 **Exemplo**
```
Expressão: "3 4 + 2 *"
Stack: []
Passo 1: "3" → Stack: [3]
Passo 2: "4" → Stack: [3, 4]
Passo 3: "+" → Stack: [7] (3+4)
Passo 4: "2" → Stack: [7, 2]
Passo 5: "*" → Stack: [14] (7*2)
Resultado: 14
```

## 📦 Equal Stacks

### 🌟 **Problema**
Equalizar a altura de **três pilhas** removendo elementos do topo até que todas tenham a mesma altura.

### 📝 **Implementação**
```python
def equal_stacks(h1, h2, h3):
    # Calcula alturas cumulativas (da base para o topo)
    def get_cumulative_heights(heights):
        cumulative = [0]
        for height in reversed(heights):
            cumulative.append(cumulative[-1] + height)
        return set(cumulative)
    
    # Encontra alturas comuns
    heights1 = get_cumulative_heights(h1)
    heights2 = get_cumulative_heights(h2)
    heights3 = get_cumulative_heights(h3)
    
    # Intersecção das três alturas
    common_heights = heights1 & heights2 & heights3
    
    if not common_heights:
        return 0
    
    return max(common_heights)
```

### 🎯 **Exemplo**
```
h1: [3, 2, 1, 1, 1] → Alturas: [0, 1, 2, 3, 5, 8]
h2: [4, 3, 2]       → Alturas: [0, 2, 5, 9]
h3: [1, 1, 4, 1]    → Alturas: [0, 1, 2, 6, 7]

Alturas comuns: {0, 1, 2}
Altura máxima: 2
```

## 🔄 Conversão de Notações

### 🌟 **Infixa para Pós-Fixa**
```python
def infix_to_postfix(expression):
    stack = []
    output = []
    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}
    
    for char in expression:
        if char.isalnum():
            # Operando - adiciona à saída
            output.append(char)
        elif char == '(':
            # Abre parêntese - empilha
            stack.append(char)
        elif char == ')':
            # Fecha parêntese - desempilha até '('
            while stack and stack[-1] != '(':
                output.append(stack.pop())
            if stack:
                stack.pop()  # Remove '('
        elif char in precedence:
            # Operador - desempilha operadores com precedência maior/igual
            while (stack and stack[-1] != '(' and 
                   precedence.get(stack[-1], 0) >= precedence[char]):
                output.append(stack.pop())
            stack.append(char)
    
    # Desempilha operadores restantes
    while stack:
        output.append(stack.pop())
    
    return ' '.join(output)
```

### 🎯 **Exemplo**
```
Infixa: "3 + 4 * 2"
Stack: []
Output: []
Passo 1: "3" → Output: ['3']
Passo 2: "+" → Stack: ['+'], Output: ['3']
Passo 3: "4" → Output: ['3', '4']
Passo 4: "*" → Stack: ['+', '*'], Output: ['3', '4']
Passo 5: "2" → Output: ['3', '4', '2']
Final: Stack: [], Output: ['3', '4', '2', '*', '+']
Pós-fixa: "3 4 2 * +"
```

## 🎨 Algoritmos de Backtracking

### 🌟 **N-Queens com Stack**
```python
def solve_n_queens_stack(n):
    stack = [(0, [])]  # (row, queens_positions)
    solutions = []
    
    while stack:
        row, queens = stack.pop()
        
        if row == n:
            # Solução encontrada
            solutions.append(queens)
            continue
        
        for col in range(n):
            if is_safe(queens, row, col):
                new_queens = queens + [(row, col)]
                stack.append((row + 1, new_queens))
    
    return solutions

def is_safe(queens, row, col):
    for q_row, q_col in queens:
        if (q_col == col or 
            q_row + q_col == row + col or 
            q_row - q_col == row - col):
            return False
    return True
```

### 🌟 **Sudoku Solver com Stack**
```python
def solve_sudoku_stack(board):
    stack = [(0, 0, board)]  # (row, col, board_state)
    
    while stack:
        row, col, current_board = stack.pop()
        
        if row == 9:
            return current_board
        
        if current_board[row][col] != 0:
            # Célula já preenchida
            next_row, next_col = get_next_cell(row, col)
            stack.append((next_row, next_col, current_board))
            continue
        
        # Tenta números de 1 a 9
        for num in range(1, 10):
            if is_valid_move(current_board, row, col, num):
                new_board = [row[:] for row in current_board]
                new_board[row][col] = num
                next_row, next_col = get_next_cell(row, col)
                stack.append((next_row, next_col, new_board))
    
    return None
```

## 🔧 Monotonic Stack

### 🌟 **Próximo Maior Elemento**
```python
def next_greater_element(nums):
    stack = []
    result = [-1] * len(nums)
    
    for i, num in enumerate(nums):
        # Remove elementos menores do stack
        while stack and nums[stack[-1]] < num:
            result[stack.pop()] = num
        
        stack.append(i)
    
    return result
```

### 🎯 **Exemplo**
```
Array: [4, 5, 2, 10, 8]
Stack: []
Result: [-1, -1, -1, -1, -1]

Passo 1: i=0, num=4 → Stack: [0]
Passo 2: i=1, num=5 → Stack: [1] (remove 0, result[0]=5)
Passo 3: i=2, num=2 → Stack: [1, 2]
Passo 4: i=3, num=10 → Stack: [3] (remove 1,2, result[1,2]=10)
Passo 5: i=4, num=8 → Stack: [3, 4]

Resultado: [5, 10, 10, -1, -1]
```

## 💡 Dicas de Implementação

### 🎯 **Pontos-Chave**
- **📊 Sempre verifique vazia**: Antes de pop
- **🔄 Mantenha invariantes**: Propriedades da stack
- **⚡ Otimize operações**: Evite recálculos
- **📏 Controle memória**: Para problemas grandes

### 🔧 **Otimizações**
- **📊 Early termination**: Pare quando possível
- **🔄 Lazy evaluation**: Calcule apenas quando necessário
- **⚡ Memory pooling**: Reutilize estruturas
- **📏 Batch processing**: Para múltiplas operações

### 🎯 **Casos Especiais**
- **📊 Expressões vazias**: Trate adequadamente
- **🔄 Parênteses desbalanceados**: Detecte erros
- **⚡ Overflow/Underflow**: Para stacks fixas
- **📏 Caracteres inválidos**: Valide entrada 