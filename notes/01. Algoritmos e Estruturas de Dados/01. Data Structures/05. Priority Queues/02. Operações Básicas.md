# 🔄 Operações Básicas do Priority Queue

## 🎯 Visão Geral

As operações básicas do priority queue garantem o funcionamento correto da estrutura de heap. Cada operação mantém a **heap property** e tem complexidade específica.

## 📤 Insert (Inserção)

### 🌟 **Processo de Inserção**
1. **📝 Adiciona elemento** no final do array
2. **📏 Incrementa contador** de tamanho
3. **🔄 Bubble-up** para manter heap property
4. **✅ Retorna sucesso**

### 📝 **Implementação**
```python
def insert(self, value):
    # Adiciona no final
    self._data.append(value)
    self._size += 1
    
    # Faz bubble-up para manter heap property
    self._bubble_up(self._size - 1)

def _bubble_up(self, index):
    parent = (index - 1) // 2
    
    # Continua enquanto não chegou na raiz e pai > filho
    while parent >= 0 and self._data[parent] > self._data[index]:
        # Troca pai e filho
        self._data[parent], self._data[index] = self._data[index], self._data[parent]
        
        # Move para o pai
        index = parent
        parent = (index - 1) // 2

def insert_optimized(self, value):
    # Versão otimizada com early exit
    self._data.append(value)
    self._size += 1
    
    index = self._size - 1
    parent = (index - 1) // 2
    
    # Early exit se já está na posição correta
    while parent >= 0 and self._data[parent] > self._data[index]:
        self._data[parent], self._data[index] = self._data[index], self._data[parent]
        index = parent
        parent = (index - 1) // 2
```

### 🎯 **Exemplo Visual**
```
Heap: [1, 3, 2, 7, 4, 5]
      1
     / \
    3   2
   / \ / \
  7  4 5  _

Insert(0):
Passo 1: [1, 3, 2, 7, 4, 5, 0]
Passo 2: Bubble-up 0
         [1, 3, 0, 7, 4, 5, 2]
Passo 3: Bubble-up 0
         [0, 3, 1, 7, 4, 5, 2]

Resultado: [0, 3, 1, 7, 4, 5, 2]
           0
          / \
         3   1
        / \ / \
       7  4 5  2
```

## 📥 Extract Min/Max (Extração)

### 🌟 **Processo de Extração**
1. **🔍 Verifica se vazia** (heap underflow)
2. **📝 Remove raiz** (elemento de maior prioridade)
3. **🔄 Move último elemento** para a raiz
4. **📏 Decrementa contador** de tamanho
5. **⚡ Heapify** para manter heap property
6. **🔄 Retorna elemento** removido

### 📝 **Implementação**
```python
def extract_min(self):
    if self.is_empty():
        raise IndexError("Priority queue vazia")
    
    # Remove e retorna o mínimo (raiz)
    min_value = self._data[0]
    
    # Move último elemento para a raiz
    self._data[0] = self._data[self._size - 1]
    self._data.pop()
    self._size -= 1
    
    # Faz heapify se necessário
    if self._size > 0:
        self._heapify(0)
    
    return min_value

def _heapify(self, index):
    smallest = index
    left = 2 * index + 1
    right = 2 * index + 2
    
    # Encontra o menor entre pai e filhos
    if left < self._size and self._data[left] < self._data[smallest]:
        smallest = left
    
    if right < self._size and self._data[right] < self._data[smallest]:
        smallest = right
    
    # Se o menor não é o pai, troca e continua
    if smallest != index:
        self._data[index], self._data[smallest] = self._data[smallest], self._data[index]
        self._heapify(smallest)

def extract_min_iterative(self):
    if self.is_empty():
        raise IndexError("Priority queue vazia")
    
    min_value = self._data[0]
    self._data[0] = self._data[self._size - 1]
    self._data.pop()
    self._size -= 1
    
    if self._size > 0:
        self._heapify_iterative(0)
    
    return min_value

def _heapify_iterative(self, index):
    while True:
        smallest = index
        left = 2 * index + 1
        right = 2 * index + 2
        
        if left < self._size and self._data[left] < self._data[smallest]:
            smallest = left
        
        if right < self._size and self._data[right] < self._data[smallest]:
            smallest = right
        
        if smallest == index:
            break
        
        self._data[index], self._data[smallest] = self._data[smallest], self._data[index]
        index = smallest
```

### 🎯 **Exemplo Visual**
```
Heap: [0, 3, 1, 7, 4, 5, 2]
       0
      / \
     3   1
    / \ / \
   7  4 5  2

Extract Min:
Passo 1: Remove 0, move 2 para raiz
         [2, 3, 1, 7, 4, 5]
Passo 2: Heapify 2
         [1, 3, 2, 7, 4, 5]

Resultado: [1, 3, 2, 7, 4, 5]
           1
          / \
         3   2
        / \ / \
       7  4 5  _
```

## 👀 Peek Min/Max (Visualização)

### 🌟 **Processo de Visualização**
1. **🔍 Verifica se vazia**
2. **👀 Retorna raiz** sem remover
3. **✅ Mantém estrutura** inalterada

### 📝 **Implementação**
```python
def peek_min(self):
    if self.is_empty():
        raise IndexError("Priority queue vazia")
    
    return self._data[0]

def peek_max(self):
    if self.is_empty():
        raise IndexError("Priority queue vazia")
    
    return self._data[0]  # Para max heap

def peek_with_index(self):
    if self.is_empty():
        raise IndexError("Priority queue vazia")
    
    return self._data[0], 0
```

### 🎯 **Exemplo Visual**
```
Heap: [1, 3, 2, 7, 4, 5]
       1
      / \
     3   2
    / \ / \
   7  4 5  _

Peek Min(): Retorna 1 (heap inalterado)
            [1, 3, 2, 7, 4, 5]
```

## 📏 Size e Empty

### 📊 **Verificação de Tamanho**
```python
def size(self):
    return self._size

def is_empty(self):
    return self._size == 0

def capacity(self):
    return len(self._data)
```

### 🎯 **Verificações Úteis**
```python
def has_elements(self):
    return not self.is_empty()

def is_full(self):
    return self._size >= len(self._data)

def get_heap_array(self):
    return self._data[:self._size]
```

## 🔄 Build Heap (Construção)

### 🌟 **Processo de Construção**
1. **📝 Adiciona elementos** no array
2. **🔄 Heapify** de baixo para cima
3. **✅ Garante heap property**

### 📝 **Implementação**
```python
def build_heap(self, elements):
    # Adiciona todos os elementos
    self._data = elements.copy()
    self._size = len(elements)
    
    # Heapify de baixo para cima (otimizado)
    for i in range(self._size // 2 - 1, -1, -1):
        self._heapify(i)

def build_heap_optimized(self, elements):
    self._data = elements.copy()
    self._size = len(elements)
    
    # Começa do último pai não-folha
    last_parent = (self._size - 2) // 2
    
    for i in range(last_parent, -1, -1):
        self._heapify(i)

def heapify_bottom_up(self, elements):
    # Constrói heap inserindo um por um
    self._data = []
    self._size = 0
    
    for element in elements:
        self.insert(element)
```

### 🎯 **Exemplo Visual**
```
Array: [7, 3, 1, 5, 4, 2]

Build Heap:
Passo 1: [7, 3, 1, 5, 4, 2]
Passo 2: Heapify índices 2, 1, 0
Passo 3: [1, 3, 2, 5, 4, 7]

Resultado: [1, 3, 2, 5, 4, 7]
           1
          / \
         3   2
        / \ / \
       5  4 7  _
```

## 🔧 Operações Avançadas

### 🗑️ **Clear (Limpar)**
```python
def clear(self):
    self._data.clear()
    self._size = 0

def clear_with_capacity(self, capacity):
    self._data = [None] * capacity
    self._size = 0
```

### 📊 **Copy (Cópia)**
```python
def copy(self):
    new_pq = MinPriorityQueue()
    new_pq._data = self._data.copy()
    new_pq._size = self._size
    return new_pq

def deep_copy(self):
    import copy
    new_pq = MinPriorityQueue()
    new_pq._data = copy.deepcopy(self._data)
    new_pq._size = self._size
    return new_pq
```

### 🔄 **Merge (Mesclar)**
```python
def merge(self, other_pq):
    # Adiciona todos os elementos da outra priority queue
    for element in other_pq._data[:other_pq._size]:
        self.insert(element)

def merge_efficient(self, other_pq):
    # Versão mais eficiente para grandes heaps
    combined_data = self._data[:self._size] + other_pq._data[:other_pq._size]
    self.build_heap(combined_data)
```

## ⚡ Otimizações

### 🔧 **Insert Otimizado**
```python
def insert_optimized(self, value):
    # Evita redimensionamento frequente
    if len(self._data) <= self._size:
        self._data.append(value)
    else:
        self._data[self._size] = value
    
    self._size += 1
    self._bubble_up(self._size - 1)
```

### 🔧 **Heapify Otimizado**
```python
def heapify_optimized(self, index):
    # Versão com early exit
    while True:
        smallest = index
        left = 2 * index + 1
        right = 2 * index + 2
        
        if left < self._size and self._data[left] < self._data[smallest]:
            smallest = left
        
        if right < self._size and self._data[right] < self._data[smallest]:
            smallest = right
        
        if smallest == index:
            break  # Early exit
        
        self._data[index], self._data[smallest] = self._data[smallest], self._data[index]
        index = smallest
```

## 💡 Dicas de Implementação

### 🎯 **Pontos-Chave**
- **📊 Sempre verifique vazia**: Antes de extract/peek
- **🔄 Mantenha heap property**: Após cada operação
- **⚡ Use índices corretos**: Pai = (i-1)//2, Filhos = 2i+1, 2i+2
- **📏 Controle tamanho**: Mantenha contador atualizado

### 🔧 **Casos Especiais**
- **📊 Heap vazio**: Trate adequadamente
- **🔄 Heap com um elemento**: Caso base
- **⚡ Heap cheio**: Para capacidades fixas
- **📏 Elementos iguais**: Mantenha estabilidade

### 🎯 **Debugging**
- **📊 Valide heap property**: Após cada operação
- **🔄 Verifique índices**: Evite out-of-bounds
- **⚡ Teste extremos**: Heap vazio, um elemento
- **📏 Trace operações**: Para encontrar bugs 