# ğŸ”„ OperaÃ§Ãµes BÃ¡sicas do Priority Queue

## ğŸ¯ VisÃ£o Geral

As operaÃ§Ãµes bÃ¡sicas do priority queue garantem o funcionamento correto da estrutura de heap. Cada operaÃ§Ã£o mantÃ©m a **heap property** e tem complexidade especÃ­fica.

## ğŸ“¤ Insert (InserÃ§Ã£o)

### ğŸŒŸ **Processo de InserÃ§Ã£o**
1. **ğŸ“ Adiciona elemento** no final do array
2. **ğŸ“ Incrementa contador** de tamanho
3. **ğŸ”„ Bubble-up** para manter heap property
4. **âœ… Retorna sucesso**

### ğŸ“ **ImplementaÃ§Ã£o**
```python
def insert(self, value):
    # Adiciona no final
    self._data.append(value)
    self._size += 1
    
    # Faz bubble-up para manter heap property
    self._bubble_up(self._size - 1)

def _bubble_up(self, index):
    parent = (index - 1) // 2
    
    # Continua enquanto nÃ£o chegou na raiz e pai > filho
    while parent >= 0 and self._data[parent] > self._data[index]:
        # Troca pai e filho
        self._data[parent], self._data[index] = self._data[index], self._data[parent]
        
        # Move para o pai
        index = parent
        parent = (index - 1) // 2

def insert_optimized(self, value):
    # VersÃ£o otimizada com early exit
    self._data.append(value)
    self._size += 1
    
    index = self._size - 1
    parent = (index - 1) // 2
    
    # Early exit se jÃ¡ estÃ¡ na posiÃ§Ã£o correta
    while parent >= 0 and self._data[parent] > self._data[index]:
        self._data[parent], self._data[index] = self._data[index], self._data[parent]
        index = parent
        parent = (index - 1) // 2
```

### ğŸ¯ **Exemplo Visual**
```
Heap: [1, 3, 2, 7, 4, 5]
      1
     / \
    3   2
   / \ / \
  7  4 5  _

Insert(0):
Passo 1: [1, 3, 2, 7, 4, 5, 0]
Passo 2: Bubble-up 0
         [1, 3, 0, 7, 4, 5, 2]
Passo 3: Bubble-up 0
         [0, 3, 1, 7, 4, 5, 2]

Resultado: [0, 3, 1, 7, 4, 5, 2]
           0
          / \
         3   1
        / \ / \
       7  4 5  2
```

## ğŸ“¥ Extract Min/Max (ExtraÃ§Ã£o)

### ğŸŒŸ **Processo de ExtraÃ§Ã£o**
1. **ğŸ” Verifica se vazia** (heap underflow)
2. **ğŸ“ Remove raiz** (elemento de maior prioridade)
3. **ğŸ”„ Move Ãºltimo elemento** para a raiz
4. **ğŸ“ Decrementa contador** de tamanho
5. **âš¡ Heapify** para manter heap property
6. **ğŸ”„ Retorna elemento** removido

### ğŸ“ **ImplementaÃ§Ã£o**
```python
def extract_min(self):
    if self.is_empty():
        raise IndexError("Priority queue vazia")
    
    # Remove e retorna o mÃ­nimo (raiz)
    min_value = self._data[0]
    
    # Move Ãºltimo elemento para a raiz
    self._data[0] = self._data[self._size - 1]
    self._data.pop()
    self._size -= 1
    
    # Faz heapify se necessÃ¡rio
    if self._size > 0:
        self._heapify(0)
    
    return min_value

def _heapify(self, index):
    smallest = index
    left = 2 * index + 1
    right = 2 * index + 2
    
    # Encontra o menor entre pai e filhos
    if left < self._size and self._data[left] < self._data[smallest]:
        smallest = left
    
    if right < self._size and self._data[right] < self._data[smallest]:
        smallest = right
    
    # Se o menor nÃ£o Ã© o pai, troca e continua
    if smallest != index:
        self._data[index], self._data[smallest] = self._data[smallest], self._data[index]
        self._heapify(smallest)

def extract_min_iterative(self):
    if self.is_empty():
        raise IndexError("Priority queue vazia")
    
    min_value = self._data[0]
    self._data[0] = self._data[self._size - 1]
    self._data.pop()
    self._size -= 1
    
    if self._size > 0:
        self._heapify_iterative(0)
    
    return min_value

def _heapify_iterative(self, index):
    while True:
        smallest = index
        left = 2 * index + 1
        right = 2 * index + 2
        
        if left < self._size and self._data[left] < self._data[smallest]:
            smallest = left
        
        if right < self._size and self._data[right] < self._data[smallest]:
            smallest = right
        
        if smallest == index:
            break
        
        self._data[index], self._data[smallest] = self._data[smallest], self._data[index]
        index = smallest
```

### ğŸ¯ **Exemplo Visual**
```
Heap: [0, 3, 1, 7, 4, 5, 2]
       0
      / \
     3   1
    / \ / \
   7  4 5  2

Extract Min:
Passo 1: Remove 0, move 2 para raiz
         [2, 3, 1, 7, 4, 5]
Passo 2: Heapify 2
         [1, 3, 2, 7, 4, 5]

Resultado: [1, 3, 2, 7, 4, 5]
           1
          / \
         3   2
        / \ / \
       7  4 5  _
```

## ğŸ‘€ Peek Min/Max (VisualizaÃ§Ã£o)

### ğŸŒŸ **Processo de VisualizaÃ§Ã£o**
1. **ğŸ” Verifica se vazia**
2. **ğŸ‘€ Retorna raiz** sem remover
3. **âœ… MantÃ©m estrutura** inalterada

### ğŸ“ **ImplementaÃ§Ã£o**
```python
def peek_min(self):
    if self.is_empty():
        raise IndexError("Priority queue vazia")
    
    return self._data[0]

def peek_max(self):
    if self.is_empty():
        raise IndexError("Priority queue vazia")
    
    return self._data[0]  # Para max heap

def peek_with_index(self):
    if self.is_empty():
        raise IndexError("Priority queue vazia")
    
    return self._data[0], 0
```

### ğŸ¯ **Exemplo Visual**
```
Heap: [1, 3, 2, 7, 4, 5]
       1
      / \
     3   2
    / \ / \
   7  4 5  _

Peek Min(): Retorna 1 (heap inalterado)
            [1, 3, 2, 7, 4, 5]
```

## ğŸ“ Size e Empty

### ğŸ“Š **VerificaÃ§Ã£o de Tamanho**
```python
def size(self):
    return self._size

def is_empty(self):
    return self._size == 0

def capacity(self):
    return len(self._data)
```

### ğŸ¯ **VerificaÃ§Ãµes Ãšteis**
```python
def has_elements(self):
    return not self.is_empty()

def is_full(self):
    return self._size >= len(self._data)

def get_heap_array(self):
    return self._data[:self._size]
```

## ğŸ”„ Build Heap (ConstruÃ§Ã£o)

### ğŸŒŸ **Processo de ConstruÃ§Ã£o**
1. **ğŸ“ Adiciona elementos** no array
2. **ğŸ”„ Heapify** de baixo para cima
3. **âœ… Garante heap property**

### ğŸ“ **ImplementaÃ§Ã£o**
```python
def build_heap(self, elements):
    # Adiciona todos os elementos
    self._data = elements.copy()
    self._size = len(elements)
    
    # Heapify de baixo para cima (otimizado)
    for i in range(self._size // 2 - 1, -1, -1):
        self._heapify(i)

def build_heap_optimized(self, elements):
    self._data = elements.copy()
    self._size = len(elements)
    
    # ComeÃ§a do Ãºltimo pai nÃ£o-folha
    last_parent = (self._size - 2) // 2
    
    for i in range(last_parent, -1, -1):
        self._heapify(i)

def heapify_bottom_up(self, elements):
    # ConstrÃ³i heap inserindo um por um
    self._data = []
    self._size = 0
    
    for element in elements:
        self.insert(element)
```

### ğŸ¯ **Exemplo Visual**
```
Array: [7, 3, 1, 5, 4, 2]

Build Heap:
Passo 1: [7, 3, 1, 5, 4, 2]
Passo 2: Heapify Ã­ndices 2, 1, 0
Passo 3: [1, 3, 2, 5, 4, 7]

Resultado: [1, 3, 2, 5, 4, 7]
           1
          / \
         3   2
        / \ / \
       5  4 7  _
```

## ğŸ”§ OperaÃ§Ãµes AvanÃ§adas

### ğŸ—‘ï¸ **Clear (Limpar)**
```python
def clear(self):
    self._data.clear()
    self._size = 0

def clear_with_capacity(self, capacity):
    self._data = [None] * capacity
    self._size = 0
```

### ğŸ“Š **Copy (CÃ³pia)**
```python
def copy(self):
    new_pq = MinPriorityQueue()
    new_pq._data = self._data.copy()
    new_pq._size = self._size
    return new_pq

def deep_copy(self):
    import copy
    new_pq = MinPriorityQueue()
    new_pq._data = copy.deepcopy(self._data)
    new_pq._size = self._size
    return new_pq
```

### ğŸ”„ **Merge (Mesclar)**
```python
def merge(self, other_pq):
    # Adiciona todos os elementos da outra priority queue
    for element in other_pq._data[:other_pq._size]:
        self.insert(element)

def merge_efficient(self, other_pq):
    # VersÃ£o mais eficiente para grandes heaps
    combined_data = self._data[:self._size] + other_pq._data[:other_pq._size]
    self.build_heap(combined_data)
```

## âš¡ OtimizaÃ§Ãµes

### ğŸ”§ **Insert Otimizado**
```python
def insert_optimized(self, value):
    # Evita redimensionamento frequente
    if len(self._data) <= self._size:
        self._data.append(value)
    else:
        self._data[self._size] = value
    
    self._size += 1
    self._bubble_up(self._size - 1)
```

### ğŸ”§ **Heapify Otimizado**
```python
def heapify_optimized(self, index):
    # VersÃ£o com early exit
    while True:
        smallest = index
        left = 2 * index + 1
        right = 2 * index + 2
        
        if left < self._size and self._data[left] < self._data[smallest]:
            smallest = left
        
        if right < self._size and self._data[right] < self._data[smallest]:
            smallest = right
        
        if smallest == index:
            break  # Early exit
        
        self._data[index], self._data[smallest] = self._data[smallest], self._data[index]
        index = smallest
```

## ğŸ’¡ Dicas de ImplementaÃ§Ã£o

### ğŸ¯ **Pontos-Chave**
- **ğŸ“Š Sempre verifique vazia**: Antes de extract/peek
- **ğŸ”„ Mantenha heap property**: ApÃ³s cada operaÃ§Ã£o
- **âš¡ Use Ã­ndices corretos**: Pai = (i-1)//2, Filhos = 2i+1, 2i+2
- **ğŸ“ Controle tamanho**: Mantenha contador atualizado

### ğŸ”§ **Casos Especiais**
- **ğŸ“Š Heap vazio**: Trate adequadamente
- **ğŸ”„ Heap com um elemento**: Caso base
- **âš¡ Heap cheio**: Para capacidades fixas
- **ğŸ“ Elementos iguais**: Mantenha estabilidade

### ğŸ¯ **Debugging**
- **ğŸ“Š Valide heap property**: ApÃ³s cada operaÃ§Ã£o
- **ğŸ”„ Verifique Ã­ndices**: Evite out-of-bounds
- **âš¡ Teste extremos**: Heap vazio, um elemento
- **ğŸ“ Trace operaÃ§Ãµes**: Para encontrar bugs 