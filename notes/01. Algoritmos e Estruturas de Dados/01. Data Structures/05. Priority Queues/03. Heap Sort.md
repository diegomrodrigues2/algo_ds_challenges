# ğŸ”„ Heap Sort

## ğŸ¯ VisÃ£o Geral

**Heap Sort** Ã© um algoritmo de ordenaÃ§Ã£o baseado na estrutura de dados **heap**. Ele utiliza as propriedades do heap para ordenar elementos de forma eficiente, com complexidade O(n log n).

### ğŸŒŸ **Propriedade Fundamental**
```
Heap Sort: ConstrÃ³i um heap e extrai elementos em ordem
- Build Heap: O(n) - constrÃ³i heap do array
- Extract: O(log n) - remove elemento da raiz
- Total: O(n log n) - n extraÃ§Ãµes
```

## ğŸ”„ Como Funciona

### ğŸ“Š **Processo em Duas Fases**
1. **ğŸ—ï¸ Build Heap**: Converte array em heap
2. **ğŸ“¥ Extract**: Remove elementos da raiz em ordem

### ğŸ¯ **Algoritmo BÃ¡sico**
```python
def heap_sort(arr):
    n = len(arr)
    
    # Fase 1: ConstrÃ³i heap
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # Fase 2: Extrai elementos
    for i in range(n - 1, 0, -1):
        # Troca raiz (mÃ¡ximo) com Ãºltimo elemento
        arr[0], arr[i] = arr[i], arr[0]
        
        # Heapify na subÃ¡rvore reduzida
        heapify(arr, i, 0)

def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    # Encontra o maior entre pai e filhos
    if left < n and arr[left] > arr[largest]:
        largest = left
    
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    # Se o maior nÃ£o Ã© o pai, troca e continua
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
```

### ğŸ¨ **RepresentaÃ§Ã£o Visual**
```
Array: [7, 3, 1, 5, 4, 2]

Fase 1 - Build Heap:
Passo 1: [7, 3, 1, 5, 4, 2]
Passo 2: Heapify Ã­ndices 2, 1, 0
Passo 3: [7, 5, 2, 3, 4, 1]

Fase 2 - Extract:
Passo 1: Troca 7 e 1 â†’ [1, 5, 2, 3, 4, 7]
Passo 2: Heapify [1, 5, 2, 3, 4] â†’ [5, 4, 2, 3, 1]
Passo 3: Troca 5 e 1 â†’ [1, 4, 2, 3, 5, 7]
...
Resultado: [1, 2, 3, 4, 5, 7]
```

## âš¡ Complexidade

### ğŸ“ˆ **AnÃ¡lise de Complexidade**
| Fase | Complexidade | ExplicaÃ§Ã£o |
|------|--------------|------------|
| **ğŸ—ï¸ Build Heap** | O(n) | Heapify de baixo para cima |
| **ğŸ“¥ Extract** | O(n log n) | n extraÃ§Ãµes de O(log n) |
| **ğŸ”„ Total** | O(n log n) | Soma das duas fases |
| **ğŸ’¾ Space** | O(1) | OrdenaÃ§Ã£o in-place |

### ğŸ” **Por que Build Heap Ã© O(n)?**
- **ğŸ“Š Altura dos nÃ³s**: NÃ³s em nÃ­vel h precisam de h comparaÃ§Ãµes
- **ğŸ”„ NÃºmero de nÃ³s**: ~n/2^h nÃ³s no nÃ­vel h
- **âš¡ Soma total**: Î£(h * n/2^h) = O(n)
- **ğŸ“ Limite superior**: n * Î£(h/2^h) = n * 2 = O(n)

## ğŸ”§ ImplementaÃ§Ãµes

### ğŸ“ **Heap Sort ClÃ¡ssico**
```python
def heap_sort_classic(arr):
    n = len(arr)
    
    # ConstrÃ³i max heap
    for i in range(n // 2 - 1, -1, -1):
        heapify_max(arr, n, i)
    
    # Extrai elementos
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify_max(arr, i, 0)

def heapify_max(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and arr[left] > arr[largest]:
        largest = left
    
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify_max(arr, n, largest)
```

### ğŸ“ **Heap Sort com Min Heap**
```python
def heap_sort_min(arr):
    n = len(arr)
    
    # ConstrÃ³i min heap
    for i in range(n // 2 - 1, -1, -1):
        heapify_min(arr, n, i)
    
    # Extrai elementos (ordem decrescente)
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify_min(arr, i, 0)
    
    # Inverte para ordem crescente
    arr.reverse()

def heapify_min(arr, n, i):
    smallest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and arr[left] < arr[smallest]:
        smallest = left
    
    if right < n and arr[right] < arr[smallest]:
        smallest = right
    
    if smallest != i:
        arr[i], arr[smallest] = arr[smallest], arr[i]
        heapify_min(arr, n, smallest)
```

### ğŸ“ **Heap Sort Iterativo**
```python
def heap_sort_iterative(arr):
    n = len(arr)
    
    # Build heap iterativo
    for i in range(n // 2 - 1, -1, -1):
        heapify_iterative(arr, n, i)
    
    # Extract iterativo
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify_iterative(arr, i, 0)

def heapify_iterative(arr, n, i):
    while True:
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        
        if left < n and arr[left] > arr[largest]:
            largest = left
        
        if right < n and arr[right] > arr[largest]:
            largest = right
        
        if largest == i:
            break
        
        arr[i], arr[largest] = arr[largest], arr[i]
        i = largest
```

## ğŸ”„ VariaÃ§Ãµes AvanÃ§adas

### ğŸ“Š **Heap Sort com Custom Comparator**
```python
def heap_sort_custom(arr, key_func=None):
    if key_func is None:
        key_func = lambda x: x
    
    n = len(arr)
    
    # Build heap com funÃ§Ã£o customizada
    for i in range(n // 2 - 1, -1, -1):
        heapify_custom(arr, n, i, key_func)
    
    # Extract com funÃ§Ã£o customizada
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify_custom(arr, i, 0, key_func)

def heapify_custom(arr, n, i, key_func):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and key_func(arr[left]) > key_func(arr[largest]):
        largest = left
    
    if right < n and key_func(arr[right]) > key_func(arr[largest]):
        largest = right
    
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify_custom(arr, n, largest, key_func)

# Exemplo: ordenar por segundo elemento
points = [(1, 3), (2, 1), (3, 2)]
heap_sort_custom(points, key_func=lambda x: x[1])
# Resultado: [(2, 1), (3, 2), (1, 3)]
```

### ğŸ“Š **Heap Sort EstÃ¡vel**
```python
def heap_sort_stable(arr):
    # Cria tuplas com Ã­ndice original
    indexed_arr = [(arr[i], i) for i in range(len(arr))]
    
    n = len(indexed_arr)
    
    # Build heap
    for i in range(n // 2 - 1, -1, -1):
        heapify_stable(indexed_arr, n, i)
    
    # Extract
    for i in range(n - 1, 0, -1):
        indexed_arr[0], indexed_arr[i] = indexed_arr[i], indexed_arr[0]
        heapify_stable(indexed_arr, i, 0)
    
    # ReconstrÃ³i array original
    for i in range(n):
        arr[i] = indexed_arr[i][0]

def heapify_stable(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and arr[left] > arr[largest]:
        largest = left
    
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify_stable(arr, n, largest)
```

## âš¡ OtimizaÃ§Ãµes

### ğŸ”§ **Heap Sort Otimizado**
```python
def heap_sort_optimized(arr):
    n = len(arr)
    
    # Build heap otimizado
    for i in range(n // 2 - 1, -1, -1):
        heapify_optimized(arr, n, i)
    
    # Extract otimizado
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify_optimized(arr, i, 0)

def heapify_optimized(arr, n, i):
    # VersÃ£o com early exit
    while True:
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        
        if left < n and arr[left] > arr[largest]:
            largest = left
        
        if right < n and arr[right] > arr[largest]:
            largest = right
        
        if largest == i:
            break  # Early exit
        
        arr[i], arr[largest] = arr[largest], arr[i]
        i = largest
```

### ğŸ”§ **Heap Sort com Bottom-Up**
```python
def heap_sort_bottom_up(arr):
    n = len(arr)
    
    # Build heap bottom-up
    for i in range(n - 1, -1, -1):
        heapify_bottom_up(arr, n, i)
    
    # Extract
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify_bottom_up(arr, i, 0)

def heapify_bottom_up(arr, n, i):
    # VersÃ£o bottom-up mais eficiente
    while i < n // 2:
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        
        if left < n and arr[left] > arr[largest]:
            largest = left
        
        if right < n and arr[right] > arr[largest]:
            largest = right
        
        if largest == i:
            break
        
        arr[i], arr[largest] = arr[largest], arr[i]
        i = largest
```

## ğŸ¯ AplicaÃ§Ãµes PrÃ¡ticas

### ğŸ”§ **Sistemas de ComputaÃ§Ã£o**
- **ğŸ“Š Database**: OrdenaÃ§Ã£o de grandes datasets
- **ğŸ® Game Engines**: OrdenaÃ§Ã£o de objetos por distÃ¢ncia
- **ğŸŒ Networking**: OrdenaÃ§Ã£o de pacotes por prioridade
- **ğŸ”§ Operating Systems**: OrdenaÃ§Ã£o de processos

### ğŸ“Š **Algoritmos**
- **ğŸ” Top-k**: Encontrar k maiores/menores elementos
- **ğŸ“ External Sort**: OrdenaÃ§Ã£o de arquivos grandes
- **ğŸ¯ Priority Scheduling**: Agendamento por prioridade
- **ğŸ”„ Event Processing**: Processamento de eventos ordenados

## ğŸ’¡ Dicas de ImplementaÃ§Ã£o

### ğŸ¯ **Pontos-Chave**
- **ğŸ“Š Use max heap**: Para ordenaÃ§Ã£o crescente
- **ğŸ”„ Controle Ã­ndices**: Evite out-of-bounds
- **âš¡ Otimize heapify**: Use early exit
- **ğŸ“ Mantenha propriedades**: Heap property durante extraÃ§Ã£o

### ğŸ”§ **Casos Especiais**
- **ğŸ“Š Array vazio**: Trate adequadamente
- **ğŸ”„ Array com um elemento**: Caso base
- **âš¡ Elementos iguais**: Considere estabilidade
- **ğŸ“ Arrays grandes**: Use otimizaÃ§Ãµes

### ğŸ¯ **Debugging**
- **ğŸ“Š Valide heap property**: ApÃ³s build heap
- **ğŸ”„ Verifique Ã­ndices**: Durante heapify
- **âš¡ Teste extremos**: Array vazio, um elemento
- **ğŸ“ Trace operaÃ§Ãµes**: Para encontrar bugs 