# Universal Hashing

## üéØ Objetivo

Implementar **hashing com garantias te√≥ricas** usando fam√≠lias de fun√ß√µes hash universais, garantindo distribui√ß√£o uniforme independente dos dados de entrada.

## üîß Conceito B√°sico

### Problema do Hashing Determin√≠stico
```python
# Fun√ß√£o hash fixa pode ter colis√µes ruins
def bad_hash(key):
    return key % 100  # Se todas as chaves s√£o m√∫ltiplos de 100

# Exemplo: chaves [100, 200, 300, 400] ‚Üí todas v√£o para √≠ndice 0
```

### Solu√ß√£o: Hashing Universal
- **Escolha aleat√≥ria**: Fun√ß√£o hash selecionada aleatoriamente
- **Fam√≠lia de fun√ß√µes**: Conjunto de fun√ß√µes hash poss√≠veis
- **Garantias te√≥ricas**: Performance independente dos dados

## üßÆ Fam√≠lia Universal de Hash

### Defini√ß√£o Matem√°tica
Uma fam√≠lia de fun√ß√µes hash **H** √© **universal** se:

```
Para quaisquer chaves distintas k‚ÇÅ, k‚ÇÇ ‚àà U:
Pr[h(k‚ÇÅ) = h(k‚ÇÇ)] ‚â§ 1/m
```

Onde:
- **h**: fun√ß√£o escolhida aleatoriamente de H
- **m**: tamanho da tabela hash
- **U**: universo de chaves

### Fun√ß√£o Universal (Divis√£o)
```python
def universal_hash(key, a, b, p, m):
    """
    h_ab(k) = ((a * k + b) mod p) mod m
    
    Onde:
    - a, b: par√¢metros aleat√≥rios
    - p: primo > u (tamanho do universo)
    - m: tamanho da tabela hash
    """
    return ((a * key + b) % p) % m
```

### Par√¢metros
```python
# Restri√ß√µes para universalidade
p > u          # Primo maior que o universo
a ‚àà [1, p-1]   # a ‚â† 0
b ‚àà [0, p-1]   # b pode ser 0
```

## üìä An√°lise de Performance

### Comprimento Esperado das Cadeias
Para uma tabela hash com **n** elementos e **m** slots:

```
E[comprimento da cadeia] = 1 + (n-1)/m
```

### Demonstra√ß√£o
1. **Vari√°vel indicadora**: X·µ¢‚±º = 1 se chaves i e j colidem
2. **Comprimento da cadeia**: X = 1 + Œ£‚±º‚â†·µ¢ X·µ¢‚±º
3. **Expectativa**: E[X] = 1 + Œ£‚±º‚â†·µ¢ E[X·µ¢‚±º]
4. **Universalidade**: E[X·µ¢‚±º] ‚â§ 1/m
5. **Resultado**: E[X] ‚â§ 1 + (n-1)/m

### Escolha de m
```python
# Para cadeias constantes
m ‚â• n ‚Üí E[comprimento] ‚â§ 2

# Exemplo pr√°tico
n = 1000 elementos
m = 2000 slots
E[comprimento] ‚â§ 1.5
```

## üîß Implementa√ß√£o

### Classe HashTable
```python
import random

class UniversalHashTable:
    def __init__(self, size, universe_size):
        self.size = size
        self.table = [[] for _ in range(size)]
        self.n = 0
        
        # Par√¢metros da fun√ß√£o universal
        self.p = self._next_prime(universe_size)
        self.a = random.randint(1, self.p - 1)
        self.b = random.randint(0, self.p - 1)
    
    def _hash(self, key):
        return ((self.a * key + self.b) % self.p) % self.size
    
    def insert(self, key, value):
        index = self._hash(key)
        # Busca se j√° existe
        for i, (k, v) in enumerate(self.table[index]):
            if k == key:
                self.table[index][i] = (key, value)
                return
        # Insere novo
        self.table[index].append((key, value))
        self.n += 1
    
    def find(self, key):
        index = self._hash(key)
        for k, v in self.table[index]:
            if k == key:
                return v
        return None
```

### Fun√ß√£o Auxiliar
```python
def _next_prime(n):
    """Encontra o menor primo maior que n"""
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True
    
    candidate = n + 1
    while not is_prime(candidate):
        candidate += 1
    return candidate
```

## üìà An√°lise de Complexidade

### Opera√ß√µes B√°sicas
| Opera√ß√£o | Tempo Esperado | Pior Caso |
|----------|----------------|-----------|
| **insert** | O(1) | O(n) |
| **find** | O(1) | O(n) |
| **delete** | O(1) | O(n) |

### Fatores que Afetam Performance
1. **Fator de carga**: Œ± = n/m
2. **Qualidade da fun√ß√£o hash**: Distribui√ß√£o uniforme
3. **Tamanho da tabela**: m deve ser Œ©(n)

## üîÑ Redimensionamento Din√¢mico

### Estrat√©gia
```python
def _resize(self, new_size):
    old_table = self.table
    old_size = self.size
    
    # Nova tabela com novos par√¢metros
    self.size = new_size
    self.table = [[] for _ in range(new_size)]
    self.a = random.randint(1, self.p - 1)
    self.b = random.randint(0, self.p - 1)
    self.n = 0
    
    # Reinserir todos os elementos
    for chain in old_table:
        for key, value in chain:
            self.insert(key, value)
```

### Pol√≠tica de Redimensionamento
```python
# Dobrar quando Œ± > 1
if self.n > self.size:
    self._resize(2 * self.size)

# Reduzir pela metade quando Œ± < 1/4
if self.n < self.size // 4:
    self._resize(self.size // 2)
```

## üéØ Vantagens e Desvantagens

### Vantagens
- ‚úÖ **Performance garantida**: Independente dos dados
- ‚úÖ **Sem ataques**: Dif√≠cil de criar dados ruins
- ‚úÖ **Teoria s√≥lida**: An√°lise matem√°tica rigorosa
- ‚úÖ **Flexibilidade**: Suporta qualquer tipo de chave

### Desvantagens
- ‚ùå **Overhead**: C√°lculos mais complexos
- ‚ùå **Aleatoriedade**: Comportamento n√£o determin√≠stico
- ‚ùå **Par√¢metros**: Necessita de primo grande
- ‚ùå **Implementa√ß√£o**: Mais complexa que hash simples

## üîç Compara√ß√£o com Outras Abordagens

### Hashing Determin√≠stico
```python
# Simples mas vulner√°vel
def simple_hash(key):
    return key % m
```

### Hashing Universal
```python
# Complexo mas robusto
def universal_hash(key, a, b, p, m):
    return ((a * key + b) % p) % m
```

### Trade-offs
- **Simplicidade vs Robustez**
- **Velocidade vs Garantias**
- **Determinismo vs Aleatoriedade**

## üéØ Conclus√£o

Universal Hashing:
- **Resolve** o problema de colis√µes ruins
- **Garante** performance O(1) esperado
- **Fornece** base te√≥rica s√≥lida
- **Permite** implementa√ß√µes robustas de tabelas hash

---

**Pr√≥ximo**: [Chaining vs Open Addressing](04.%20Chaining%20vs%20Open%20Addressing.md) 