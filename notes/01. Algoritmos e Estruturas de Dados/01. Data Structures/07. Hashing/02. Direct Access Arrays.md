# Direct Access Arrays

## ğŸ¯ Objetivo

Implementar operaÃ§Ãµes de conjunto usando **acesso direto Ã  memÃ³ria**, permitindo operaÃ§Ãµes O(1) mas com limitaÃ§Ãµes de espaÃ§o.

## ğŸ—ï¸ Conceito BÃ¡sico

### Ideia Central
Armazenar um item com chave **k** diretamente na posiÃ§Ã£o **k** do array:

```python
# Se item tem chave = 10, armazenar em array[10]
array[10] = item
```

### OperaÃ§Ãµes O(1)
```python
def find(key):
    return array[key]  # O(1)

def insert(key, item):
    array[key] = item  # O(1)

def delete(key):
    array[key] = None  # O(1)
```

## ğŸ“Š Complexidade

| OperaÃ§Ã£o | Tempo | EspaÃ§o |
|----------|-------|--------|
| **build** | O(n) | O(u) |
| **find** | O(1) | - |
| **insert** | O(1) | - |
| **delete** | O(1) | - |
| **find_min** | O(u) | - |
| **find_max** | O(u) | - |

Onde:
- **n**: nÃºmero de elementos armazenados
- **u**: tamanho do universo de chaves (u â‰¥ n)

## âš ï¸ LimitaÃ§Ãµes

### 1. EspaÃ§o Excessivo
```python
# Exemplo: MIT IDs (9 dÃ­gitos)
u = 10^9  # Tamanho do universo
n = 400   # NÃºmero de estudantes

# EspaÃ§o necessÃ¡rio: O(10^9)
# EspaÃ§o usado: O(400)
# EficiÃªncia: 0.00004%
```

### 2. Chaves Inteiras
- **RestriÃ§Ã£o**: Apenas chaves inteiras sÃ£o suportadas
- **Motivo**: Chaves devem ser usadas como Ã­ndices
- **LimitaÃ§Ã£o**: NÃ£o funciona com strings, objetos complexos

### 3. Word RAM Model
```python
# RestriÃ§Ã£o: u â‰¤ 2^w
# Onde w = tamanho da palavra da mÃ¡quina
# Exemplo: w = 64 bits â†’ u â‰¤ 2^64
```

## ğŸ”§ ImplementaÃ§Ã£o

### Estrutura BÃ¡sica
```python
class DirectAccessArray:
    def __init__(self, universe_size):
        self.array = [None] * universe_size
        self.size = 0
    
    def find(self, key):
        return self.array[key]
    
    def insert(self, key, item):
        if self.array[key] is None:
            self.size += 1
        self.array[key] = item
    
    def delete(self, key):
        if self.array[key] is not None:
            self.size -= 1
            self.array[key] = None
```

### OperaÃ§Ãµes de Min/Max
```python
def find_min(self):
    for i in range(len(self.array)):
        if self.array[i] is not None:
            return self.array[i]
    return None

def find_max(self):
    for i in range(len(self.array) - 1, -1, -1):
        if self.array[i] is not None:
            return self.array[i]
    return None
```

## ğŸ“ˆ AnÃ¡lise de Trade-offs

### Vantagens
- âœ… **OperaÃ§Ãµes O(1)**: find, insert, delete
- âœ… **Simplicidade**: ImplementaÃ§Ã£o direta
- âœ… **Sem colisÃµes**: Cada chave tem posiÃ§Ã£o Ãºnica

### Desvantagens
- âŒ **EspaÃ§o O(u)**: Pode ser muito maior que O(n)
- âŒ **Chaves inteiras**: LimitaÃ§Ã£o de tipos
- âŒ **OperaÃ§Ãµes de ordem**: find_min/max sÃ£o O(u)
- âŒ **EspaÃ§o desperdiÃ§ado**: Muitas posiÃ§Ãµes vazias

## ğŸ¯ Casos de Uso

### Apropriado Quando
- **u â‰ˆ n**: Universo pequeno comparado aos dados
- **Chaves inteiras**: IDs, cÃ³digos numÃ©ricos
- **OperaÃ§Ãµes crÃ­ticas**: find/insert/delete frequentes
- **EspaÃ§o disponÃ­vel**: MemÃ³ria nÃ£o Ã© restriÃ§Ã£o

### Exemplos PrÃ¡ticos
```python
# IDs de funcionÃ¡rios (1 a 1000)
employee_db = DirectAccessArray(1000)

# CÃ³digos de produtos (0 a 9999)
product_catalog = DirectAccessArray(10000)

# Ãndices de array (0 a n-1)
index_mapping = DirectAccessArray(n)
```

## ğŸ”„ TransiÃ§Ã£o para Hashing

### Problema Central
Como reduzir o espaÃ§o de O(u) para O(n) mantendo operaÃ§Ãµes O(1)?

### SoluÃ§Ã£o: FunÃ§Ã£o Hash
```python
# Em vez de: array[key]
# Usar: array[hash(key) % m]
# Onde m â‰ˆ n (tamanho da tabela)
```

### Vantagens do Hashing
- **EspaÃ§o O(n)**: Tamanho proporcional aos dados
- **OperaÃ§Ãµes O(1)**: MantÃ©m eficiÃªncia
- **Chaves arbitrÃ¡rias**: Suporta qualquer tipo
- **Flexibilidade**: Tamanho adaptÃ¡vel

## ğŸ¯ ConclusÃ£o

Direct Access Arrays:
- **Demonstram** o potencial do Word RAM Model
- **Superam** o limite Î©(log n) do modelo de comparaÃ§Ã£o
- **Motivam** o desenvolvimento de hashing
- **Servem** como base conceitual para estruturas mais eficientes

---

**PrÃ³ximo**: [Universal Hashing](03.%20Universal%20Hashing.md) 