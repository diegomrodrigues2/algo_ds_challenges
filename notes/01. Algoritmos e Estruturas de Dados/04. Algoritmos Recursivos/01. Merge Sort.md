# ğŸ”„ Merge Sort

## ğŸ¯ VisÃ£o Geral
**Divide-and-conquer** por excelÃªncia: divide array ao meio, ordena recursivamente, combina resultados. Desenvolvido por John von Neumann em 1945, garante **O(n log n)** em todos os casos.

## ğŸ”§ Algoritmo

### ğŸ“Š EstratÃ©gia Principal
1. **Divide**: Array em duas metades
2. **Conquista**: Ordena cada metade recursivamente  
3. **Combina**: Mescla as duas metades ordenadas

### ğŸ”„ ImplementaÃ§Ã£o Base
```python
def merge_sort(A, a, b):
    if b - a <= 1:
        return
    c = (a + b) // 2  # Ponto mÃ©dio
    merge_sort(A, a, c)  # Ordena metade esquerda
    merge_sort(A, c, b)  # Ordena metade direita
    merge(A, a, c, b)    # Combina resultados
```

### ğŸ”— Merge (Two-Finger Algorithm)
```python
def merge(A, a, c, b):
    if c <= a or b <= c:
        return
    if A[c-1] <= A[c]:
        return  # JÃ¡ ordenado
    
    # Escolhe maior elemento do final
    if A[c-1] > A[b-1]:
        A[c-1], A[b-1] = A[b-1], A[c-1]
        merge(A, a, c, b-1)
    else:
        merge(A, a, c-1, b)
```

## âš¡ AnÃ¡lise de Complexidade

### ğŸ“ˆ Merge
- **RecursÃ£o**: T(n) = T(n-1) + O(1)
- **SoluÃ§Ã£o**: T(n) = O(n)
- **IntuiÃ§Ã£o**: Cada elemento visitado uma vez

### ğŸ¯ Merge Sort
- **RecorrÃªncia**: T(n) = 2T(n/2) + O(n)
- **SoluÃ§Ã£o**: T(n) = O(n log n)
- **Prova**: Master Theorem com a=2, b=2, f(n)=O(n)

### ğŸ“Š ComparaÃ§Ã£o com Outros Algoritmos
| Algoritmo | Tempo (Pior) | Tempo (MÃ©dio) | EspaÃ§o | EstÃ¡vel |
|-----------|--------------|---------------|--------|---------|
| Merge Sort | O(n log n) | O(n log n) | O(n) | âœ… Sim |
| Quick Sort | O(nÂ²) | O(n log n) | O(log n) | âŒ NÃ£o |
| Heap Sort | O(n log n) | O(n log n) | O(1) | âŒ NÃ£o |
| Insertion | O(nÂ²) | O(nÂ²) | O(1) | âœ… Sim |

## ğŸ” Exemplo Visual
```
[7,1,5,6,2,4,9,3] â†’ [7,1,5,6] [2,4,9,3]
                    â†“
                [1,5,6,7] [2,3,4,9]
                    â†“
                [1,2,3,4,5,6,7,9]
```

## âœ… Vantagens
- **Complexidade**: O(n log n) garantido
- **EstÃ¡vel**: MantÃ©m ordem relativa
- **PrevisÃ­vel**: Performance consistente
- **ParalelizÃ¡vel**: Metades independentes

## âŒ LimitaÃ§Ãµes
- **EspaÃ§o**: Requer O(n) espaÃ§o extra
- **Cache**: NÃ£o aproveita localidade
- **Overhead**: RecursÃ£o para arrays pequenos
- **Complexidade**: Mais difÃ­cil de implementar

## ğŸš€ VariaÃ§Ãµes e OtimizaÃ§Ãµes

### ğŸ”§ Merge Sort In-place
```python
def merge_sort_inplace(arr, left, right):
    if left < right:
        mid = (left + right) // 2
        merge_sort_inplace(arr, left, mid)
        merge_sort_inplace(arr, mid + 1, right)
        merge_inplace(arr, left, mid, right)
```

### âš¡ Natural Merge Sort
Aproveita sequÃªncias jÃ¡ ordenadas na entrada:
```python
def natural_merge_sort(arr):
    runs = find_runs(arr)
    while len(runs) > 1:
        # Mesclar runs adjacentes
        new_runs = []
        for i in range(0, len(runs), 2):
            if i + 1 < len(runs):
                merge_runs(arr, runs[i], runs[i+1])
                new_runs.append((runs[i][0], runs[i+1][1]))
            else:
                new_runs.append(runs[i])
        runs = new_runs
```

### ğŸ”„ Merge Sort Iterativo (Bottom-up)
```python
def merge_sort_iterative(arr):
    n = len(arr)
    size = 1
    
    while size < n:
        for left in range(0, n, 2 * size):
            mid = min(left + size, n)
            right = min(left + 2 * size, n)
            merge(arr, left, mid, right)
        size *= 2
```

## ğŸ¯ Casos de Uso
- **Arrays grandes**: n > 1000 elementos
- **Estabilidade necessÃ¡ria**: Ordem relativa importante
- **Performance garantida**: Quando O(n log n) Ã© essencial
- **ImplementaÃ§Ãµes de linguagens**: Python, Java, C++

## ğŸ’¡ Insights TeÃ³ricos
- **Divide-and-conquer**: PadrÃ£o fundamental
- **RecorrÃªncia**: T(n) = aT(n/b) + f(n)
- **Master Theorem**: SoluÃ§Ã£o automÃ¡tica para recorrÃªncias
- **Two-finger**: TÃ©cnica eficiente para merge
- **Logaritmo**: Resultado natural de divisÃ£o binÃ¡ria

## ğŸ”§ OtimizaÃ§Ãµes PrÃ¡ticas
- **Insertion sort**: Para subarrays pequenos (n < 10)
- **Merge in-place**: Evita espaÃ§o extra
- **Bottom-up**: VersÃ£o iterativa
- **Natural merge**: Aproveita ordenaÃ§Ã£o parcial 