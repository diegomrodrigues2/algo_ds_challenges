# 🔄 Merge Sort

## 🎯 Visão Geral
**Divide-and-conquer** por excelência: divide array ao meio, ordena recursivamente, combina resultados. Desenvolvido por John von Neumann em 1945, garante **O(n log n)** em todos os casos.

## 🔧 Algoritmo

### 📊 Estratégia Principal
1. **Divide**: Array em duas metades
2. **Conquista**: Ordena cada metade recursivamente  
3. **Combina**: Mescla as duas metades ordenadas

### 🔄 Implementação Base
```python
def merge_sort(A, a, b):
    if b - a <= 1:
        return
    c = (a + b) // 2  # Ponto médio
    merge_sort(A, a, c)  # Ordena metade esquerda
    merge_sort(A, c, b)  # Ordena metade direita
    merge(A, a, c, b)    # Combina resultados
```

### 🔗 Merge (Two-Finger Algorithm)
```python
def merge(A, a, c, b):
    if c <= a or b <= c:
        return
    if A[c-1] <= A[c]:
        return  # Já ordenado
    
    # Escolhe maior elemento do final
    if A[c-1] > A[b-1]:
        A[c-1], A[b-1] = A[b-1], A[c-1]
        merge(A, a, c, b-1)
    else:
        merge(A, a, c-1, b)
```

## ⚡ Análise de Complexidade

### 📈 Merge
- **Recursão**: T(n) = T(n-1) + O(1)
- **Solução**: T(n) = O(n)
- **Intuição**: Cada elemento visitado uma vez

### 🎯 Merge Sort
- **Recorrência**: T(n) = 2T(n/2) + O(n)
- **Solução**: T(n) = O(n log n)
- **Prova**: Master Theorem com a=2, b=2, f(n)=O(n)

### 📊 Comparação com Outros Algoritmos
| Algoritmo | Tempo (Pior) | Tempo (Médio) | Espaço | Estável |
|-----------|--------------|---------------|--------|---------|
| Merge Sort | O(n log n) | O(n log n) | O(n) | ✅ Sim |
| Quick Sort | O(n²) | O(n log n) | O(log n) | ❌ Não |
| Heap Sort | O(n log n) | O(n log n) | O(1) | ❌ Não |
| Insertion | O(n²) | O(n²) | O(1) | ✅ Sim |

## 🔍 Exemplo Visual
```
[7,1,5,6,2,4,9,3] → [7,1,5,6] [2,4,9,3]
                    ↓
                [1,5,6,7] [2,3,4,9]
                    ↓
                [1,2,3,4,5,6,7,9]
```

## ✅ Vantagens
- **Complexidade**: O(n log n) garantido
- **Estável**: Mantém ordem relativa
- **Previsível**: Performance consistente
- **Paralelizável**: Metades independentes

## ❌ Limitações
- **Espaço**: Requer O(n) espaço extra
- **Cache**: Não aproveita localidade
- **Overhead**: Recursão para arrays pequenos
- **Complexidade**: Mais difícil de implementar

## 🚀 Variações e Otimizações

### 🔧 Merge Sort In-place
```python
def merge_sort_inplace(arr, left, right):
    if left < right:
        mid = (left + right) // 2
        merge_sort_inplace(arr, left, mid)
        merge_sort_inplace(arr, mid + 1, right)
        merge_inplace(arr, left, mid, right)
```

### ⚡ Natural Merge Sort
Aproveita sequências já ordenadas na entrada:
```python
def natural_merge_sort(arr):
    runs = find_runs(arr)
    while len(runs) > 1:
        # Mesclar runs adjacentes
        new_runs = []
        for i in range(0, len(runs), 2):
            if i + 1 < len(runs):
                merge_runs(arr, runs[i], runs[i+1])
                new_runs.append((runs[i][0], runs[i+1][1]))
            else:
                new_runs.append(runs[i])
        runs = new_runs
```

### 🔄 Merge Sort Iterativo (Bottom-up)
```python
def merge_sort_iterative(arr):
    n = len(arr)
    size = 1
    
    while size < n:
        for left in range(0, n, 2 * size):
            mid = min(left + size, n)
            right = min(left + 2 * size, n)
            merge(arr, left, mid, right)
        size *= 2
```

## 🎯 Casos de Uso
- **Arrays grandes**: n > 1000 elementos
- **Estabilidade necessária**: Ordem relativa importante
- **Performance garantida**: Quando O(n log n) é essencial
- **Implementações de linguagens**: Python, Java, C++

## 💡 Insights Teóricos
- **Divide-and-conquer**: Padrão fundamental
- **Recorrência**: T(n) = aT(n/b) + f(n)
- **Master Theorem**: Solução automática para recorrências
- **Two-finger**: Técnica eficiente para merge
- **Logaritmo**: Resultado natural de divisão binária

## 🔧 Otimizações Práticas
- **Insertion sort**: Para subarrays pequenos (n < 10)
- **Merge in-place**: Evita espaço extra
- **Bottom-up**: Versão iterativa
- **Natural merge**: Aproveita ordenação parcial 