# Quickselect

## Visão Geral

O Quickselect é uma aplicação brilhante da ideia de particionamento do Quicksort. Em vez de recursão em ambos os lados do pivô, ele descarta um lado e continua a busca apenas na partição que deve conter o k-ésimo elemento. Isso reduz a complexidade média de O(n log n) para O(n), tornando-o um dos algoritmos de seleção mais eficientes na prática.

## Conceitos Fundamentais

### Problema de Seleção

O problema de seleção consiste em encontrar o k-ésimo menor elemento em um array não ordenado. Este é um problema fundamental em ciência da computação, com aplicações em:

- **Estatística**: Cálculo de medianas, quartis, percentis
- **Machine Learning**: Seleção de features, outliers
- **Sistemas de Banco de Dados**: Otimização de consultas
- **Algoritmos de Ordenação**: Como subrotina em outros algoritmos

### Estratégia de Divisão e Conquista

O Quickselect segue o paradigma de divisão e conquista, mas com uma otimização crucial:

1. **Dividir**: Particionar o array usando um pivô
2. **Conquistar**: Recursão apenas no lado relevante
3. **Combinar**: Não há combinação - o elemento é encontrado diretamente

## Algoritmo Básico

### Pseudocódigo

```
function quickselect(array, k):
    if length(array) == 1:
        return array[0]
    
    pivot = partition(array)
    pivot_rank = pivot + 1
    
    if k == pivot_rank:
        return array[pivot]
    elif k < pivot_rank:
        return quickselect(left_partition, k)
    else:
        return quickselect(right_partition, k - pivot_rank)
```

### Implementação Python

```python
def quickselect(arr, k):
    if len(arr) == 1:
        return arr[0]
    
    pivot_index = partition(arr, 0, len(arr) - 1)
    
    if k == pivot_index + 1:
        return arr[pivot_index]
    elif k < pivot_index + 1:
        return quickselect(arr[:pivot_index], k)
    else:
        return quickselect(arr[pivot_index + 1:], k - (pivot_index + 1))
```

## Análise de Complexidade

### Relação de Recorrência

A relação de recorrência do Quickselect é:
```
T(n) = T(n/2) + O(n)
```

### Solução da Recorrência

Usando o método de substituição:
```
T(n) = T(n/2) + O(n)
     = T(n/4) + O(n/2) + O(n)
     = T(n/8) + O(n/4) + O(n/2) + O(n)
     = ...
     = O(n) + O(n/2) + O(n/4) + ... + O(1)
     = O(n) * (1 + 1/2 + 1/4 + ...)
     = O(n) * 2
     = O(n)
```

### Comparação com Quicksort

| Aspecto | Quicksort | Quickselect |
|---------|-----------|-------------|
| Recorrência | T(n) = 2T(n/2) + O(n) | T(n) = T(n/2) + O(n) |
| Complexidade | O(n log n) | O(n) |
| Recursão | Ambos os lados | Apenas um lado |
| Objetivo | Ordenar todo o array | Encontrar um elemento |

## Otimizações

### Escolha de Pivô

#### Pivô Aleatório
```python
def partition_random(arr, left, right):
    pivot_index = random.randint(left, right)
    arr[pivot_index], arr[right] = arr[right], arr[pivot_index]
    return partition(arr, left, right)
```

#### Mediana de Três
```python
def median_of_three(arr, left, right):
    mid = (left + right) // 2
    if arr[left] <= arr[mid] <= arr[right] or arr[right] <= arr[mid] <= arr[left]:
        return mid
    elif arr[mid] <= arr[left] <= arr[right] or arr[right] <= arr[left] <= arr[mid]:
        return left
    else:
        return right
```

### Tratamento de Duplicatas

Para arrays com muitos elementos duplicados, é importante usar uma partição que agrupe elementos iguais:

```python
def partition_with_duplicates(arr, left, right):
    pivot = arr[right]
    i = left - 1
    j = left
    
    while j < right:
        if arr[j] < pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
        j += 1
    
    # Colocar pivô na posição correta
    arr[i + 1], arr[right] = arr[right], arr[i + 1]
    
    # Encontrar região de elementos iguais
    start = i + 1
    end = start
    while end < len(arr) and arr[end] == pivot:
        end += 1
    
    return start, end - 1
```

## Aplicações Práticas

### Cálculo de Mediana

```python
def find_median(arr):
    n = len(arr)
    if n % 2 == 1:
        return quickselect(arr, (n + 1) // 2)
    else:
        left = quickselect(arr, n // 2)
        right = quickselect(arr, n // 2 + 1)
        return (left + right) / 2
```

### Encontrar k-ésimo Maior

```python
def find_kth_largest(arr, k):
    return quickselect(arr, len(arr) - k + 1)
```

### Seleção de Percentis

```python
def find_percentile(arr, percentile):
    k = int(len(arr) * percentile / 100)
    return quickselect(arr, k + 1)
```

## Variações e Extensões

### Versão Iterativa

```python
def quickselect_iterative(arr, k):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        pivot_index = partition(arr, left, right)
        
        if k == pivot_index + 1:
            return arr[pivot_index]
        elif k < pivot_index + 1:
            right = pivot_index - 1
        else:
            left = pivot_index + 1
            k -= (pivot_index + 1)
    
    return arr[left]
```

### Versão Paralela

Para arrays muito grandes, é possível paralelizar o Quickselect:

```python
def quickselect_parallel(arr, k, num_threads=4):
    if len(arr) < 1000:  # Threshold para paralelização
        return quickselect(arr, k)
    
    # Dividir array em chunks
    chunk_size = len(arr) // num_threads
    chunks = [arr[i:i + chunk_size] for i in range(0, len(arr), chunk_size)]
    
    # Processar chunks em paralelo
    with ThreadPoolExecutor(max_workers=num_threads) as executor:
        futures = [executor.submit(quickselect, chunk, k) for chunk in chunks]
        results = [future.result() for future in futures]
    
    # Combinar resultados
    return quickselect(results, k)
```

## Análise de Performance

### Casos de Uso

| Cenário | Performance | Explicação |
|---------|-------------|------------|
| Pivô sempre mediano | O(n) | Redução ideal do problema |
| Pivô sempre extremo | O(n²) | Pior caso possível |
| Pivô aleatório | O(n) esperado | Probabilisticamente linear |
| Array já ordenado | O(n²) | Sem otimização de pivô |

### Comparação com Outros Algoritmos

| Algoritmo | Tempo Médio | Tempo Pior Caso | Espaço | Estável |
|-----------|-------------|------------------|--------|---------|
| **Quickselect** | O(n) | O(n²) | O(log n) | Não |
| **Heap Select** | O(n + k log n) | O(n + k log n) | O(1) | Não |
| **Sort + Select** | O(n log n) | O(n log n) | O(n) | Sim |
| **BFPRT** | O(n) | O(n) | O(n) | Não |

## Implementações em Linguagens

### Python
- **NumPy**: `np.partition()` e `np.argpartition()`
- **Pandas**: `Series.nsmallest()` e `Series.nlargest()`

### C++
- **STL**: `std::nth_element()`
- **Boost**: `boost::algorithm::nth_element()`

## Considerações Práticas

### Escolha do Algoritmo

- **Quickselect**: Para seleção única, performance média
- **Heap Select**: Para múltiplas seleções, k pequeno
- **Sort + Select**: Para estabilidade necessária
- **BFPRT**: Para performance garantida

### Considerações de Memória

- **In-place**: Quickselect modifica o array original
- **Espaço Auxiliar**: Apenes O(log n) para pilha de recursão
- **Fragmentação**: Menor que Quicksort devido à recursão unilateral
