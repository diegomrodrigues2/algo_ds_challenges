# 🗼 Tower of Hanoi

## 🎯 Visão Geral
**Exemplo canônico da recursão**: demonstra **"fé recursiva"** - acreditar que subproblemas funcionam. Inventado por Édouard Lucas em 1883.

## 🧩 O Problema

### 📋 Regras
1. **Um disco** por vez
2. **Nenhum disco** sobre disco menor
3. **Apenas disco do topo** pode ser movido

### 🎯 Objetivo
Mover n discos da origem para destino usando torre auxiliar.

## 🔄 Estratégia Recursiva

### 🧠 Fé Recursiva
Acreditar que você pode resolver para n-1 discos e usar para mover disco n.

### 🔧 Algoritmo
```python
def tower_of_hanoi(n, origem, destino, auxiliar):
    if n == 1:
        print(f"Mover disco 1 de {origem} para {destino}")
        return
    
    # Passo 1: Mover n-1 discos para auxiliar
    tower_of_hanoi(n-1, origem, auxiliar, destino)
    
    # Passo 2: Mover disco n para destino
    print(f"Mover disco {n} de {origem} para {destino}")
    
    # Passo 3: Mover n-1 discos do auxiliar para destino
    tower_of_hanoi(n-1, auxiliar, destino, origem)
```

## 📊 Análise de Complexidade

### 🔢 Recorrência
T(n) = 2T(n-1) + 1

### 📈 Solução
T(n) = 2^n - 1

### 📊 Demonstração
Para n = 1: T(1) = 1 = 2^1 - 1 ✓

Para n > 1:
```
T(n) = 2T(n-1) + 1
     = 2(2^(n-1) - 1) + 1
     = 2^n - 2 + 1
     = 2^n - 1
```

### ⚡ Complexidade
- **Tempo**: O(2^n) - exponencial
- **Espaço**: O(n) - altura da pilha

## 🧮 Propriedades Matemáticas

### 📊 Número de Movimentos
**2^n - 1** movimentos mínimos para n discos.

### 🔍 Sequência para n=3
1. A → C (disco 1)
2. A → B (disco 2)
3. C → B (disco 1)
4. A → C (disco 3)
5. B → A (disco 1)
6. B → C (disco 2)
7. A → C (disco 1)

### 🎯 Padrões
- **Disco 1**: Move a cada movimento alternado
- **Disco n**: Move apenas uma vez, no meio
- **Sequência n**: Contém duas cópias da sequência n-1

## 🌟 Fé Recursiva em Ação

### ✅ Por que Funciona?
1. **Caso Base**: n = 1 é trivial
2. **Hipótese Indutiva**: Funciona para n-1
3. **Passo Indutivo**: Usa solução n-1 para resolver n

### 🔍 Visualização
```
n=3: [1,2,3] → [3] + [1,2] → [3] + [2] + [1]
     ↑         ↑              ↑
   Problema  Subproblema   Subproblema
   original   n=2           n=1
```

## 🔧 Variações

### ⚡ Versão Iterativa
```python
def tower_of_hanoi_iterative(n, source, dest, aux):
    stack = [(n, source, dest, aux, False)]
    moves = []
    
    while stack:
        n, src, dst, aux, moved = stack.pop()
        
        if n == 1:
            moves.append(f"Mover disco 1 de {src} para {dst}")
        elif not moved:
            stack.append((n, src, dst, aux, True))
            stack.append((n-1, src, aux, dst, False))
        else:
            moves.append(f"Mover disco {n} de {src} para {dst}")
            stack.append((n-1, aux, dst, src, False))
    
    return moves
```

## 🎯 Aplicações

### 📚 Importância Pedagógica
- **Introdução à Recursão**: Demonstração visual
- **Fé Recursiva**: Confiar em subproblemas
- **Análise de Complexidade**: Exemplo clássico

### 🧪 Aplicações Práticas
- **Educação**: Ferramenta fundamental
- **Testes**: Verificação de algoritmos recursivos
- **Análise**: Exemplo de complexidade exponencial

## 💡 Insights Fundamentais

### 🧠 Lições Aprendidas
1. **Recursão é natural**: Solução mais simples que iteração
2. **Fé recursiva é poderosa**: Confiar em subproblemas funciona
3. **Análise é crucial**: Entender complexidade é essencial
4. **Casos base são fundamentais**: Sem eles, recursão não para
5. **Visualização ajuda**: Ver processo facilita entendimento

### 🚀 A Lenda dos 64 Discos
- **Movimentos**: 2^64 - 1 ≈ 18.4 quintilhões
- **Tempo**: ≈ 580 bilhões de anos (1 disco/segundo)
- **Contexto**: Universo tem ~13.8 bilhões de anos 