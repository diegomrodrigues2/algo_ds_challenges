# ğŸ—¼ Tower of Hanoi

## ğŸ¯ VisÃ£o Geral
**Exemplo canÃ´nico da recursÃ£o**: demonstra **"fÃ© recursiva"** - acreditar que subproblemas funcionam. Inventado por Ã‰douard Lucas em 1883.

## ğŸ§© O Problema

### ğŸ“‹ Regras
1. **Um disco** por vez
2. **Nenhum disco** sobre disco menor
3. **Apenas disco do topo** pode ser movido

### ğŸ¯ Objetivo
Mover n discos da origem para destino usando torre auxiliar.

## ğŸ”„ EstratÃ©gia Recursiva

### ğŸ§  FÃ© Recursiva
Acreditar que vocÃª pode resolver para n-1 discos e usar para mover disco n.

### ğŸ”§ Algoritmo
```python
def tower_of_hanoi(n, origem, destino, auxiliar):
    if n == 1:
        print(f"Mover disco 1 de {origem} para {destino}")
        return
    
    # Passo 1: Mover n-1 discos para auxiliar
    tower_of_hanoi(n-1, origem, auxiliar, destino)
    
    # Passo 2: Mover disco n para destino
    print(f"Mover disco {n} de {origem} para {destino}")
    
    # Passo 3: Mover n-1 discos do auxiliar para destino
    tower_of_hanoi(n-1, auxiliar, destino, origem)
```

## ğŸ“Š AnÃ¡lise de Complexidade

### ğŸ”¢ RecorrÃªncia
T(n) = 2T(n-1) + 1

### ğŸ“ˆ SoluÃ§Ã£o
T(n) = 2^n - 1

### ğŸ“Š DemonstraÃ§Ã£o
Para n = 1: T(1) = 1 = 2^1 - 1 âœ“

Para n > 1:
```
T(n) = 2T(n-1) + 1
     = 2(2^(n-1) - 1) + 1
     = 2^n - 2 + 1
     = 2^n - 1
```

### âš¡ Complexidade
- **Tempo**: O(2^n) - exponencial
- **EspaÃ§o**: O(n) - altura da pilha

## ğŸ§® Propriedades MatemÃ¡ticas

### ğŸ“Š NÃºmero de Movimentos
**2^n - 1** movimentos mÃ­nimos para n discos.

### ğŸ” SequÃªncia para n=3
1. A â†’ C (disco 1)
2. A â†’ B (disco 2)
3. C â†’ B (disco 1)
4. A â†’ C (disco 3)
5. B â†’ A (disco 1)
6. B â†’ C (disco 2)
7. A â†’ C (disco 1)

### ğŸ¯ PadrÃµes
- **Disco 1**: Move a cada movimento alternado
- **Disco n**: Move apenas uma vez, no meio
- **SequÃªncia n**: ContÃ©m duas cÃ³pias da sequÃªncia n-1

## ğŸŒŸ FÃ© Recursiva em AÃ§Ã£o

### âœ… Por que Funciona?
1. **Caso Base**: n = 1 Ã© trivial
2. **HipÃ³tese Indutiva**: Funciona para n-1
3. **Passo Indutivo**: Usa soluÃ§Ã£o n-1 para resolver n

### ğŸ” VisualizaÃ§Ã£o
```
n=3: [1,2,3] â†’ [3] + [1,2] â†’ [3] + [2] + [1]
     â†‘         â†‘              â†‘
   Problema  Subproblema   Subproblema
   original   n=2           n=1
```

## ğŸ”§ VariaÃ§Ãµes

### âš¡ VersÃ£o Iterativa
```python
def tower_of_hanoi_iterative(n, source, dest, aux):
    stack = [(n, source, dest, aux, False)]
    moves = []
    
    while stack:
        n, src, dst, aux, moved = stack.pop()
        
        if n == 1:
            moves.append(f"Mover disco 1 de {src} para {dst}")
        elif not moved:
            stack.append((n, src, dst, aux, True))
            stack.append((n-1, src, aux, dst, False))
        else:
            moves.append(f"Mover disco {n} de {src} para {dst}")
            stack.append((n-1, aux, dst, src, False))
    
    return moves
```

## ğŸ¯ AplicaÃ§Ãµes

### ğŸ“š ImportÃ¢ncia PedagÃ³gica
- **IntroduÃ§Ã£o Ã  RecursÃ£o**: DemonstraÃ§Ã£o visual
- **FÃ© Recursiva**: Confiar em subproblemas
- **AnÃ¡lise de Complexidade**: Exemplo clÃ¡ssico

### ğŸ§ª AplicaÃ§Ãµes PrÃ¡ticas
- **EducaÃ§Ã£o**: Ferramenta fundamental
- **Testes**: VerificaÃ§Ã£o de algoritmos recursivos
- **AnÃ¡lise**: Exemplo de complexidade exponencial

## ğŸ’¡ Insights Fundamentais

### ğŸ§  LiÃ§Ãµes Aprendidas
1. **RecursÃ£o Ã© natural**: SoluÃ§Ã£o mais simples que iteraÃ§Ã£o
2. **FÃ© recursiva Ã© poderosa**: Confiar em subproblemas funciona
3. **AnÃ¡lise Ã© crucial**: Entender complexidade Ã© essencial
4. **Casos base sÃ£o fundamentais**: Sem eles, recursÃ£o nÃ£o para
5. **VisualizaÃ§Ã£o ajuda**: Ver processo facilita entendimento

### ğŸš€ A Lenda dos 64 Discos
- **Movimentos**: 2^64 - 1 â‰ˆ 18.4 quintilhÃµes
- **Tempo**: â‰ˆ 580 bilhÃµes de anos (1 disco/segundo)
- **Contexto**: Universo tem ~13.8 bilhÃµes de anos 