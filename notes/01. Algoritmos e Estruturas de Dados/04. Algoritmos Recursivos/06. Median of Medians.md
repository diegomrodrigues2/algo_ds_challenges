# Mediana das Medianas (BFPRT)

## Visão Geral

O algoritmo Mediana das Medianas (Blum-Floyd-Pratt-Rivest-Tarjan) é um marco teórico que garante tempo linear no pior caso para o problema de seleção. Na prática, a constante oculta na notação O(n) é alta, tornando o Quickselect com pivô aleatório mais rápido para a maioria das entradas, mas a compreensão deste algoritmo é crucial para um domínio completo da análise de algoritmos de divisão e conquista.

## Conceitos Fundamentais

### Problema de Seleção Determinística

O problema de seleção determinística consiste em encontrar o k-ésimo menor elemento em um array não ordenado, garantindo tempo linear no pior caso. Este é um problema fundamental em ciência da computação que demonstra a importância de escolhas inteligentes de pivô.

### Estratégia de Divisão e Conquista Avançada

O algoritmo BFPRT segue o paradigma de divisão e conquista, mas com uma estratégia sofisticada de escolha de pivô:

1. **Dividir**: Dividir o array em grupos de 5 elementos
2. **Conquistar**: Encontrar a mediana de cada grupo
3. **Combinar**: Encontrar a mediana das medianas
4. **Particionar**: Particionar ao redor da mediana das medianas
5. **Recursão**: Continuar apenas no lado relevante

## Algoritmo Básico

### Pseudocódigo

```
function median_of_medians_select(array, k):
    if length(array) <= 5:
        return sort_and_select(array, k)
    
    // Dividir em grupos de 5
    groups = divide_into_groups_of_five(array)
    
    // Encontrar mediana de cada grupo
    medians = []
    for each group in groups:
        median = find_median_of_five(group)
        medians.append(median)
    
    // Encontrar mediana das medianas
    pivot = median_of_medians_select(medians, length(medians)/2)
    
    // Particionar ao redor do pivô
    pivot_rank = partition_around_pivot(array, pivot)
    
    if k == pivot_rank:
        return pivot
    elif k < pivot_rank:
        return median_of_medians_select(left_partition, k)
    else:
        return median_of_medians_select(right_partition, k - pivot_rank)
```

### Implementação Python

```python
def median_of_medians_select(arr, k):
    if len(arr) <= 5:
        return sorted(arr)[k - 1]
    
    # Dividir em grupos de 5
    groups = [arr[i:i+5] for i in range(0, len(arr), 5)]
    
    # Encontrar mediana de cada grupo
    medians = []
    for group in groups:
        median = find_median_of_five(group)
        medians.append(median)
    
    # Encontrar mediana das medianas
    pivot = median_of_medians_select(medians, len(medians) // 2)
    
    # Particionar ao redor do pivô
    pivot_rank = partition_around_pivot(arr, pivot)
    
    if k == pivot_rank:
        return pivot
    elif k < pivot_rank:
        return median_of_medians_select(left_partition, k)
    else:
        return median_of_medians_select(right_partition, k - pivot_rank)
```

## Análise de Complexidade

### Relação de Recorrência

A relação de recorrência do algoritmo BFPRT é:
```
T(n) ≤ T(n/5) + T(7n/10) + O(n)
```

### Solução da Recorrência

Usando o método de substituição:
```
T(n) ≤ T(n/5) + T(7n/10) + O(n)
     ≤ T(n/25) + T(7n/50) + O(n/5) + T(7n/50) + T(49n/100) + O(7n/10) + O(n)
     = T(n/25) + 2T(7n/50) + T(49n/100) + O(n)
     ≤ ...
     = O(n) * (1 + 7/10 + (7/10)² + ...)
     = O(n) * (1 / (1 - 7/10))
     = O(n) * (10/3)
     = O(n)
```

### Garantia de Qualidade do Pivô

O algoritmo garante que o pivô escolhido está entre o 30º e 70º percentil:

- **Pelo menos 30%** dos elementos são menores que o pivô
- **Pelo menos 30%** dos elementos são maiores que o pivô
- **No máximo 70%** dos elementos permanecem após a partição

## Implementação Detalhada

### Encontrar Mediana de Cinco

```python
def median_of_five(arr, left, right):
    """Encontra a mediana de cinco elementos usando ordenação."""
    group = arr[left:right + 1]
    sorted_group = sorted(group)
    median_value = sorted_group[len(sorted_group) // 2]
    
    # Encontrar índice da mediana no array original
    for i in range(left, right + 1):
        if arr[i] == median_value:
            return i
    
    return left  # Fallback
```

### Encontrar Mediana das Medianas

```python
def find_median_of_medians(arr, left, right):
    """Encontra a mediana das medianas usando o algoritmo BFPRT."""
    n = right - left + 1
    
    if n <= 5:
        return median_of_five(arr, left, right)
    
    # Dividir em grupos de 5
    medians = []
    for i in range(left, right + 1, 5):
        end = min(i + 4, right)
        median_index = median_of_five(arr, i, end)
        medians.append(arr[median_index])
    
    # Recursão para encontrar mediana das medianas
    return find_median_of_medians(medians, 0, len(medians) - 1)
```

### Particionar ao Redor do Pivô

```python
def partition_around_pivot(arr, left, right, pivot_index):
    """Particiona o array ao redor do pivô especificado."""
    pivot = arr[pivot_index]
    
    # Mover pivô para o final
    arr[pivot_index], arr[right] = arr[right], arr[pivot_index]
    
    # Particionar
    i = left - 1
    for j in range(left, right):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    # Colocar pivô na posição correta
    arr[i + 1], arr[right] = arr[right], arr[i + 1]
    
    return i + 1
```

## Análise de Performance

### Casos de Uso

| Cenário | Performance | Explicação |
|---------|-------------|------------|
| Pior caso | O(n) | Garantido pelo algoritmo |
| Caso médio | O(n) | Constante alta |
| Melhor caso | O(n) | Sempre linear |

### Comparação com Outros Algoritmos

| Algoritmo | Tempo Médio | Tempo Pior Caso | Constante | Garantia |
|-----------|-------------|------------------|-----------|----------|
| **Quickselect** | O(n) | O(n²) | Baixa | Probabilística |
| **BFPRT** | O(n) | O(n) | Alta | Determinística |
| **Heap Select** | O(n + k log n) | O(n + k log n) | Média | Determinística |
| **Sort + Select** | O(n log n) | O(n log n) | Baixa | Determinística |

## Variações e Otimizações

### Versão Otimizada

```python
def median_of_medians_optimized(arr, k):
    """Versão otimizada com melhorias de performance."""
    if len(arr) <= 10:
        return sorted(arr)[k - 1]
    
    # Usar grupos de 7 em vez de 5 para melhor balanceamento
    groups = [arr[i:i+7] for i in range(0, len(arr), 7)]
    
    medians = []
    for group in groups:
        median = find_median_of_seven(group)
        medians.append(median)
    
    pivot = median_of_medians_optimized(medians, len(medians) // 2)
    pivot_rank = partition_around_pivot(arr, 0, len(arr) - 1, pivot)
    
    if k == pivot_rank:
        return pivot
    elif k < pivot_rank:
        return median_of_medians_optimized(arr[:pivot_rank], k)
    else:
        return median_of_medians_optimized(arr[pivot_rank + 1:], k - pivot_rank - 1)
```

### Versão Paralela

```python
def median_of_medians_parallel(arr, k, num_threads=4):
    """Versão paralela do algoritmo BFPRT."""
    if len(arr) < 1000:  # Threshold para paralelização
        return median_of_medians_select(arr, k)
    
    # Dividir array em chunks
    chunk_size = len(arr) // num_threads
    chunks = [arr[i:i + chunk_size] for i in range(0, len(arr), chunk_size)]
    
    # Processar chunks em paralelo
    with ThreadPoolExecutor(max_workers=num_threads) as executor:
        futures = [executor.submit(median_of_medians_select, chunk, k) for chunk in chunks]
        results = [future.result() for future in futures]
    
    # Combinar resultados
    return median_of_medians_select(results, k)
```

## Aplicações Práticas

### Cálculo de Mediana Determinística

```python
def find_median_deterministic(arr):
    """Encontra a mediana usando BFPRT."""
    n = len(arr)
    if n % 2 == 1:
        return median_of_medians_select(arr, (n + 1) // 2)
    else:
        left = median_of_medians_select(arr, n // 2)
        right = median_of_medians_select(arr, n // 2 + 1)
        return (left + right) / 2
```

### Seleção de Percentis Determinística

```python
def find_percentile_deterministic(arr, percentile):
    """Encontra o percentil usando BFPRT."""
    k = int(len(arr) * percentile / 100)
    return median_of_medians_select(arr, k + 1)
```

### Comparação com Quickselect

```python
def compare_with_quickselect(arr, k):
    """Compara BFPRT com Quickselect."""
    import time
    
    # Teste BFPRT
    start_time = time.time()
    mom_result = median_of_medians_select(arr.copy(), k)
    mom_time = time.time() - start_time
    
    # Teste Quickselect
    start_time = time.time()
    qs_result = quickselect(arr.copy(), k)
    qs_time = time.time() - start_time
    
    return {
        'mom_result': mom_result,
        'quickselect_result': qs_result,
        'mom_time': mom_time,
        'quickselect_time': qs_time,
        'consistent': mom_result == qs_result
    }
```

## Análise Teórica

### Limites Teóricos

O algoritmo BFPRT estabelece limites teóricos importantes:

- **Limite Inferior**: Ω(n) para algoritmos baseados em comparação
- **Limite Superior**: O(n) com constante determinística
- **Constante**: Aproximadamente 3-4 vezes maior que Quickselect

### Análise da Recorrência

A relação de recorrência `T(n) ≤ T(n/5) + T(7n/10) + O(n)` é resolvida usando:

1. **Método de Substituição**: Mostra que a solução é O(n)
2. **Árvore de Recorrência**: Visualiza a decomposição
3. **Método Mestre**: Não se aplica diretamente devido à forma da recorrência

### Garantia de Qualidade do Pivô

O algoritmo garante que o pivô escolhido está entre o 30º e 70º percentil através de:

1. **Divisão em Grupos**: Cada grupo de 5 elementos
2. **Mediana de Grupos**: Encontra mediana de cada grupo
3. **Mediana das Medianas**: Garante qualidade do pivô
4. **Análise Combinatória**: Prova os limites percentuais

## Considerações Práticas

### Quando Usar BFPRT

- **Sistemas de Tempo Real**: Quando performance no pior caso é crítica
- **Análise Teórica**: Para entender limites de algoritmos de seleção
- **Implementações Determinísticas**: Quando comportamento previsível é necessário
- **Algoritmos de Ordenação**: Como subrotina em algoritmos de ordenação

### Quando Usar Quickselect

- **Aplicações Práticas**: Para a maioria dos casos de uso
- **Performance Média**: Quando performance média é mais importante
- **Simplicidade**: Quando implementação simples é preferível
- **Cache Performance**: Quando localidade de cache é importante

### Otimizações de Cache

- **Localidade de Referência**: BFPRT tem acesso menos local que Quickselect
- **Tamanho de Cache Line**: Afeta performance em arrays grandes
- **Memory Bandwidth**: Crucial para datasets muito grandes
- **TLB Misses**: Impactam algoritmos com acesso aleatório

## Conclusão

O algoritmo Mediana das Medianas (BFPRT) representa um marco teórico fundamental em algoritmos de seleção. Sua garantia de tempo linear no pior caso o torna indispensável para aplicações onde performance determinística é crítica, mesmo que a constante oculta seja alta.

A compreensão deste algoritmo é essencial para:
- **Análise de Algoritmos**: Entender limites teóricos
- **Design de Sistemas**: Escolher algoritmos apropriados
- **Otimização**: Balancear teoria e prática
- **Educação**: Demonstrar técnicas avançadas de análise

A chave para sua eficiência está na escolha inteligente do pivô: ao garantir que o pivô está entre o 30º e 70º percentil, o algoritmo assegura que pelo menos 30% dos elementos são descartados a cada iteração, resultando em uma complexidade linear determinística que é difícil de superar com algoritmos baseados em comparação. 