# ğŸš€ Fast Multiplication

## ğŸ¯ VisÃ£o Geral
**MultiplicaÃ§Ã£o rÃ¡pida** atravÃ©s de algoritmos recursivos: **Karatsuba** para nÃºmeros grandes e **Binary Exponentiation** para potÃªncias, ambos usando **divide-and-conquer**.

## ğŸ”§ Karatsuba Algorithm

### ğŸ“Š EstratÃ©gia
Reduz multiplicaÃ§Ã£o de $O(n^2)$ para $O(n^{1.585})$ usando identidade algÃ©brica:

$x \cdot y = 10^{2m} \cdot ac + 10^m \cdot [(a+b)(c+d) - ac - bd] + bd$

### ğŸ”„ ImplementaÃ§Ã£o
```python
def karatsuba_multiply(a, b):
    if len(a) == 1 and len(b) == 1:
        return str(int(a) * int(b))
    
    mid = len(a) // 2
    a_left, a_right = a[:mid], a[mid:]
    b_left, b_right = b[:mid], b[mid:]
    
    # TrÃªs multiplicaÃ§Ãµes recursivas
    z0 = karatsuba_multiply(a_right, b_right)
    z2 = karatsuba_multiply(a_left, b_left)
    z1 = karatsuba_multiply(add_strings(a_left, a_right), 
                           add_strings(b_left, b_right))
    z1 = subtract_strings(subtract_strings(z1, z0), z2)
    
    return add_strings(
        add_strings(z2 + "0" * (2 * mid), z1 + "0" * mid),
        z0
    )
```

### ğŸ“ˆ AnÃ¡lise
- **RecorrÃªncia**: T(n) = 3T(n/2) + O(n)
- **SoluÃ§Ã£o**: T(n) = O(n^1.585)
- **Master Theorem**: Caso 1 (a > b^1)

## âš¡ Binary Exponentiation

### ğŸ“Š EstratÃ©gia
Reduz exponenciaÃ§Ã£o de $O(n)$ para $O(\log n)$ usando representaÃ§Ã£o binÃ¡ria:

$x^n = x^{b_k \cdot 2^k} \cdot x^{b_{k-1} \cdot 2^{k-1}} \cdot \ldots \cdot x^{b_0 \cdot 2^0}$

### ğŸ”„ ImplementaÃ§Ã£o
```python
def binary_exponentiation(base, exponent):
    result = 1
    while exponent > 0:
        if exponent & 1:  # Bit atual Ã© 1
            result *= base
        base *= base      # Quadrar a base
        exponent >>= 1    # Mover para prÃ³ximo bit
    return result
```

### ğŸ“ˆ AnÃ¡lise
- **RecorrÃªncia**: T(n) = T(n/2) + O(1)
- **SoluÃ§Ã£o**: T(n) = O(log n)
- **MultiplicaÃ§Ãµes**: O(log n) vs O(n) tradicional

## ğŸ“Š ComparaÃ§Ã£o de Algoritmos

| Algoritmo | Complexidade | MultiplicaÃ§Ãµes | AplicaÃ§Ã£o |
|-----------|--------------|----------------|-----------|
| **Tradicional** | O(nÂ²) | nÂ² | NÃºmeros pequenos |
| **Karatsuba** | O(n^1.585) | 3 recursivas | NÃºmeros grandes |
| **Binary Exp** | O(log n) | O(log n) | PotÃªncias grandes |

## âœ… Vantagens
- **Karatsuba**: EscalÃ¡vel para nÃºmeros muito grandes
- **Binary Exp**: Eficiente para expoentes grandes
- **Divide-and-Conquer**: Estrutura natural
- **AplicaÃ§Ãµes**: Criptografia, computaÃ§Ã£o cientÃ­fica

## âŒ LimitaÃ§Ãµes
- **Overhead**: Constantes maiores para entradas pequenas
- **Complexidade**: ImplementaÃ§Ã£o mais difÃ­cil
- **MemÃ³ria**: Stack space para recursÃ£o
- **PrecisÃ£o**: Cuidado com overflow

## ğŸ¯ Casos de Uso

### ğŸš€ Karatsuba
- **NÃºmeros grandes**: 100+ dÃ­gitos
- **Criptografia**: RSA, sistemas de chave pÃºblica
- **PrecisÃ£o arbitrÃ¡ria**: Bibliotecas matemÃ¡ticas
- **CompetiÃ§Ãµes**: ProgramaÃ§Ã£o competitiva

### âš¡ Binary Exponentiation
- **Expoentes grandes**: 1000+ potÃªncias
- **Criptografia**: RSA, Diffie-Hellman
- **ComputaÃ§Ã£o cientÃ­fica**: SimulaÃ§Ãµes numÃ©ricas
- **Algoritmos**: RecorrÃªncias lineares

## ğŸ’¡ Insights TeÃ³ricos
- **Divide-and-conquer**: PadrÃ£o fundamental
- **Master Theorem**: Ferramenta poderosa
- **RepresentaÃ§Ã£o binÃ¡ria**: DecomposiÃ§Ã£o eficiente
- **Identidades algÃ©bricas**: OtimizaÃ§Ã£o matemÃ¡tica
- **Trade-offs**: Simplicidade vs performance

## ğŸ”§ OtimizaÃ§Ãµes
- **Threshold**: Usar algoritmo tradicional para entradas pequenas
- **Modular**: VersÃµes modulares para criptografia
- **Iterativo**: Evitar stack overflow
- **HÃ­brido**: Combinar mÃºltiplas tÃ©cnicas 