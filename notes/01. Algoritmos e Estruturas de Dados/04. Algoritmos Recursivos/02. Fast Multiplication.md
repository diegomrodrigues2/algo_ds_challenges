# 🚀 Fast Multiplication

## 🎯 Visão Geral
**Multiplicação rápida** através de algoritmos recursivos: **Karatsuba** para números grandes e **Binary Exponentiation** para potências, ambos usando **divide-and-conquer**.

## 🔧 Karatsuba Algorithm

### 📊 Estratégia
Reduz multiplicação de $O(n^2)$ para $O(n^{1.585})$ usando identidade algébrica:

$x \cdot y = 10^{2m} \cdot ac + 10^m \cdot [(a+b)(c+d) - ac - bd] + bd$

### 🔄 Implementação
```python
def karatsuba_multiply(a, b):
    if len(a) == 1 and len(b) == 1:
        return str(int(a) * int(b))
    
    mid = len(a) // 2
    a_left, a_right = a[:mid], a[mid:]
    b_left, b_right = b[:mid], b[mid:]
    
    # Três multiplicações recursivas
    z0 = karatsuba_multiply(a_right, b_right)
    z2 = karatsuba_multiply(a_left, b_left)
    z1 = karatsuba_multiply(add_strings(a_left, a_right), 
                           add_strings(b_left, b_right))
    z1 = subtract_strings(subtract_strings(z1, z0), z2)
    
    return add_strings(
        add_strings(z2 + "0" * (2 * mid), z1 + "0" * mid),
        z0
    )
```

### 📈 Análise
- **Recorrência**: T(n) = 3T(n/2) + O(n)
- **Solução**: T(n) = O(n^1.585)
- **Master Theorem**: Caso 1 (a > b^1)

## ⚡ Binary Exponentiation

### 📊 Estratégia
Reduz exponenciação de $O(n)$ para $O(\log n)$ usando representação binária:

$x^n = x^{b_k \cdot 2^k} \cdot x^{b_{k-1} \cdot 2^{k-1}} \cdot \ldots \cdot x^{b_0 \cdot 2^0}$

### 🔄 Implementação
```python
def binary_exponentiation(base, exponent):
    result = 1
    while exponent > 0:
        if exponent & 1:  # Bit atual é 1
            result *= base
        base *= base      # Quadrar a base
        exponent >>= 1    # Mover para próximo bit
    return result
```

### 📈 Análise
- **Recorrência**: T(n) = T(n/2) + O(1)
- **Solução**: T(n) = O(log n)
- **Multiplicações**: O(log n) vs O(n) tradicional

## 📊 Comparação de Algoritmos

| Algoritmo | Complexidade | Multiplicações | Aplicação |
|-----------|--------------|----------------|-----------|
| **Tradicional** | O(n²) | n² | Números pequenos |
| **Karatsuba** | O(n^1.585) | 3 recursivas | Números grandes |
| **Binary Exp** | O(log n) | O(log n) | Potências grandes |

## ✅ Vantagens
- **Karatsuba**: Escalável para números muito grandes
- **Binary Exp**: Eficiente para expoentes grandes
- **Divide-and-Conquer**: Estrutura natural
- **Aplicações**: Criptografia, computação científica

## ❌ Limitações
- **Overhead**: Constantes maiores para entradas pequenas
- **Complexidade**: Implementação mais difícil
- **Memória**: Stack space para recursão
- **Precisão**: Cuidado com overflow

## 🎯 Casos de Uso

### 🚀 Karatsuba
- **Números grandes**: 100+ dígitos
- **Criptografia**: RSA, sistemas de chave pública
- **Precisão arbitrária**: Bibliotecas matemáticas
- **Competições**: Programação competitiva

### ⚡ Binary Exponentiation
- **Expoentes grandes**: 1000+ potências
- **Criptografia**: RSA, Diffie-Hellman
- **Computação científica**: Simulações numéricas
- **Algoritmos**: Recorrências lineares

## 💡 Insights Teóricos
- **Divide-and-conquer**: Padrão fundamental
- **Master Theorem**: Ferramenta poderosa
- **Representação binária**: Decomposição eficiente
- **Identidades algébricas**: Otimização matemática
- **Trade-offs**: Simplicidade vs performance

## 🔧 Otimizações
- **Threshold**: Usar algoritmo tradicional para entradas pequenas
- **Modular**: Versões modulares para criptografia
- **Iterativo**: Evitar stack overflow
- **Híbrido**: Combinar múltiplas técnicas 