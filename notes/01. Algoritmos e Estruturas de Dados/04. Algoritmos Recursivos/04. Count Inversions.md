# 🔄 Count Inversions

## 🎯 Visão Geral
**Aplicação clássica do Merge Sort**: conta pares (i,j) onde i < j e A[i] > A[j]. Demonstra como adaptar algoritmos para problemas além da ordenação.

## 📊 Definição

### 🔍 O que é uma Inversão?
Par de índices (i,j) onde i < j e A[i] > A[j].

**Exemplo:**
```
Array: [8, 4, 2, 1]
Inversões: (8,4), (8,2), (8,1), (4,2), (4,1), (2,1)
Total: 6 inversões
```

### 📈 Propriedades
- **Array ordenado**: 0 inversões
- **Array reverso**: n(n-1)/2 inversões (máximo)
- **Medida**: "Quão longe" o array está de estar ordenado

## 🔄 Estratégia do Algoritmo

### 🧠 Observação Chave
Durante merge de duas sub-listas ordenadas, se elemento da direita é movido antes da esquerda, forma inversões com **todos** os elementos restantes da esquerda.

### 🔍 Visualização
```
Sub-lista esquerda: [2, 4, 6]  (ordenada)
Sub-lista direita:  [1, 3, 5]  (ordenada)

Mesclagem:
- 1 < 2 → mover 1 → inversões com [2,4,6] = 3 inversões
- 2 < 3 → mover 2 → sem inversões
- 3 < 4 → mover 3 → sem inversões
- 4 < 5 → mover 4 → sem inversões
- 5 < 6 → mover 5 → sem inversões
- mover 6 → sem inversões

Total: 3 inversões
```

## 🔧 Implementação

### 📊 Estrutura Recursiva
```python
def count_inversions(arr):
    if len(arr) <= 1:
        return 0
    
    mid = len(arr) // 2
    left_inversions = count_inversions(arr[:mid])
    right_inversions = count_inversions(arr[mid:])
    cross_inversions = merge_and_count(arr[:mid], arr[mid:])
    
    return left_inversions + right_inversions + cross_inversions
```

### 🔗 Merge Modificado
```python
def merge_with_inversions(arr, left, mid, right):
    inversions = 0
    temp = []
    i = left      # índice da sub-lista esquerda
    j = mid + 1   # índice da sub-lista direita
    
    while i <= mid and j <= right:
        if arr[i] <= arr[j]:
            temp.append(arr[i])
            i += 1
        else:
            temp.append(arr[j])
            # arr[j] forma inversões com todos os elementos restantes da esquerda
            inversions += (mid - i + 1)
            j += 1
    
    # Copiar elementos restantes
    while i <= mid:
        temp.append(arr[i])
        i += 1
    
    while j <= right:
        temp.append(arr[j])
        j += 1
    
    # Copiar de volta para o array original
    for k in range(len(temp)):
        arr[left + k] = temp[k]
    
    return inversions
```

## 📈 Análise de Complexidade

### 🔢 Recorrência
T(n) = 2T(n/2) + O(n)

### 📊 Solução
T(n) = O(n log n)

### 🎯 Demonstração
- **Caso base**: T(1) = O(1)
- **Caso recursivo**: 
  - Dividir: O(1)
  - Conquistar: 2T(n/2)
  - Mesclar: O(n)
  - Total: T(n) = 2T(n/2) + O(n)

**Master Theorem**: a=2, b=2, f(n)=O(n)
- log_b(a) = log_2(2) = 1
- f(n) = O(n) = O(n^1)
- Como f(n) = O(n^log_b(a)), temos T(n) = O(n log n)

## 🔧 Variações

### ⚡ Força Bruta - O(n²)
```python
def count_inversions_brute_force(arr):
    inversions = 0
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            if arr[i] > arr[j]:
                inversions += 1
    return inversions
```

### 🌳 Fenwick Tree - O(n log n)
```python
def count_inversions_fenwick_tree(arr):
    # Comprimir valores para [0, n-1]
    compressed = compress_array(arr)
    
    # Processar da direita para a esquerda
    fenwick = FenwickTree(len(arr))
    inversions = 0
    
    for i in range(len(compressed) - 1, -1, -1):
        # Contar elementos menores já processados
        inversions += fenwick.query(compressed[i] - 1)
        fenwick.update(compressed[i], 1)
    
    return inversions
```

## 📊 Propriedades Matemáticas

### 🎯 Limites
- **Mínimo**: 0 (array ordenado)
- **Máximo**: n(n-1)/2 (array reverso)

### 📈 Distribuição
Para array aleatório de n elementos distintos:
- **Valor esperado**: n(n-1)/4
- **Variância**: n(n-1)(2n+5)/72

### 🔗 Relação com Ordenação
- **Bubble Sort**: Número de trocas = número de inversões
- **Insertion Sort**: Número de comparações ≥ número de inversões

## 🎯 Aplicações Práticas

### 📊 Medida de Desordem
Contagem de inversões é medida natural de "quão desordenado" um array está.

### 🔬 Análise de Dados
- **Genômica**: Análise de sequências de DNA
- **Finanças**: Análise de séries temporais
- **Machine Learning**: Medidas de similaridade

### 🔗 Problemas Relacionados
- **Kendall Tau Distance**: Medida de correlação entre rankings
- **Spearman's Rank Correlation**: Correlação de postos
- **Bubble Sort**: Número de trocas necessárias

## ✅ Vantagens
- **Eficiente**: O(n log n) vs O(n²) força bruta
- **Divide-and-Conquer**: Estrutura natural
- **Aplicável**: Muitos problemas relacionados
- **Estável**: Mantém ordem relativa

## ❌ Limitações
- **Complexidade**: Implementação mais difícil
- **Espaço**: O(n) espaço auxiliar
- **Overhead**: Para arrays pequenos, força bruta pode ser melhor
- **Especializado**: Requer compressão para valores grandes

## 💡 Insights Teóricos
- **Divide-and-conquer**: Poderoso para problemas complexos
- **Observação**: Chave está em notar o que acontece durante merge
- **Estruturas especializadas**: Fenwick Trees para otimizações
- **Análise matemática**: Essencial para escolher melhor abordagem
- **Validação**: Sempre verificar com casos simples primeiro 