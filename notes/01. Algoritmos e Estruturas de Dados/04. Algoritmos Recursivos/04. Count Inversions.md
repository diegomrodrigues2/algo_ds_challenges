# ğŸ”„ Count Inversions

## ğŸ¯ VisÃ£o Geral
**AplicaÃ§Ã£o clÃ¡ssica do Merge Sort**: conta pares (i,j) onde i < j e A[i] > A[j]. Demonstra como adaptar algoritmos para problemas alÃ©m da ordenaÃ§Ã£o.

## ğŸ“Š DefiniÃ§Ã£o

### ğŸ” O que Ã© uma InversÃ£o?
Par de Ã­ndices (i,j) onde i < j e A[i] > A[j].

**Exemplo:**
```
Array: [8, 4, 2, 1]
InversÃµes: (8,4), (8,2), (8,1), (4,2), (4,1), (2,1)
Total: 6 inversÃµes
```

### ğŸ“ˆ Propriedades
- **Array ordenado**: 0 inversÃµes
- **Array reverso**: n(n-1)/2 inversÃµes (mÃ¡ximo)
- **Medida**: "QuÃ£o longe" o array estÃ¡ de estar ordenado

## ğŸ”„ EstratÃ©gia do Algoritmo

### ğŸ§  ObservaÃ§Ã£o Chave
Durante merge de duas sub-listas ordenadas, se elemento da direita Ã© movido antes da esquerda, forma inversÃµes com **todos** os elementos restantes da esquerda.

### ğŸ” VisualizaÃ§Ã£o
```
Sub-lista esquerda: [2, 4, 6]  (ordenada)
Sub-lista direita:  [1, 3, 5]  (ordenada)

Mesclagem:
- 1 < 2 â†’ mover 1 â†’ inversÃµes com [2,4,6] = 3 inversÃµes
- 2 < 3 â†’ mover 2 â†’ sem inversÃµes
- 3 < 4 â†’ mover 3 â†’ sem inversÃµes
- 4 < 5 â†’ mover 4 â†’ sem inversÃµes
- 5 < 6 â†’ mover 5 â†’ sem inversÃµes
- mover 6 â†’ sem inversÃµes

Total: 3 inversÃµes
```

## ğŸ”§ ImplementaÃ§Ã£o

### ğŸ“Š Estrutura Recursiva
```python
def count_inversions(arr):
    if len(arr) <= 1:
        return 0
    
    mid = len(arr) // 2
    left_inversions = count_inversions(arr[:mid])
    right_inversions = count_inversions(arr[mid:])
    cross_inversions = merge_and_count(arr[:mid], arr[mid:])
    
    return left_inversions + right_inversions + cross_inversions
```

### ğŸ”— Merge Modificado
```python
def merge_with_inversions(arr, left, mid, right):
    inversions = 0
    temp = []
    i = left      # Ã­ndice da sub-lista esquerda
    j = mid + 1   # Ã­ndice da sub-lista direita
    
    while i <= mid and j <= right:
        if arr[i] <= arr[j]:
            temp.append(arr[i])
            i += 1
        else:
            temp.append(arr[j])
            # arr[j] forma inversÃµes com todos os elementos restantes da esquerda
            inversions += (mid - i + 1)
            j += 1
    
    # Copiar elementos restantes
    while i <= mid:
        temp.append(arr[i])
        i += 1
    
    while j <= right:
        temp.append(arr[j])
        j += 1
    
    # Copiar de volta para o array original
    for k in range(len(temp)):
        arr[left + k] = temp[k]
    
    return inversions
```

## ğŸ“ˆ AnÃ¡lise de Complexidade

### ğŸ”¢ RecorrÃªncia
T(n) = 2T(n/2) + O(n)

### ğŸ“Š SoluÃ§Ã£o
T(n) = O(n log n)

### ğŸ¯ DemonstraÃ§Ã£o
- **Caso base**: T(1) = O(1)
- **Caso recursivo**: 
  - Dividir: O(1)
  - Conquistar: 2T(n/2)
  - Mesclar: O(n)
  - Total: T(n) = 2T(n/2) + O(n)

**Master Theorem**: a=2, b=2, f(n)=O(n)
- log_b(a) = log_2(2) = 1
- f(n) = O(n) = O(n^1)
- Como f(n) = O(n^log_b(a)), temos T(n) = O(n log n)

## ğŸ”§ VariaÃ§Ãµes

### âš¡ ForÃ§a Bruta - O(nÂ²)
```python
def count_inversions_brute_force(arr):
    inversions = 0
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            if arr[i] > arr[j]:
                inversions += 1
    return inversions
```

### ğŸŒ³ Fenwick Tree - O(n log n)
```python
def count_inversions_fenwick_tree(arr):
    # Comprimir valores para [0, n-1]
    compressed = compress_array(arr)
    
    # Processar da direita para a esquerda
    fenwick = FenwickTree(len(arr))
    inversions = 0
    
    for i in range(len(compressed) - 1, -1, -1):
        # Contar elementos menores jÃ¡ processados
        inversions += fenwick.query(compressed[i] - 1)
        fenwick.update(compressed[i], 1)
    
    return inversions
```

## ğŸ“Š Propriedades MatemÃ¡ticas

### ğŸ¯ Limites
- **MÃ­nimo**: 0 (array ordenado)
- **MÃ¡ximo**: n(n-1)/2 (array reverso)

### ğŸ“ˆ DistribuiÃ§Ã£o
Para array aleatÃ³rio de n elementos distintos:
- **Valor esperado**: n(n-1)/4
- **VariÃ¢ncia**: n(n-1)(2n+5)/72

### ğŸ”— RelaÃ§Ã£o com OrdenaÃ§Ã£o
- **Bubble Sort**: NÃºmero de trocas = nÃºmero de inversÃµes
- **Insertion Sort**: NÃºmero de comparaÃ§Ãµes â‰¥ nÃºmero de inversÃµes

## ğŸ¯ AplicaÃ§Ãµes PrÃ¡ticas

### ğŸ“Š Medida de Desordem
Contagem de inversÃµes Ã© medida natural de "quÃ£o desordenado" um array estÃ¡.

### ğŸ”¬ AnÃ¡lise de Dados
- **GenÃ´mica**: AnÃ¡lise de sequÃªncias de DNA
- **FinanÃ§as**: AnÃ¡lise de sÃ©ries temporais
- **Machine Learning**: Medidas de similaridade

### ğŸ”— Problemas Relacionados
- **Kendall Tau Distance**: Medida de correlaÃ§Ã£o entre rankings
- **Spearman's Rank Correlation**: CorrelaÃ§Ã£o de postos
- **Bubble Sort**: NÃºmero de trocas necessÃ¡rias

## âœ… Vantagens
- **Eficiente**: O(n log n) vs O(nÂ²) forÃ§a bruta
- **Divide-and-Conquer**: Estrutura natural
- **AplicÃ¡vel**: Muitos problemas relacionados
- **EstÃ¡vel**: MantÃ©m ordem relativa

## âŒ LimitaÃ§Ãµes
- **Complexidade**: ImplementaÃ§Ã£o mais difÃ­cil
- **EspaÃ§o**: O(n) espaÃ§o auxiliar
- **Overhead**: Para arrays pequenos, forÃ§a bruta pode ser melhor
- **Especializado**: Requer compressÃ£o para valores grandes

## ğŸ’¡ Insights TeÃ³ricos
- **Divide-and-conquer**: Poderoso para problemas complexos
- **ObservaÃ§Ã£o**: Chave estÃ¡ em notar o que acontece durante merge
- **Estruturas especializadas**: Fenwick Trees para otimizaÃ§Ãµes
- **AnÃ¡lise matemÃ¡tica**: Essencial para escolher melhor abordagem
- **ValidaÃ§Ã£o**: Sempre verificar com casos simples primeiro 