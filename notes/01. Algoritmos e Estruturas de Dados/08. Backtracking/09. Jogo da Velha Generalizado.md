# ğŸ® Jogo da Velha Generalizado com Minimax

## ğŸ¯ VisÃ£o Geral

ImplementaÃ§Ã£o do algoritmo **Minimax** para Jogo da Velha generalizado (nÃ—n), demonstrando a aplicaÃ§Ã£o formal do **backtracking em Ã¡rvores de jogo**. O algoritmo explora todos os movimentos possÃ­veis e determina o movimento Ã³timo para cada jogador, assumindo que ambos jogam de forma Ã³tima.

## ğŸ”— VÃ­nculos Conceituais

### ğŸ“š ReferÃªncias TeÃ³ricas
- **Erickson, "Algorithms"**: CapÃ­tulo 2, SeÃ§Ã£o 2.2, "Game Trees"
- **Teoria das Ãrvores de Jogo**: [Erickson sobre Ãrvores de Jogo](https://jeffe.cs.illinois.edu/teaching/algorithms/book/02-backtracking.pdf)

### ğŸ’» ImplementaÃ§Ãµes de CÃ³digo-Fonte
- **[GitHub: t-ROY-coder/Tic-Tac-Toe-Game](https://github.com/t-ROY-coder/Tic-Tac-Toe-Game)** - Solucionador de jogo da velha usando algoritmo Minimax

## ğŸ§  AnÃ¡lise de Especialista

O algoritmo **Minimax** Ã© uma forma de backtracking aplicada a jogos de dois jogadores com informaÃ§Ã£o perfeita:

### ğŸ² Conceitos Fundamentais
- **Ãrvore de Jogo**: RepresentaÃ§Ã£o de todos os movimentos possÃ­veis
- **Maximizador (X)**: Escolhe movimento que leva ao melhor resultado
- **Minimizador (O)**: Escolhe movimento que leva ao pior resultado para o maximizador
- **Backtracking**: Retrocede valores das folhas para determinar movimento Ã³timo

### ğŸ”„ Estados Recursivos
```mermaid
graph TD
    A[Estado Atual] --> B[Maximizador]
    A --> C[Minimizador]
    B --> D[Melhor Movimento]
    C --> E[Pior Movimento para Max]
    D --> F[Valor MÃ¡ximo]
    E --> G[Valor MÃ­nimo]
    F --> H[Backtracking]
    G --> H
    H --> I[Movimento Ã“timo]
```

## âš™ï¸ Estrutura da ImplementaÃ§Ã£o

### ğŸ—ï¸ Classe Principal: `TicTacToeBoard`

```python
class TicTacToeBoard:
    def __init__(self, size: int = 3):
        """Inicializa um tabuleiro de tamanho n x n."""
        self.size = size
        self.board = [['' for _ in range(size)] for _ in range(size)]
        self.current_player = 'X'
        self.winner = None
        self.game_over = False
    
    def make_move(self, row: int, col: int) -> bool:
        """Faz um movimento na posiÃ§Ã£o especificada."""
    
    def get_available_moves(self) -> List[Tuple[int, int]]:
        """Retorna todas as posiÃ§Ãµes vazias disponÃ­veis."""
    
    def is_terminal_state(self) -> bool:
        """Verifica se o estado atual Ã© terminal."""
    
    def get_utility(self) -> int:
        """Retorna o valor de utilidade do estado terminal."""
```

### ğŸ§® FunÃ§Ã£o Principal: `minimax`

```python
def minimax(board: TicTacToeBoard, depth: int, alpha: float = float('-inf'), 
            beta: float = float('inf'), maximizing: bool = True) -> Tuple[int, Optional[Tuple[int, int]]]:
    """
    Implementa o algoritmo Minimax com poda Alpha-Beta.
    
    Args:
        board: Estado atual do tabuleiro
        depth: Profundidade mÃ¡xima de busca
        alpha: Valor alpha para poda
        beta: Valor beta para poda
        maximizing: True se Ã© o turno do maximizador (X), False para minimizador (O)
        
    Returns:
        Tupla (valor, movimento) onde valor Ã© a avaliaÃ§Ã£o do estado e
        movimento Ã© a posiÃ§Ã£o (row, col) do melhor movimento
    """
```

## ğŸš€ Funcionalidades Principais

### 1. ğŸ¯ Algoritmo Minimax com Poda Alpha-Beta
- **ExploraÃ§Ã£o Completa**: Para tabuleiros pequenos (3Ã—3), explora toda a Ã¡rvore de jogo
- **Poda Alpha-Beta**: Reduz significativamente o nÃºmero de nÃ³s explorados
- **OtimizaÃ§Ã£o**: Determina o movimento Ã³timo para cada jogador

### 2. ğŸ® Jogo da Velha Generalizado
- **Tabuleiros nÃ—n**: Suporta tabuleiros de qualquer tamanho
- **VitÃ³ria em Linhas, Colunas e Diagonais**: Regras clÃ¡ssicas do jogo
- **DetecÃ§Ã£o de Empate**: Identifica quando nÃ£o hÃ¡ mais movimentos possÃ­veis

### 3. ğŸ“Š AnÃ¡lise de Complexidade
```python
def analyze_minimax_complexity(size: int) -> Dict:
    """
    Analisa a complexidade do algoritmo Minimax para diferentes tamanhos de tabuleiro.
    
    Returns:
        DicionÃ¡rio com anÃ¡lise detalhada de complexidade
    """
```

### 4. ğŸ² SimulaÃ§Ã£o de Jogos Ã“timos
```python
def play_optimal_game(size: int = 3, max_depth: int = None) -> List[Dict]:
    """
    Simula um jogo completo onde ambos os jogadores jogam de forma Ã³tima.
    
    Returns:
        Lista de estados do jogo em cada movimento
    """
```

## ğŸ“Š Complexidade e LimitaÃ§Ãµes

### â±ï¸ AnÃ¡lise de Complexidade
| Aspecto | Complexidade | DescriÃ§Ã£o |
|---------|-------------|-----------|
| **Tempo** | O(b^d) | b = fator de ramificaÃ§Ã£o, d = profundidade |
| **EspaÃ§o** | O(d) | Profundidade da pilha de recursÃ£o |
| **Praticamente ViÃ¡vel** | AtÃ© 4Ã—4 | Tabuleiros com profundidade limitada |

### ğŸš« LimitaÃ§Ãµes PrÃ¡ticas
1. **Complexidade Exponencial**: Para tabuleiros grandes, o algoritmo se torna impraticÃ¡vel
2. **MemÃ³ria**: ExploraÃ§Ã£o completa requer memÃ³ria proporcional ao tamanho da Ã¡rvore
3. **Tempo**: Mesmo com poda Alpha-Beta, tabuleiros grandes sÃ£o computacionalmente caros

## ğŸ¯ AplicaÃ§Ãµes PrÃ¡ticas

### ğŸ² Jogos de Tabuleiro
- **Xadrez, Damas, Go**: Todos usam variaÃ§Ãµes do Minimax
- **IA Competitiva**: Algoritmo fundamental para criar IAs fortes

### ğŸ§  Teoria dos Jogos
- **AnÃ¡lise de EstratÃ©gias**: Determina estratÃ©gias Ã³timas em jogos de soma zero
- **ValidaÃ§Ã£o de HeurÃ­sticas**: Base para desenvolvimento de heurÃ­sticas

### ğŸ“š EducaÃ§Ã£o em IA
- **Aprendizado de Algoritmos**: Exemplo clÃ¡ssico de busca em Ã¡rvores
- **OtimizaÃ§Ã£o**: Demonstra tÃ©cnicas de poda e otimizaÃ§Ã£o

## âš¡ OtimizaÃ§Ãµes Implementadas

### 1. ğŸ”ª Poda Alpha-Beta
- **ReduÃ§Ã£o Significativa**: Pode reduzir o nÃºmero de nÃ³s explorados em atÃ© 50%
- **Mesma Qualidade**: MantÃ©m a mesma qualidade de decisÃ£o
- **EficÃ¡cia**: Especialmente eficaz em jogos com muitos movimentos

### 2. ğŸ“ Busca em Profundidade Limitada
- **Controle de Tempo**: Permite controle do tempo de execuÃ§Ã£o
- **HeurÃ­sticas**: Pode ser combinado com funÃ§Ãµes de avaliaÃ§Ã£o
- **Escalabilidade**: Permite aplicaÃ§Ã£o em tabuleiros maiores

### 3. ğŸ’¾ MemoizaÃ§Ã£o
- **Cache de Estados**: Evita recÃ¡lculo de estados jÃ¡ explorados
- **EficiÃªncia**: Melhora significativamente o desempenho em jogos repetitivos

## ğŸ§ª Testes e ValidaÃ§Ã£o

### âœ… Testes UnitÃ¡rios
- **Funcionalidade BÃ¡sica**: CriaÃ§Ã£o de tabuleiro, movimentos, detecÃ§Ã£o de vitÃ³ria
- **Algoritmo Minimax**: CorreÃ§Ã£o da lÃ³gica de busca e avaliaÃ§Ã£o
- **Casos Extremos**: Estados terminais, empates, vitÃ³rias imediatas

### ğŸ“ˆ Testes de Performance
- **Benchmark**: ComparaÃ§Ã£o de tempos para diferentes tamanhos de tabuleiro
- **AnÃ¡lise de Complexidade**: ValidaÃ§Ã£o das estimativas teÃ³ricas
- **Limites PrÃ¡ticos**: DeterminaÃ§Ã£o dos limites de aplicabilidade

## ğŸ’¡ Exemplos de Uso

### ğŸ¯ Exemplo BÃ¡sico
```python
from tic_tac_toe_minimax import TicTacToeBoard, get_best_move

# Cria tabuleiro 3Ã—3
board = TicTacToeBoard(3)

# Determina melhor movimento para X
best_move = get_best_move(board)
print(f"Melhor movimento: {best_move}")

# Faz o movimento
board.make_move(*best_move)
```

### ğŸ² Exemplo de Jogo Completo
```python
from tic_tac_toe_minimax import play_optimal_game

# Simula jogo Ã³timo 3Ã—3
game_history = play_optimal_game(3)

# Analisa resultado
final_state = game_history[-1]
print(f"Resultado: {final_state['game_result']}")
```

### ğŸ“Š Exemplo de AnÃ¡lise de Complexidade
```python
from tic_tac_toe_minimax import analyze_minimax_complexity

# Analisa diferentes tamanhos de tabuleiro
for size in [3, 4, 5]:
    analysis = analyze_minimax_complexity(size)
    print(f"Tabuleiro {size}Ã—{size}: {analysis['complexity_class']}")
```

## ğŸ¯ ConclusÃ£o

A implementaÃ§Ã£o do Jogo da Velha com algoritmo Minimax demonstra a aplicaÃ§Ã£o prÃ¡tica do backtracking em Ã¡rvores de jogo. O algoritmo fornece:

1. **SoluÃ§Ã£o Ã“tima**: Determina o melhor movimento possÃ­vel
2. **Base TeÃ³rica**: Ilustra conceitos fundamentais de IA e teoria dos jogos
3. **Escalabilidade**: Demonstra limitaÃ§Ãµes e otimizaÃ§Ãµes necessÃ¡rias
4. **Aplicabilidade**: Serve como base para jogos mais complexos

Esta implementaÃ§Ã£o serve como um excelente exemplo educacional e ponto de partida para algoritmos mais sofisticados em jogos e IA. 