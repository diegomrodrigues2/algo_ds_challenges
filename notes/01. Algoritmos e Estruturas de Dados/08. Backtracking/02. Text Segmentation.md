# Text Segmentation (Segmentação de Texto)

## Visão Geral do Problema

O problema de Segmentação de Texto (Word Break) é um problema clássico de backtracking que consiste em determinar se uma string sem espaços pode ser segmentada em uma sequência de palavras válidas, usando uma função `is_word(substring)` que verifica se uma substring é uma palavra válida.

### Definição Formal

**Entrada:**
- Uma string `S` sem espaços de comprimento `n`
- Uma função `is_word(substring)` que retorna `True` se a substring for uma palavra válida

**Saída:**
- Uma lista de palavras `[w₁, w₂, ..., wₖ]` tal que `S = w₁ + w₂ + ... + wₖ` e cada `wᵢ` é uma palavra válida
- `None` se não existir tal segmentação

### Exemplo

```
Entrada: S = "helloworld"
         is_word("hello") = True
         is_word("world") = True
         is_word("helloworld") = False

Saída: ["hello", "world"]
```

## Estratégia de Backtracking

### Árvore de Decisão

A recursão para segmentação de texto pode ser visualizada como uma árvore de decisão onde cada nó representa uma posição na string e as arestas representam diferentes prefixos válidos:

```
                    "helloworld"
                    /           \
              "hello"           "h"
              /     \           |
         "world"    "wo"      "he"
         /           |         |
      [] (sucesso)  "rld"    "llo"
                    /         |
                  []         "world"
                            /
                          [] (sucesso)
```

### Pseudocódigo Recursivo

```
function SEGMENTABLE(S, start, is_word):
    if start == length(S):
        return []
    
    for end from start+1 to length(S):
        prefix = S[start..end-1]
        if is_word(prefix):
            remaining = SEGMENTABLE(S, end, is_word)
            if remaining != None:
                return [prefix] + remaining
    
    return None
```

### Implementação em Python

```python
def text_segmentation_backtracking(text: str, is_word_func) -> Optional[List[str]]:
    if not text:
        return []
    
    def backtrack(start: int) -> Optional[List[str]]:
        # Caso base: chegamos ao final da string
        if start == len(text):
            return []
        
        # Tenta todos os prefixos possíveis a partir da posição atual
        for end in range(start + 1, len(text) + 1):
            prefix = text[start:end]
            
            # Se o prefixo é uma palavra válida
            if is_word_func(prefix):
                # Recursivamente tenta segmentar o restante
                remaining = backtrack(end)
                if remaining is not None:
                    return [prefix] + remaining
        
        # Nenhuma segmentação encontrada
        return None
    
    return backtrack(0)
```

## Análise de Complexidade

### Relação de Recorrência

A relação de recorrência para o algoritmo de backtracking é:

```
T(n) = Σ T(n-i) para i de 1 a n
```

Onde:
- `T(n)` é o tempo para segmentar uma string de comprimento `n`
- Para cada posição `start`, tentamos todos os prefixos possíveis
- Se um prefixo de comprimento `i` é válido, recursivamente resolvemos o subproblema de tamanho `n-i`

### Análise de Tempo

#### Pior Caso: O(2^n)
- Cada posição pode tentar até `n` prefixos diferentes
- No pior caso, todos os prefixos são válidos
- Isso leva a uma árvore de recursão exponencial

#### Caso Médio: O(n²)
- Com memoização, cada subproblema é resolvido apenas uma vez
- Existem `O(n)` subproblemas únicos
- Cada subproblema pode tentar até `O(n)` prefixos

#### Melhor Caso: O(n)
- Quando a primeira tentativa sempre funciona
- Por exemplo: string "aaaa" com dicionário ["a", "aa", "aaa", "aaaa"]

### Análise de Espaço

#### Pilha de Recursão: O(n)
- A profundidade máxima da pilha de recursão é `n`
- Cada chamada recursiva armazena a posição atual

#### Memoização: O(n)
- Armazena resultados para cada posição
- No máximo `n` entradas no dicionário de memoização

#### Total: O(n)
- Espaço total é limitado pela pilha de recursão + memoização

## Otimizações Implementadas

### 1. Memoização

A memoização é crucial para este problema devido à sobreposição massiva de subproblemas:

```python
def text_segmentation_with_memoization(text: str, is_word_func) -> Optional[List[str]]:
    memo: Dict[int, Optional[List[str]]] = {}
    
    def backtrack(start: int) -> Optional[List[str]]:
        # Verifica se já calculamos este subproblema
        if start in memo:
            return memo[start]
        
        # ... resto da lógica ...
        
        memo[start] = result
        return result
```

**Benefícios:**
- Evita recálculo de subproblemas
- Reduz complexidade de O(2^n) para O(n²)
- Melhora drasticamente a performance na prática

### 2. Ordenação de Tentativas

Tentar prefixos maiores primeiro pode encontrar soluções mais rapidamente:

```python
# Tenta prefixos em ordem decrescente de tamanho
for end in range(len(text), start, -1):
    prefix = text[start:end]
```

**Benefícios:**
- Encontra soluções com menos palavras primeiro
- Pode reduzir o número de tentativas necessárias
- Melhora a performance em casos específicos

### 3. Early Termination

Detecção precoce de casos especiais:

```python
if start == len(text):
    return []  # Caso base: sucesso
```

## Variações Especializadas

### 1. Encontrar Todas as Soluções

```python
def text_segmentation_all_solutions(text: str, is_word_func) -> List[List[str]]:
    solutions = []
    
    def backtrack(start: int, current_segmentation: List[str]):
        if start == len(text):
            solutions.append(current_segmentation[:])
            return
        
        for end in range(start + 1, len(text) + 1):
            prefix = text[start:end]
            if is_word_func(prefix):
                current_segmentation.append(prefix)
                backtrack(end, current_segmentation)
                current_segmentation.pop()  # Backtrack
    
    backtrack(0, [])
    return solutions
```

### 2. Contar Soluções

```python
def text_segmentation_count_solutions(text: str, is_word_func) -> int:
    memo: Dict[int, int] = {}
    
    def backtrack(start: int) -> int:
        if start in memo:
            return memo[start]
        
        if start == len(text):
            return 1
        
        count = 0
        for end in range(start + 1, len(text) + 1):
            prefix = text[start:end]
            if is_word_func(prefix):
                count += backtrack(end)
        
        memo[start] = count
        return count
    
    return backtrack(0)
```

## Análise Detalhada da Complexidade

### Subproblemas Sobrepostos

O problema de segmentação de texto apresenta sobreposição massiva de subproblemas:

```
Exemplo: "aaaa" com dicionário ["a", "aa", "aaa", "aaaa"]

Subproblemas:
- SEGMENTABLE("aaaa", 0) chama:
  - SEGMENTABLE("aaaa", 1) (após "a")
  - SEGMENTABLE("aaaa", 2) (após "aa")
  - SEGMENTABLE("aaaa", 3) (após "aaa")
  - SEGMENTABLE("aaaa", 4) (após "aaaa")

- SEGMENTABLE("aaaa", 1) chama:
  - SEGMENTABLE("aaaa", 2) (após "a")
  - SEGMENTABLE("aaaa", 3) (após "aa")
  - SEGMENTABLE("aaaa", 4) (após "aaa")

Note que SEGMENTABLE("aaaa", 2) é chamado múltiplas vezes!
```

### Impacto da Memoização

Sem memoização:
- **Tempo**: O(2^n) - cada subproblema pode ser resolvido múltiplas vezes
- **Espaço**: O(n) - apenas a pilha de recursão

Com memoização:
- **Tempo**: O(n²) - cada subproblema é resolvido apenas uma vez
- **Espaço**: O(n) - pilha de recursão + memoização

## Aplicações Práticas

### 1. Processamento de Linguagem Natural
- Segmentação de texto sem espaços (chinês, japonês)
- Reconhecimento de palavras em OCR
- Análise de texto em linguagens sem separadores

### 2. Compressão de Dados
- Segmentação para algoritmos de compressão
- Identificação de padrões repetitivos
- Otimização de dicionários de compressão

### 3. Sistemas de Busca
- Indexação de texto contínuo
- Busca por palavras-chave
- Análise de consultas de usuário

### 4. Reconhecimento de Padrões
- Identificação de palavras em sequências
- Análise de DNA/proteínas
- Processamento de sinais

### 5. Análise de Texto
- Processamento de documentos
- Extração de informações
- Classificação de texto

## Insights Teóricos

### 1. NP-Completeness
O problema de segmentação de texto é NP-completo na sua forma mais geral, mas pode ser resolvido eficientemente com memoização para casos práticos.

### 2. Subproblemas Sobrepostos
A sobreposição massiva de subproblemas torna este problema ideal para:
- Memoização
- Programação dinâmica
- Otimizações de cache

### 3. Estrutura Recursiva Natural
A definição recursiva é intuitiva e natural:
- Uma string é segmentável se existe um prefixo válido e o restante é segmentável
- Isso leva diretamente ao algoritmo de backtracking

### 4. Dependência do Dicionário
A performance depende muito da estrutura do dicionário:
- Dicionários densos (muitas palavras) → mais tentativas
- Dicionários esparsos (poucas palavras) → menos tentativas
- Palavras longas → menos recursões

### 5. Base para Programação Dinâmica
O backtracking com memoização é essencialmente programação dinâmica:
- Subproblemas sobrepostos
- Solução bottom-up possível
- Otimizações adicionais disponíveis

## Limites Teóricos

### 1. Número de Soluções
O número de segmentações possíveis pode ser exponencial:
- Para "aaaa" com dicionário ["a", "aa", "aaa", "aaaa"]: 4 soluções
- Para strings mais longas: pode crescer exponencialmente

### 2. Complexidade de Tempo
- **Sem otimizações**: O(2^n)
- **Com memoização**: O(n²)
- **Com otimizações adicionais**: O(n)

### 3. Complexidade de Espaço
- **Pilha de recursão**: O(n)
- **Memoização**: O(n)
- **Total**: O(n)

## Comparação com Outras Abordagens

### 1. Programação Dinâmica
- **Vantagem**: Solução bottom-up mais eficiente
- **Desvantagem**: Menos intuitiva que backtracking
- **Complexidade**: O(n²) tempo, O(n) espaço

### 2. Algoritmos Aproximados
- **Vantagem**: Muito rápidos
- **Desvantagem**: Podem não encontrar a solução ótima
- **Aplicação**: Quando velocidade é mais importante que optimalidade

### 3. Algoritmos Gulosos
- **Vantagem**: Extremamente rápidos
- **Desvantagem**: Podem falhar mesmo quando existe solução
- **Aplicação**: Heurísticas para casos específicos

## Variações do Problema

### 1. Segmentação com Pesos
Cada palavra tem um peso, objetivo é minimizar o peso total:
```python
def weighted_text_segmentation(text, is_word_func, weight_func):
    # Implementação com pesos
```

### 2. Segmentação Mínima
Encontrar a segmentação com menor número de palavras:
```python
def minimal_text_segmentation(text, is_word_func):
    # Implementação para mínimo número de palavras
```

### 3. Segmentação com Restrições
Limitações adicionais (comprimento máximo, palavras proibidas):
```python
def constrained_text_segmentation(text, is_word_func, constraints):
    # Implementação com restrições
```

### 4. Segmentação Probabilística
Probabilidades para cada palavra:
```python
def probabilistic_text_segmentation(text, word_probs):
    # Implementação com probabilidades
```

### 5. Segmentação Múltipla
Múltiplos dicionários ou idiomas:
```python
def multi_dict_text_segmentation(text, dicts):
    # Implementação com múltiplos dicionários
```

## Conclusão

O problema de Segmentação de Texto é um excelente exemplo de como backtracking pode ser aplicado a problemas práticos de processamento de texto. A sobreposição massiva de subproblemas torna a memoização crucial para performance, e a estrutura recursiva natural torna o algoritmo intuitivo e fácil de implementar.

As otimizações implementadas (memoização, ordenação de tentativas, early termination) demonstram como técnicas de otimização podem transformar um algoritmo exponencial em um algoritmo polinomial na prática, mantendo a simplicidade conceitual do backtracking. 