# Graph Coloring (Coloração de Grafos)

## Visão Geral

O problema de **Coloração de Grafos** é um problema NP-completo clássico que envolve atribuir cores aos vértices de um grafo de forma que vértices adjacentes tenham cores diferentes. É uma aplicação direta do backtracking para resolver problemas de satisfação de restrições em grafos.

### Definição Formal

**Entrada:**
- Um grafo `G = (V, E)` representado por matriz de adjacência
- Um inteiro `m` (número máximo de cores disponíveis)

**Saída:**
- Uma coloração válida `c: V → {1, 2, ..., m}` tal que `c(u) ≠ c(v)` para toda aresta `(u, v) ∈ E`
- `None` se não for possível colorir com `m` cores

## Estratégia do Algoritmo de Backtracking

### Árvore de Decisão por Vértice

Para cada vértice `vᵢ`, a recursão tenta atribuir uma cor de 1 a m:

```
                    v₀?
                   / | \
                  /  |  \
                 /   |   \
               Cor1 Cor2 Cor3
               /     |     \
            v₁?    v₁?    v₁?
           / | \  / | \  / | \
          /  |  \/  |  \/  |  \
       Cor1 Cor2 Cor3 Cor1 Cor2 Cor3
       / | \ / | \ / | \ / | \ / | \ / | \
      ... ... ... ... ... ... ... ... ... ...
```

### Algoritmo Recursivo

```python
def graph_coloring_backtracking(graph, m):
    V = len(graph)
    colors = [0] * V
    
    def is_safe(vertex, color):
        # Verifica se é seguro atribuir a cor ao vértice
        for i in range(V):
            if graph[vertex][i] == 1 and colors[i] == color:
                return False
        return True
    
    def graph_coloring_util(vertex):
        # Caso base: todos os vértices foram coloridos
        if vertex == V:
            return True
        
        # Tenta cada cor disponível para o vértice atual
        for color in range(1, m + 1):
            if is_safe(vertex, color):
                colors[vertex] = color
                
                # Recursão para o próximo vértice
                if graph_coloring_util(vertex + 1):
                    return True
                
                # Backtrack: remove a cor se não levou à solução
                colors[vertex] = 0
        
        # Nenhuma cor funcionou para este vértice
        return False
    
    return colors if graph_coloring_util(0) else None
```

## Análise de Complexidade

### Complexidade de Tempo

- **Pior caso**: O(m^V) - tenta m cores para cada vértice
- **Melhor caso**: O(V × m) - quando cada vértice pode ser colorido na primeira tentativa
- **Caso médio**: Depende da estrutura do grafo e do número de cores

### Complexidade de Espaço

- **Recursão**: O(V) - profundidade da pilha de recursão
- **Memoização**: O(V × m^V) - tabela de memoização

### Relação de Recorrência

```
T(V) = m × T(V-1) + O(V)
```

A solução é:
```
T(V) = O(m^V)
```

## Otimizações Implementadas

### 1. Ordenação por Grau

```python
degrees = [sum(graph[i]) for i in range(V)]
vertex_order = sorted(range(V), key=lambda x: degrees[x], reverse=True)
```

**Vantagens:**
- Colore vértices de maior grau primeiro
- Reduz o número de backtrackings necessários
- Aproveita restrições mais restritivas cedo

### 2. Verificação Eficiente

```python
def is_safe(vertex, color):
    for i in range(V):
        if graph[vertex][i] == 1 and colors[i] == color:
            return False
    return True
```

**Características:**
- Verifica apenas vértices adjacentes
- Early termination quando possível
- O(V) no pior caso, mas O(1) em média

### 3. Memoização

```python
def get_state_key(vertex):
    return f"{vertex}:{tuple(colors[:vertex])}"

memo = {}
def graph_coloring_memoized(vertex):
    state_key = get_state_key(vertex)
    if state_key in memo:
        return memo[state_key]
    # ... resto do algoritmo
```

**Benefícios:**
- Evita recálculos de estados já visitados
- Melhora performance para grafos com padrões repetitivos
- Trade-off entre tempo e espaço

## Aplicações Práticas

### 1. Coloração de Mapas
- **Problema**: Colorir países/estados vizinhos com cores diferentes
- **Aplicação**: Cartografia, design de mapas políticos
- **Teorema das Quatro Cores**: Qualquer mapa planar pode ser colorido com 4 cores

### 2. Agendamento de Exames
- **Problema**: Agendar exames simultâneos sem conflitos de estudantes
- **Modelo**: Cada exame é um vértice, estudantes em comum criam arestas
- **Cores**: Representam horários diferentes

### 3. Alocação de Registradores
- **Problema**: Alocar variáveis em registradores sem conflitos
- **Modelo**: Variáveis são vértices, uso simultâneo cria arestas
- **Cores**: Representam registradores diferentes

### 4. Problema do Sudoku
- **Problema**: Preencher grade 9×9 com números 1-9
- **Modelo**: Cada célula é um vértice, células na mesma linha/coluna/bloco são adjacentes
- **Cores**: Representam números de 1 a 9

### 5. Design de Redes
- **Problema**: Alocar canais de comunicação sem interferência
- **Modelo**: Canais são vértices, interferência cria arestas
- **Cores**: Representam frequências diferentes

## Insights Teóricos

### Número Cromático

O **número cromático** χ(G) de um grafo G é o menor número de cores necessárias para colorir G.

**Propriedades:**
- χ(G) ≤ Δ(G) + 1 (onde Δ(G) é o grau máximo)
- χ(G) ≥ ω(G) (onde ω(G) é o tamanho do maior clique)
- Para grafos bipartidos: χ(G) = 2

### Grafo Bipartido

Um grafo é **bipartido** se seus vértices podem ser divididos em dois conjuntos independentes.

**Características:**
- Pode ser colorido com 2 cores
- Não contém ciclos ímpares
- Algoritmo de detecção: BFS com coloração

### Teorema das Quatro Cores

**Enunciado**: Qualquer mapa planar pode ser colorido com no máximo 4 cores.

**Significado:**
- Aplica-se a grafos planares
- Limite superior para coloração de mapas
- Demonstrado em 1976 usando computador

### Heurísticas de Coloração

#### 1. Welsh-Powell
```python
def welsh_powell_coloring(graph):
    # Ordena vértices por grau decrescente
    vertices = sorted(range(V), key=lambda x: degrees[x], reverse=True)
    colors = [0] * V
    
    for vertex in vertices:
        # Encontra a menor cor disponível
        used_colors = set(colors[adj] for adj in range(V) 
                         if graph[vertex][adj] == 1 and colors[adj] > 0)
        color = 1
        while color in used_colors:
            color += 1
        colors[vertex] = color
    
    return colors
```

#### 2. DSatur (Degree of Saturation)
- Considera o número de cores diferentes usadas pelos vizinhos
- Escolhe vértices com maior saturação
- Geralmente produz colorações com menos cores

## Variações do Problema

### 1. Coloração de Arestas
- **Problema**: Colorir arestas em vez de vértices
- **Restrição**: Arestas incidentes ao mesmo vértice devem ter cores diferentes
- **Aplicação**: Agendamento de tarefas em máquinas

### 2. Coloração Lista
- **Problema**: Cada vértice tem uma lista de cores permitidas
- **Restrição**: c(v) ∈ L(v) para todo vértice v
- **Aplicação**: Alocação de recursos com preferências

### 3. Coloração Total
- **Problema**: Colorir vértices e arestas simultaneamente
- **Restrições**: 
  - Vértices adjacentes têm cores diferentes
  - Arestas incidentes ao mesmo vértice têm cores diferentes
  - Vértice e suas arestas têm cores diferentes

### 4. Coloração com Pesos
- **Problema**: Minimizar custo total das cores usadas
- **Função objetivo**: min ∑(v∈V) w(c(v))
- **Aplicação**: Otimização de custos em alocação

### 5. Coloração Online
- **Problema**: Decidir cores sem conhecer o grafo completo
- **Característica**: Vértices chegam sequencialmente
- **Aplicação**: Alocação dinâmica de recursos

## Implementações Específicas

### Contagem de Soluções

```python
def graph_coloring_count_solutions(graph, m):
    V = len(graph)
    colors = [0] * V
    solution_count = [0]
    
    def count_solutions_util(vertex):
        if vertex == V:
            solution_count[0] += 1
            return
        
        for color in range(1, m + 1):
            if is_safe(vertex, color):
                colors[vertex] = color
                count_solutions_util(vertex + 1)
                colors[vertex] = 0
    
    count_solutions_util(0)
    return solution_count[0]
```

### Todas as Soluções

```python
def graph_coloring_all_solutions(graph, m):
    V = len(graph)
    colors = [0] * V
    solutions = []
    
    def find_all_solutions_util(vertex):
        if vertex == V:
            solutions.append(colors.copy())
            return
        
        for color in range(1, m + 1):
            if is_safe(vertex, color):
                colors[vertex] = color
                find_all_solutions_util(vertex + 1)
                colors[vertex] = 0
    
    find_all_solutions_util(0)
    return solutions
```

### Análise de Complexidade

```python
def analyze_graph_coloring_complexity(graph, m):
    V = len(graph)
    E = sum(sum(row) for row in graph) // 2
    degrees = [sum(graph[i]) for i in range(V)]
    max_degree = max(degrees) if degrees else 0
    avg_degree = sum(degrees) / V if V > 0 else 0
    
    return {
        "vertices": V,
        "edges": E,
        "colors": m,
        "max_degree": max_degree,
        "avg_degree": avg_degree,
        "worst_case_time": m ** V,
        "best_case_time": V * m,
        "chromatic_number_upper_bound": max_degree + 1,
        "chromatic_number_lower_bound": max(1, V // (V - max_degree)) if max_degree < V else 1
    }
```

## Conexão com CSP

O problema de coloração de grafos é um **Problema de Satisfação de Restrições (CSP)**:

### Variáveis
- `c(v)` para cada vértice v ∈ V

### Domínios
- D(v) = {1, 2, ..., m} para cada vértice v

### Restrições
- `c(u) ≠ c(v)` para toda aresta (u, v) ∈ E

### Algoritmos CSP Aplicáveis
- **Backtracking**: Implementação básica
- **Forward Checking**: Elimina valores inconsistentes
- **Arc Consistency**: Propaga restrições
- **Min-Conflicts**: Heurística para otimização local

## Referências

- **InterviewBit**: [Graph Coloring Algorithm using Backtracking](https://www.interviewbit.com/courses/programming/backtracking/graph-coloring-algorithm-using-backtracking/)
- **GeeksforGeeks**: [M-Coloring Problem](https://www.geeksforgeeks.org/dsa/m-coloring-problem-in-python/)
- **TheAlgorithms/Python**: [coloring.py](https://github.com/TheAlgorithms/Python/blob/master/backtracking/coloring.py)
- **CSP Map Coloring**: [CSP-Map-coloring-using-Backtracking](https://github.com/jaiswalchitransh/CSP-Map-coloring-using-Backtracking)
- **Erickson, "Algorithms"**: Capítulo sobre backtracking e problemas NP-completos
- **Research Papers**: Análise de complexidade e otimizações para coloração de grafos 