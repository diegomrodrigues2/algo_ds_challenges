# Hamiltonian Path (Caminho Hamiltoniano)

## Visão Geral

O problema do **Caminho Hamiltoniano** é um problema NP-completo clássico que envolve encontrar um caminho em um grafo que visite todos os vértices exatamente uma vez. É uma aplicação direta do backtracking para resolver problemas de busca em grafos.

### Definição Formal

**Entrada:**
- Um grafo `G = (V, E)` representado por matriz de adjacência

**Saída:**
- Uma sequência de vértices `(v₁, v₂, ..., vₙ)` tal que:
  - Todos os vértices são visitados exatamente uma vez
  - Vértices consecutivos são adjacentes: `(vᵢ, vᵢ₊₁) ∈ E`
- `None` se não existir caminho Hamiltoniano

## Estratégia do Algoritmo de Backtracking

### Árvore de Decisão por Vértice

Para cada vértice, a recursão tenta adicionar um vértice adjacente não visitado:

```
                    v₀?
                   / | \
                  /  |  \
                 /   |   \
               v₁   v₂   v₃
               /     |     \
            v₂?    v₁?    v₁?
           / | \  / | \  / | \
          /  |  \/  |  \/  |  \
       v₃? v₀? v₃? v₀? v₃? v₀?
       / | \ / | \ / | \ / | \ / | \ / | \ / | \
      ... ... ... ... ... ... ... ... ... ...
```

### Algoritmo Recursivo

```python
def hamiltonian_path_backtracking(graph):
    V = len(graph)
    visited = [False] * V
    path = []
    
    def hamiltonian_path_util(vertex, path_count):
        # Marca o vértice atual como visitado
        visited[vertex] = True
        path.append(vertex)
        
        # Caso base: todos os vértices foram visitados
        if path_count == V:
            return True
        
        # Tenta todos os vértices adjacentes
        for next_vertex in range(V):
            if (graph[vertex][next_vertex] == 1 and 
                not visited[next_vertex]):
                
                # Recursão para o próximo vértice
                if hamiltonian_path_util(next_vertex, path_count + 1):
                    return True
        
        # Backtrack: remove o vértice do caminho se não levou à solução
        visited[vertex] = False
        path.pop()
        return False
    
    # Tenta começar de cada vértice
    for start_vertex in range(V):
        if hamiltonian_path_util(start_vertex, 1):
            return path.copy()
    
    return None
```

## Análise de Complexidade

### Complexidade de Tempo

- **Pior caso**: O(V!) - explora todas as permutações possíveis
- **Melhor caso**: O(V) - quando encontra rapidamente
- **Caso médio**: Depende da estrutura do grafo

### Complexidade de Espaço

- **Recursão**: O(V) - profundidade da pilha de recursão
- **Memoização**: O(V × 2^V) - tabela de memoização

### Relação de Recorrência

```
T(V) = V × T(V-1) + O(V)
```

A solução é:
```
T(V) = O(V!)
```

## Otimizações Implementadas

### 1. Ordenação por Grau

```python
degrees = [sum(graph[i]) for i in range(V)]
vertex_order = sorted(range(V), key=lambda x: degrees[x], reverse=True)
```

**Vantagens:**
- Tenta vértices de maior grau primeiro
- Reduz o número de backtrackings necessários
- Aproveita vértices mais conectados cedo

### 2. Verificação Eficiente

```python
if (graph[vertex][next_vertex] == 1 and 
    not visited[next_vertex]):
```

**Características:**
- Verifica adjacência e visitação em O(1)
- Early termination quando possível
- Evita tentativas desnecessárias

### 3. Memoização

```python
def get_state_key(vertex, path_count):
    return f"{vertex}:{path_count}:{tuple(visited)}"

memo = {}
def hamiltonian_path_memoized(vertex, path_count):
    state_key = get_state_key(vertex, path_count)
    if state_key in memo:
        return memo[state_key]
    # ... resto do algoritmo
```

**Benefícios:**
- Evita recálculos de estados já visitados
- Melhora performance para grafos com padrões repetitivos
- Trade-off entre tempo e espaço

## Aplicações Práticas

### 1. Problema do Caixeiro Viajante (TSP)
- **Problema**: Encontrar rota mais curta visitando todas as cidades uma vez
- **Modelo**: Cidades são vértices, distâncias são arestas
- **Caminho Hamiltoniano**: Caso especial do TSP com custos unitários

### 2. Sequenciamento de DNA
- **Problema**: Reconstruir sequência genética a partir de fragmentos
- **Modelo**: Fragmentos são vértices, sobreposições são arestas
- **Caminho Hamiltoniano**: Ordem ótima de montagem

### 3. Design de Circuitos
- **Problema**: Conectar componentes sem cruzar fios
- **Modelo**: Componentes são vértices, conexões são arestas
- **Caminho Hamiltoniano**: Rota de conexão ótima

### 4. Agendamento de Tarefas
- **Problema**: Ordenar tarefas com dependências
- **Modelo**: Tarefas são vértices, dependências são arestas
- **Caminho Hamiltoniano**: Sequência de execução válida

### 5. Roteamento de Pacotes
- **Problema**: Encontrar rota ótima em rede de computadores
- **Modelo**: Nós são vértices, links são arestas
- **Caminho Hamiltoniano**: Rota que visita todos os nós

## Insights Teóricos

### Condições Necessárias

**Para Caminho Hamiltoniano:**
- Grau mínimo ≥ 1 (cada vértice deve ter pelo menos uma conexão)

**Para Ciclo Hamiltoniano:**
- Grau mínimo ≥ 2 (cada vértice deve ter pelo menos duas conexões)

### Condições Suficientes

**Teorema de Dirac:**
- Se grau mínimo ≥ V/2, então existe ciclo Hamiltoniano

**Teorema de Ore:**
- Se para cada par de vértices não adjacentes, a soma dos graus ≥ V, então existe ciclo Hamiltoniano

### Conexão com TSP

O **Problema do Caixeiro Viajante (TSP)** é uma generalização do Caminho Hamiltoniano:
- Caminho Hamiltoniano: custos unitários
- TSP: custos arbitrários nas arestas

### Heurísticas de Busca

#### 1. Ordenação por Grau
```python
def order_by_degree(graph):
    degrees = [sum(graph[i]) for i in range(V)]
    return sorted(range(V), key=lambda x: degrees[x], reverse=True)
```

#### 2. Busca em Profundidade com Poda
```python
def dfs_with_pruning(vertex, visited, path):
    if len(path) == V:
        return path
    
    # Poda: verifica se ainda é possível completar o caminho
    if not can_complete_path(vertex, visited):
        return None
    
    for next_vertex in get_unvisited_neighbors(vertex):
        # ... recursão
```

## Variações do Problema

### 1. Ciclo Hamiltoniano
- **Problema**: Caminho que forma um ciclo
- **Restrição**: Último vértice deve se conectar ao primeiro
- **Aplicação**: Circuitos fechados, rotas circulares

### 2. Caminho Hamiltoniano Direcionado
- **Problema**: Em grafos direcionados
- **Restrição**: Arestas têm direção
- **Aplicação**: Fluxo de trabalho, dependências temporais

### 3. Caminho Hamiltoniano com Pesos
- **Problema**: Minimizar custo total do caminho
- **Função objetivo**: min ∑(i=1 to n-1) w(vᵢ, vᵢ₊₁)
- **Aplicação**: TSP, roteamento com custos

### 4. Caminho Hamiltoniano com Restrições
- **Problema**: Limitações na ordem de visitação
- **Restrições**: Vértices específicos devem ser visitados em ordem
- **Aplicação**: Agendamento com prioridades

### 5. Caminho Hamiltoniano Online
- **Problema**: Decidir sem conhecer o grafo completo
- **Característica**: Vértices chegam sequencialmente
- **Aplicação**: Roteamento dinâmico

## Implementações Específicas

### Ciclo Hamiltoniano

```python
def hamiltonian_cycle_backtracking(graph):
    V = len(graph)
    visited = [False] * V
    path = []
    
    def hamiltonian_cycle_util(vertex, path_count):
        visited[vertex] = True
        path.append(vertex)
        
        if path_count == V:
            # Verifica se o último vértice se conecta ao primeiro
            if graph[vertex][path[0]] == 1:
                return True
            else:
                visited[vertex] = False
                path.pop()
                return False
        
        for next_vertex in range(V):
            if (graph[vertex][next_vertex] == 1 and 
                not visited[next_vertex]):
                
                if hamiltonian_cycle_util(next_vertex, path_count + 1):
                    return True
        
        visited[vertex] = False
        path.pop()
        return False
    
    # Tenta começar de cada vértice
    for start_vertex in range(V):
        if hamiltonian_cycle_util(start_vertex, 1):
            return path.copy()
    
    return None
```

### Contagem de Soluções

```python
def hamiltonian_path_count_solutions(graph):
    V = len(graph)
    visited = [False] * V
    solution_count = [0]
    
    def count_solutions_util(vertex, path_count):
        visited[vertex] = True
        
        if path_count == V:
            solution_count[0] += 1
            visited[vertex] = False
            return
        
        for next_vertex in range(V):
            if (graph[vertex][next_vertex] == 1 and 
                not visited[next_vertex]):
                count_solutions_util(next_vertex, path_count + 1)
        
        visited[vertex] = False
    
    # Conta soluções começando de cada vértice
    for start_vertex in range(V):
        count_solutions_util(start_vertex, 1)
    
    return solution_count[0]
```

### Análise de Complexidade

```python
def analyze_hamiltonian_path_complexity(graph):
    V = len(graph)
    E = sum(sum(row) for row in graph) // 2
    degrees = [sum(graph[i]) for i in range(V)]
    max_degree = max(degrees) if degrees else 0
    avg_degree = sum(degrees) / V if V > 0 else 0
    min_degree = min(degrees) if degrees else 0
    
    # Análise de complexidade
    worst_case_time = 1
    for i in range(V):
        worst_case_time *= (V - i)  # V! = V × (V-1) × ... × 1
    
    best_case_time = V  # Se encontrar rapidamente
    estimated_time = V * (avg_degree ** (V - 1))
    
    return {
        "vertices": V,
        "edges": E,
        "max_degree": max_degree,
        "avg_degree": avg_degree,
        "min_degree": min_degree,
        "worst_case_time": worst_case_time,
        "best_case_time": best_case_time,
        "estimated_time": estimated_time,
        "space_complexity": V,
        "is_sparse": E < V * (V - 1) / 4,
        "is_dense": E > V * (V - 1) / 2,
        "is_complete": E == V * (V - 1) / 2,
        "has_hamiltonian_path_necessary_condition": min_degree >= 1,
        "has_hamiltonian_cycle_necessary_condition": min_degree >= 2
    }
```

## Conexão com Outros Problemas

### Problema do Caixeiro Viajante (TSP)
- **Relação**: TSP é generalização do Caminho Hamiltoniano
- **Diferença**: TSP tem custos arbitrários, Caminho Hamiltoniano tem custos unitários
- **Algoritmos**: Técnicas de TSP aplicáveis ao Caminho Hamiltoniano

### Permutações
- **Relação**: Cada caminho Hamiltoniano é uma permutação dos vértices
- **Diferença**: Permutações não consideram adjacência
- **Aplicação**: Geração de permutações com restrições

### Coloração de Grafos
- **Relação**: Ambos são problemas NP-completos em grafos
- **Diferença**: Coloração atribui cores, Caminho Hamiltoniano encontra ordem
- **Técnicas**: Backtracking aplicável a ambos

## Referências

- **Wikipedia**: [Hamiltonian path problem](https://en.wikipedia.org/wiki/Hamiltonian_path_problem)
- **HackerEarth**: [Hamiltonian Path Tutorial](https://www.hackerearth.com/practice/algorithms/graphs/hamiltonian-path/tutorial/)
- **TheAlgorithms/Python**: [hamiltonian_cycle.py](https://github.com/TheAlgorithms/Python/blob/master/backtracking/hamiltonian_cycle.py)
- **NetworkX Implementation**: [mikkelam/hamilton.py](https://gist.github.com/mikkelam/ab7966e7ab1c441f947b)
- **Erickson, "Algorithms"**: Capítulo sobre backtracking e problemas NP-completos
- **Research Papers**: Análise de complexidade e otimizações para caminhos Hamiltonianos 