# Longest Increasing Subsequence (LIS) - Versão Backtracking

## Visão Geral do Problema

O problema da Subsequência Crescente Mais Longa (LIS) é um problema clássico de algoritmos que consiste em encontrar a subsequência mais longa de uma sequência de números onde cada elemento é maior que o anterior.

**Definição Formal:**
Dada uma sequência A[1..n] de números, encontrar a subsequência A[i₁], A[i₂], ..., A[iₖ] tal que:
- i₁ < i₂ < ... < iₖ (índices em ordem crescente)
- A[i₁] < A[i₂] < ... < A[iₖ] (valores em ordem crescente)
- k é o maior possível

**Vínculo Conceitual:** Erickson, "Algorithms", Capítulo 2, Seção 2.6, "Longest Increasing Subsequence"

## Formulação de Erickson

Erickson apresenta a formulação recursiva LISbigger(prev, A[j..n]):

```
LISbigger(prev, A[j..n]) = max(
    LISbigger(prev, A[j+1..n]),           # skip A[j]
    1 + LISbigger(A[j], A[j+1..n])        # include A[j] if A[j] > prev
)
```

Esta formulação pergunta: "Qual é o comprimento da LIS no restante do array, onde todos os elementos devem ser maiores que prev?"

## Estratégia de Backtracking

### Árvore de Decisão Binária

Para cada elemento A[j], a recursão decide:
1. **Incluir A[j]**: Se A[j] > prev, então A[j] pode ser o próximo elemento da LIS
2. **Ignorar A[j]**: Continuar procurando sem incluir A[j]

```
                    LISbigger(prev, A[j..n])
                    /                        \
        LISbigger(prev, A[j+1..n])    1 + LISbigger(A[j], A[j+1..n])
        (skip A[j])                    (include A[j] if A[j] > prev)
```

### Pseudocódigo

```python
def LISbigger(prev, A, j):
    if j >= len(A):
        return 0
    
    # Skip current element
    skip = LISbigger(prev, A, j + 1)
    
    # Include current element if it's greater than prev
    include = 0
    if A[j] > prev:
        include = 1 + LISbigger(A[j], A, j + 1)
    
    return max(skip, include)

def LIS(A):
    return LISbigger(-∞, A, 0)
```

## Análise de Complexidade

### Tempo

**Sem Memoização:**
- Relação de recorrência: T(n) = 2 × T(n-1) + O(1)
- Solução: T(n) = O(2^n)
- Cada elemento gera duas chamadas recursivas

**Com Memoização:**
- Estados únicos: O(n²) - (index, prev) pairs
- Tempo por estado: O(1)
- Complexidade total: O(n²)

### Espaço

**Sem Memoização:**
- Profundidade da recursão: O(n)
- Espaço total: O(n)

**Com Memoização:**
- Tabela de memoização: O(n²)
- Pilha de recursão: O(n)
- Espaço total: O(n²)

## Implementações Especializadas

### 1. Backtracking Básico

```python
def lis_backtracking(sequence):
    def backtrack(index, prev):
        if index >= len(sequence):
            return 0
        
        # Skip current element
        skip = backtrack(index + 1, prev)
        
        # Include current element if it's greater than previous
        include = 0
        if sequence[index] > prev:
            include = 1 + backtrack(index + 1, sequence[index])
        
        return max(skip, include)
    
    return backtrack(0, float('-inf'))
```

### 2. Backtracking com Memoização

```python
def lis_backtracking_with_memoization(sequence):
    memo = {}
    
    def backtrack(index, prev):
        if index >= len(sequence):
            return 0
        
        state = (index, prev)
        if state in memo:
            return memo[state]
        
        # Skip current element
        skip = backtrack(index + 1, prev)
        
        # Include current element if it's greater than previous
        include = 0
        if sequence[index] > prev:
            include = 1 + backtrack(index + 1, sequence[index])
        
        memo[state] = max(skip, include)
        return memo[state]
    
    return backtrack(0, float('-inf'))
```

### 3. Encontrar Todas as Soluções

```python
def lis_backtracking_all_solutions(sequence):
    max_length = 0
    all_solutions = []
    
    def backtrack(index, prev, current):
        nonlocal max_length
        
        if index >= len(sequence):
            if len(current) > max_length:
                max_length = len(current)
                all_solutions.clear()
                all_solutions.append(current[:])
            elif len(current) == max_length:
                all_solutions.append(current[:])
            return
        
        # Skip current element
        backtrack(index + 1, prev, current)
        
        # Include current element if it's greater than previous
        if sequence[index] > prev:
            current.append(sequence[index])
            backtrack(index + 1, sequence[index], current)
            current.pop()
    
    backtrack(0, float('-inf'), [])
    return all_solutions
```

### 4. Contar Soluções

```python
def lis_backtracking_count_solutions(sequence):
    max_length = 0
    count = 0
    
    def backtrack(index, prev, current_length):
        nonlocal max_length, count
        
        if index >= len(sequence):
            if current_length > max_length:
                max_length = current_length
                count = 1
            elif current_length == max_length:
                count += 1
            return
        
        # Skip current element
        backtrack(index + 1, prev, current_length)
        
        # Include current element if it's greater than previous
        if sequence[index] > prev:
            backtrack(index + 1, sequence[index], current_length + 1)
    
    backtrack(0, float('-inf'), 0)
    return (max_length, count)
```

### 5. Backtracking Otimizado

```python
def lis_backtracking_optimized(sequence):
    n = len(sequence)
    best_length = 0
    
    def backtrack(index, prev, current_length):
        nonlocal best_length
        
        # Early termination: if remaining elements + current length <= best
        remaining = n - index
        if current_length + remaining <= best_length:
            return
        
        if index >= n:
            best_length = max(best_length, current_length)
            return
        
        # Skip current element
        backtrack(index + 1, prev, current_length)
        
        # Include current element if it's greater than previous
        if sequence[index] > prev:
            backtrack(index + 1, sequence[index], current_length + 1)
    
    backtrack(0, float('-inf'), 0)
    return best_length
```

## Otimizações Implementadas

### 1. Memoização
- **Objetivo**: Evitar recálculo de subproblemas
- **Implementação**: Tabela hash para estados (index, prev)
- **Benefício**: Reduz complexidade de O(2^n) para O(n²)

### 2. Early Termination
- **Objetivo**: Poda de ramos que não podem melhorar a solução
- **Implementação**: Verificar se remaining + current ≤ best
- **Benefício**: Reduz significativamente o número de chamadas recursivas

### 3. Formulação de Erickson
- **Objetivo**: Implementação direta da formulação teórica
- **Implementação**: LISbigger(prev, A[j..n]) com parâmetros explícitos
- **Benefício**: Clareza conceitual e facilita otimizações

## Análise Detalhada da Complexidade

### Relação de Recorrência

Para a formulação de Erickson:
```
T(n) = 2 × T(n-1) + O(1)
```

### Solução da Recorrência

**Método da Árvore de Recursão:**
```
Nível 0: 1 chamada
Nível 1: 2 chamadas
Nível 2: 4 chamadas
...
Nível n: 2^n chamadas
```

Total: Σ(2^i) para i de 0 a n = 2^(n+1) - 1 = O(2^n)

### Com Memoização

**Estados únicos:**
- index: 0 a n-1 (n valores)
- prev: valores únicos da sequência + -∞ (máximo n+1 valores)
- Total de estados: O(n²)

**Tempo por estado:** O(1)
**Complexidade total:** O(n²)

## Aplicações Práticas

### 1. Bioinformática
- **Análise de Sequências de DNA**: Identificar padrões evolutivos
- **Alinhamento de Sequências**: Encontrar subsequências conservadas
- **Análise de Proteínas**: Identificar domínios funcionais

### 2. Processamento de Sinais
- **Análise de Tendências**: Identificar padrões em séries temporais
- **Filtragem de Ruído**: Encontrar sinais consistentes
- **Compressão de Dados**: Identificar redundâncias

### 3. Machine Learning
- **Feature Selection**: Identificar características relevantes
- **Análise de Dependências**: Encontrar relações sequenciais
- **Clustering Temporal**: Agrupar sequências similares

### 4. Análise Financeira
- **Identificação de Tendências**: Encontrar padrões de mercado
- **Análise de Portfólio**: Otimizar seleção de ativos
- **Predição de Preços**: Identificar padrões históricos

### 5. Processamento de Texto
- **Análise de Sequências**: Identificar padrões em texto
- **Compressão de Texto**: Encontrar redundâncias
- **Análise de Linguagem**: Identificar estruturas gramaticais

## Insights Teóricos

### 1. Estrutura de Decisão Binária
- Cada elemento gera uma decisão binária (incluir ou não)
- Isso leva naturalmente à complexidade exponencial
- A estrutura é ideal para otimizações com memoização

### 2. Subproblemas Sobrepostos
- Muitos subproblemas são resolvidos múltiplas vezes
- Isso torna o problema ideal para memoização
- A memoização reduz drasticamente a complexidade

### 3. Base para Programação Dinâmica
- O backtracking é a base para soluções de DP
- A formulação recursiva é natural para DP
- A otimização com memoização é o primeiro passo para DP

### 4. Formulação de Erickson
- LISbigger(prev, A[j..n]) é intuitiva
- Facilita a implementação de otimizações
- Conecta diretamente com a teoria

### 5. Complexidade Exponencial
- Demonstra a necessidade de otimização
- Serve como exemplo de problema NP-difícil
- Ilustra a importância de algoritmos eficientes

## Limites Teóricos

### Complexidade
- **Sem otimização**: O(2^n) - exponencial
- **Com memoização**: O(n²) - polinomial
- **Com DP**: O(n log n) - usando binary search

### Espaço de Soluções
- **Número de subsequências**: O(2^n)
- **Número de LIS**: Pode ser exponencial
- **Comprimento máximo**: n (sequência estritamente crescente)

### Limites Práticos
- **Sem memoização**: Limitado a n ≈ 20-25
- **Com memoização**: Limitado a n ≈ 1000-10000
- **Com DP otimizado**: Limitado a n ≈ 100000

## Comparação com Outras Abordagens

### 1. Programação Dinâmica Clássica
- **Complexidade**: O(n²)
- **Vantagem**: Mais eficiente para n grande
- **Desvantagem**: Menos intuitivo

### 2. Algoritmo com Binary Search
- **Complexidade**: O(n log n)
- **Vantagem**: Mais eficiente
- **Desvantagem**: Mais complexo de implementar

### 3. Algoritmos Aproximados
- **Complexidade**: O(n)
- **Vantagem**: Muito rápido
- **Desvantagem**: Pode não encontrar a solução ótima

## Variações do Problema

### 1. LIS com Pesos
- **Problema**: Maximizar soma dos pesos dos elementos selecionados
- **Complexidade**: O(n²) com DP
- **Aplicação**: Seleção de investimentos

### 2. LIS com Restrições
- **Problema**: LIS com restrições adicionais (distância, valor, etc.)
- **Complexidade**: Depende das restrições
- **Aplicação**: Scheduling com restrições

### 3. LIS Aproximado
- **Problema**: Encontrar subsequência próxima da ideal
- **Complexidade**: O(n)
- **Aplicação**: Processamento de sinais ruidosos

### 4. LIS Múltiplo
- **Problema**: Encontrar LIS em múltiplas sequências
- **Complexidade**: O(k × n²) para k sequências
- **Aplicação**: Análise comparativa

### 5. LIS com Duplicatas
- **Problema**: Elementos podem ser repetidos
- **Complexidade**: O(n²)
- **Aplicação**: Análise de sequências com repetições

## Conclusão

O problema LIS com backtracking demonstra:

1. **Estrutura Natural**: A formulação recursiva é intuitiva
2. **Necessidade de Otimização**: Complexidade exponencial requer otimizações
3. **Base para DP**: Backtracking é a base para soluções eficientes
4. **Aplicabilidade**: Problema relevante em múltiplas áreas
5. **Insights Teóricos**: Ilustra conceitos fundamentais de algoritmos

A implementação backtracking serve como:
- **Exemplo Educacional**: Demonstra conceitos de recursão e backtracking
- **Base para Otimização**: Ponto de partida para memoização e DP
- **Ferramenta Prática**: Útil para problemas de tamanho moderado
- **Referência Teórica**: Conecta com a formulação de Erickson 