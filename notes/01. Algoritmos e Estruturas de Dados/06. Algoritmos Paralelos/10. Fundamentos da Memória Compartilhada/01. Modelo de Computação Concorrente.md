# 🔄 Modelo de Computação Concorrente

## 🎯 Visão Geral

**Computação concorrente com memória compartilhada** consiste em múltiplas threads sequenciais que comunicam através de objetos em memória compartilhada. Threads são **assíncronas** - executam em velocidades diferentes e podem parar por duração imprevisível.

## 🏗️ Fundamentos Teóricos

### 📜 Tese de Church-Turing
- **1930s**: Alan Turing e Alonzo Church estabelecem fundamentos
- **Tese**: Qualquer coisa computável pode ser computada por uma Máquina de Turing
- **Limitação**: Problemas indecidíveis (ex: halting problem) são universalmente insolúveis

### 🔄 Evolução dos Modelos
```
Finite-State Automata → Push-Down Automata → Turing Machines
```

**Analogia**: Como evolução de autômatos, modelos concorrentes progridem de simples para complexos.

## 🧵 Modelo de Threads Assíncronas

### ⚡ Características Principais
- **Velocidades diferentes**: Threads executam independentemente
- **Paradas imprevisíveis**: Microssegundos (cache miss) a segundos (scheduling)
- **Comunicação via objetos**: Métodos de objetos em memória compartilhada

### 🔧 Interface Básica
```java
public interface Register<T> {
    T read();
    void write(T v);
}
```

## 🛡️ Propriedades de Correção

### 📊 Tabela de Propriedades
| Propriedade | 🎯 Definição | ⚡ Implicação |
|-------------|--------------|---------------|
| **Segurança** | Condições de consistência | Comportamento correto |
| **Vivacidade** | Condições de progresso | Garantia de terminação |

### 🔒 Wait-Free vs Mutual Exclusion

#### ❌ Mutual Exclusion (Não Usado)
- **Problema**: Depende do scheduler do SO
- **Limitação**: Não examina blocos básicos da computação concorrente
- **Circularidade**: Registradores implementam mutual exclusion

#### ✅ Wait-Free (Preferido)
- **Definição**: Cada método termina em passos finitos
- **Vantagem**: Progresso independente do scheduler
- **Consequência**: Elimina qualquer mutual exclusion

## 🎨 Diagrama do Modelo

```mermaid
graph LR
    👤[Thread A] --> 🔧[Objeto Compartilhado]
    👤[Thread B] --> 🔧[Objeto Compartilhado]
    👤[Thread C] --> 🔧[Objeto Compartilhado]
    🔧 --> 📦[Memória Compartilhada]
    
    subgraph "Comunicação"
        📞[read()] --> 📤[Retorna valor]
        ✏️[write()] --> 📥[Modifica valor]
    end
```

## 🔍 Análise de Eficiência

### 📈 Abordagem Teórica
- **Foco**: Existência e funcionamento das construções
- **Prioridade**: Simplicidade sobre eficiência
- **Objetivo**: Entender princípios fundamentais

### ⚠️ Limitações Práticas
- **Timestamps ilimitados**: Crescem sem limite
- **Soluções limitadas**: Mais satisfatórias intelectualmente
- **Trade-off**: Simplicidade vs eficiência

## 🎯 Conclusão

O modelo de computação concorrente estabelece **fundamentos teóricos sólidos** para algoritmos distribuídos, priorizando **clareza conceitual** sobre otimizações práticas. A propriedade **wait-free** garante progresso independente, eliminando dependências do sistema operacional. 