# ğŸ”„ Modelo de ComputaÃ§Ã£o Concorrente

## ğŸ¯ VisÃ£o Geral

**ComputaÃ§Ã£o concorrente com memÃ³ria compartilhada** consiste em mÃºltiplas threads sequenciais que comunicam atravÃ©s de objetos em memÃ³ria compartilhada. Threads sÃ£o **assÃ­ncronas** - executam em velocidades diferentes e podem parar por duraÃ§Ã£o imprevisÃ­vel.

## ğŸ—ï¸ Fundamentos TeÃ³ricos

### ğŸ“œ Tese de Church-Turing
- **1930s**: Alan Turing e Alonzo Church estabelecem fundamentos
- **Tese**: Qualquer coisa computÃ¡vel pode ser computada por uma MÃ¡quina de Turing
- **LimitaÃ§Ã£o**: Problemas indecidÃ­veis (ex: halting problem) sÃ£o universalmente insolÃºveis

### ğŸ”„ EvoluÃ§Ã£o dos Modelos
```
Finite-State Automata â†’ Push-Down Automata â†’ Turing Machines
```

**Analogia**: Como evoluÃ§Ã£o de autÃ´matos, modelos concorrentes progridem de simples para complexos.

## ğŸ§µ Modelo de Threads AssÃ­ncronas

### âš¡ CaracterÃ­sticas Principais
- **Velocidades diferentes**: Threads executam independentemente
- **Paradas imprevisÃ­veis**: Microssegundos (cache miss) a segundos (scheduling)
- **ComunicaÃ§Ã£o via objetos**: MÃ©todos de objetos em memÃ³ria compartilhada

### ğŸ”§ Interface BÃ¡sica
```java
public interface Register<T> {
    T read();
    void write(T v);
}
```

## ğŸ›¡ï¸ Propriedades de CorreÃ§Ã£o

### ğŸ“Š Tabela de Propriedades
| Propriedade | ğŸ¯ DefiniÃ§Ã£o | âš¡ ImplicaÃ§Ã£o |
|-------------|--------------|---------------|
| **SeguranÃ§a** | CondiÃ§Ãµes de consistÃªncia | Comportamento correto |
| **Vivacidade** | CondiÃ§Ãµes de progresso | Garantia de terminaÃ§Ã£o |

### ğŸ”’ Wait-Free vs Mutual Exclusion

#### âŒ Mutual Exclusion (NÃ£o Usado)
- **Problema**: Depende do scheduler do SO
- **LimitaÃ§Ã£o**: NÃ£o examina blocos bÃ¡sicos da computaÃ§Ã£o concorrente
- **Circularidade**: Registradores implementam mutual exclusion

#### âœ… Wait-Free (Preferido)
- **DefiniÃ§Ã£o**: Cada mÃ©todo termina em passos finitos
- **Vantagem**: Progresso independente do scheduler
- **ConsequÃªncia**: Elimina qualquer mutual exclusion

## ğŸ¨ Diagrama do Modelo

```mermaid
graph LR
    ğŸ‘¤[Thread A] --> ğŸ”§[Objeto Compartilhado]
    ğŸ‘¤[Thread B] --> ğŸ”§[Objeto Compartilhado]
    ğŸ‘¤[Thread C] --> ğŸ”§[Objeto Compartilhado]
    ğŸ”§ --> ğŸ“¦[MemÃ³ria Compartilhada]
    
    subgraph "ComunicaÃ§Ã£o"
        ğŸ“[read()] --> ğŸ“¤[Retorna valor]
        âœï¸[write()] --> ğŸ“¥[Modifica valor]
    end
```

## ğŸ” AnÃ¡lise de EficiÃªncia

### ğŸ“ˆ Abordagem TeÃ³rica
- **Foco**: ExistÃªncia e funcionamento das construÃ§Ãµes
- **Prioridade**: Simplicidade sobre eficiÃªncia
- **Objetivo**: Entender princÃ­pios fundamentais

### âš ï¸ LimitaÃ§Ãµes PrÃ¡ticas
- **Timestamps ilimitados**: Crescem sem limite
- **SoluÃ§Ãµes limitadas**: Mais satisfatÃ³rias intelectualmente
- **Trade-off**: Simplicidade vs eficiÃªncia

## ğŸ¯ ConclusÃ£o

O modelo de computaÃ§Ã£o concorrente estabelece **fundamentos teÃ³ricos sÃ³lidos** para algoritmos distribuÃ­dos, priorizando **clareza conceitual** sobre otimizaÃ§Ãµes prÃ¡ticas. A propriedade **wait-free** garante progresso independente, eliminando dependÃªncias do sistema operacional. 