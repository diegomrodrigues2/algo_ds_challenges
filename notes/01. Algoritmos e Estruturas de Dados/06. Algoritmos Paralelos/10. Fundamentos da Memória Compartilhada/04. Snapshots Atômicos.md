# 📸 Snapshots Atômicos

## 🎯 Visão Geral

**Snapshots atômicos** permitem ler múltiplos registradores atomicamente, criando visão instantânea de array de registradores. Implementações **wait-free** garantem que threads não sejam atrasadas.

## 🔧 Interface e Especificação

### 📋 Interface Snapshot
```java
public interface Snapshot<T> {
    void update(T v);    // Escreve no registrador da thread
    T[] scan();          // Retorna snapshot atômico
}
```

### 🎯 Propriedade Chave
- **Linearizabilidade**: Equivalente a execução sequencial
- **Wait-free**: Cada método termina em passos finitos
- **Aplicações**: Backups, checkpoints, estados consistentes

## 🔄 Implementações

### 📊 4.3.1 Obstruction-Free Snapshot

#### 🎯 Estratégia Simples
- **Double collect**: Duas coletas consecutivas
- **Clean double collect**: Mesmos timestamps = estabilidade
- **Obstruction-free**: Completa se executar sozinho tempo suficiente

#### 🔧 Algoritmo
```java
public T[] scan() {
    StampedValue<T>[] oldCopy, newCopy;
    oldCopy = collect();
    while (true) {
        newCopy = collect();
        if (Arrays.equals(oldCopy, newCopy)) {
            return extractValues(newCopy);
        }
        oldCopy = newCopy;
    }
}
```

#### ⚠️ Limitação
- **Não wait-free**: Pode executar indefinidamente
- **Interrupções**: Update() pode interferir repetidamente

### ⚡ 4.3.2 Wait-Free Snapshot

#### 🎯 Insight Fundamental
- **Problema**: Thread A falha por thread B mover
- **Solução**: B ajuda A com snapshot próprio
- **Condição**: B moveu duas vezes durante scan de A

#### 🔧 StampedSnapshot
```java
public class StampedSnapshot<T> {
    public long stamp;
    public T value;
    public T[] snap;
}
```

#### 🎯 Mecanismo de Ajuda
- **Update()**: Chama scan() e anexa resultado
- **Scan()**: Detecta movimento duplo de threads
- **Ajuda**: Usa snapshot de thread que moveu duas vezes

## 🎨 Diagrama do Algoritmo Wait-Free

```mermaid
graph TD
    👤[Thread A] --> 🔍[scan()]
    🔍 --> 📊[collect()]
    📊 --> ❓{Clean double collect?}
    ❓ -->|Sim| ✅[Return snapshot]
    ❓ -->|Não| 🔄[Detect movement]
    🔄 --> 📈[Check moved[] array]
    📈 --> 🆘{Second movement?}
    🆘 -->|Sim| 🎁[Use helper's snapshot]
    🆘 -->|Não| 📝[Update moved[]]
    📝 --> 📊
    
    👤[Thread B] --> ✏️[update()]
    ✏️ --> 📸[scan()]
    📸 --> 📦[Append to value]
```

## 🔍 Análise de Correção

### 📊 Condições para Wait-Free

#### ✅ Condição 1: Progresso
- **Double collect**: Eventualmente encontra estabilidade
- **Movimento duplo**: Garante snapshot válido
- **Wait-free**: Cada scan() termina

#### ✅ Condição 2: Linearizabilidade
- **Clean double collect**: Snapshot válido
- **Helper snapshot**: Tomado durante intervalo do scan
- **Ordem**: Preserva ordem de operações

### 🎯 Argumento de Correção

#### 🔧 Cenário Crítico
```
Thread A: scan() inicia
Thread B: update() durante scan de A
Thread B: move duas vezes
Thread A: usa snapshot de B
```

#### ✅ Validação
- **B move duas vezes**: Garante update() completo durante scan()
- **Snapshot de B**: Linearizável dentro do intervalo de A
- **Resultado**: Comportamento equivalente a execução sequencial

## 📊 Comparação de Implementações

### 📋 Tabela de Propriedades
| Implementação | ⚡ Progresso | 🕐 Complexidade | 💾 Espaço | 📝 Característica |
|---------------|--------------|-----------------|-----------|-------------------|
| **Obstruction-free** | Obstruction-free | O(n) | O(n) | Simples |
| **Wait-free** | Wait-free | O(n²) | O(n²) | Complexa |

### 🔍 Trade-offs
- **Simplicidade vs Progresso**: Obstruction-free mais simples
- **Eficiência vs Garantias**: Wait-free mais robusto
- **Overhead**: Wait-free tem comunicação adicional

## 🎯 Aplicações Práticas

### 📸 Casos de Uso
- **Backups**: Estado consistente do sistema
- **Checkpoints**: Ponto de recuperação
- **Debugging**: Estado global em momento específico
- **Sincronização**: Coordenação entre threads

### 🔧 Implementações Reais
- **Sistemas distribuídos**: Estado global consistente
- **Bancos de dados**: Transações atômicas
- **Sistemas de arquivos**: Snapshots de diretórios

## ⚠️ Limitações e Desafios

### 🔍 Problemas Práticos
- **Overhead**: Comunicação entre threads
- **Complexidade**: Algoritmos não triviais
- **Escalabilidade**: O(n²) para wait-free

### 🎯 Desafios Teóricos
- **Timestamps**: Crescimento ilimitado
- **Sincronização**: Coordenação complexa
- **Correção**: Provas não triviais

## 🎯 Conclusão

Snapshots atômicos demonstram **poder da computação concorrente** para criar operações complexas a partir de primitivas simples. A **implementação wait-free** garante robustez, enquanto **mecanismos de ajuda** mostram elegância dos algoritmos distribuídos. 