# ğŸ“¸ Snapshots AtÃ´micos

## ğŸ¯ VisÃ£o Geral

**Snapshots atÃ´micos** permitem ler mÃºltiplos registradores atomicamente, criando visÃ£o instantÃ¢nea de array de registradores. ImplementaÃ§Ãµes **wait-free** garantem que threads nÃ£o sejam atrasadas.

## ğŸ”§ Interface e EspecificaÃ§Ã£o

### ğŸ“‹ Interface Snapshot
```java
public interface Snapshot<T> {
    void update(T v);    // Escreve no registrador da thread
    T[] scan();          // Retorna snapshot atÃ´mico
}
```

### ğŸ¯ Propriedade Chave
- **Linearizabilidade**: Equivalente a execuÃ§Ã£o sequencial
- **Wait-free**: Cada mÃ©todo termina em passos finitos
- **AplicaÃ§Ãµes**: Backups, checkpoints, estados consistentes

## ğŸ”„ ImplementaÃ§Ãµes

### ğŸ“Š 4.3.1 Obstruction-Free Snapshot

#### ğŸ¯ EstratÃ©gia Simples
- **Double collect**: Duas coletas consecutivas
- **Clean double collect**: Mesmos timestamps = estabilidade
- **Obstruction-free**: Completa se executar sozinho tempo suficiente

#### ğŸ”§ Algoritmo
```java
public T[] scan() {
    StampedValue<T>[] oldCopy, newCopy;
    oldCopy = collect();
    while (true) {
        newCopy = collect();
        if (Arrays.equals(oldCopy, newCopy)) {
            return extractValues(newCopy);
        }
        oldCopy = newCopy;
    }
}
```

#### âš ï¸ LimitaÃ§Ã£o
- **NÃ£o wait-free**: Pode executar indefinidamente
- **InterrupÃ§Ãµes**: Update() pode interferir repetidamente

### âš¡ 4.3.2 Wait-Free Snapshot

#### ğŸ¯ Insight Fundamental
- **Problema**: Thread A falha por thread B mover
- **SoluÃ§Ã£o**: B ajuda A com snapshot prÃ³prio
- **CondiÃ§Ã£o**: B moveu duas vezes durante scan de A

#### ğŸ”§ StampedSnapshot
```java
public class StampedSnapshot<T> {
    public long stamp;
    public T value;
    public T[] snap;
}
```

#### ğŸ¯ Mecanismo de Ajuda
- **Update()**: Chama scan() e anexa resultado
- **Scan()**: Detecta movimento duplo de threads
- **Ajuda**: Usa snapshot de thread que moveu duas vezes

## ğŸ¨ Diagrama do Algoritmo Wait-Free

```mermaid
graph TD
    ğŸ‘¤[Thread A] --> ğŸ”[scan()]
    ğŸ” --> ğŸ“Š[collect()]
    ğŸ“Š --> â“{Clean double collect?}
    â“ -->|Sim| âœ…[Return snapshot]
    â“ -->|NÃ£o| ğŸ”„[Detect movement]
    ğŸ”„ --> ğŸ“ˆ[Check moved[] array]
    ğŸ“ˆ --> ğŸ†˜{Second movement?}
    ğŸ†˜ -->|Sim| ğŸ[Use helper's snapshot]
    ğŸ†˜ -->|NÃ£o| ğŸ“[Update moved[]]
    ğŸ“ --> ğŸ“Š
    
    ğŸ‘¤[Thread B] --> âœï¸[update()]
    âœï¸ --> ğŸ“¸[scan()]
    ğŸ“¸ --> ğŸ“¦[Append to value]
```

## ğŸ” AnÃ¡lise de CorreÃ§Ã£o

### ğŸ“Š CondiÃ§Ãµes para Wait-Free

#### âœ… CondiÃ§Ã£o 1: Progresso
- **Double collect**: Eventualmente encontra estabilidade
- **Movimento duplo**: Garante snapshot vÃ¡lido
- **Wait-free**: Cada scan() termina

#### âœ… CondiÃ§Ã£o 2: Linearizabilidade
- **Clean double collect**: Snapshot vÃ¡lido
- **Helper snapshot**: Tomado durante intervalo do scan
- **Ordem**: Preserva ordem de operaÃ§Ãµes

### ğŸ¯ Argumento de CorreÃ§Ã£o

#### ğŸ”§ CenÃ¡rio CrÃ­tico
```
Thread A: scan() inicia
Thread B: update() durante scan de A
Thread B: move duas vezes
Thread A: usa snapshot de B
```

#### âœ… ValidaÃ§Ã£o
- **B move duas vezes**: Garante update() completo durante scan()
- **Snapshot de B**: LinearizÃ¡vel dentro do intervalo de A
- **Resultado**: Comportamento equivalente a execuÃ§Ã£o sequencial

## ğŸ“Š ComparaÃ§Ã£o de ImplementaÃ§Ãµes

### ğŸ“‹ Tabela de Propriedades
| ImplementaÃ§Ã£o | âš¡ Progresso | ğŸ• Complexidade | ğŸ’¾ EspaÃ§o | ğŸ“ CaracterÃ­stica |
|---------------|--------------|-----------------|-----------|-------------------|
| **Obstruction-free** | Obstruction-free | O(n) | O(n) | Simples |
| **Wait-free** | Wait-free | O(nÂ²) | O(nÂ²) | Complexa |

### ğŸ” Trade-offs
- **Simplicidade vs Progresso**: Obstruction-free mais simples
- **EficiÃªncia vs Garantias**: Wait-free mais robusto
- **Overhead**: Wait-free tem comunicaÃ§Ã£o adicional

## ğŸ¯ AplicaÃ§Ãµes PrÃ¡ticas

### ğŸ“¸ Casos de Uso
- **Backups**: Estado consistente do sistema
- **Checkpoints**: Ponto de recuperaÃ§Ã£o
- **Debugging**: Estado global em momento especÃ­fico
- **SincronizaÃ§Ã£o**: CoordenaÃ§Ã£o entre threads

### ğŸ”§ ImplementaÃ§Ãµes Reais
- **Sistemas distribuÃ­dos**: Estado global consistente
- **Bancos de dados**: TransaÃ§Ãµes atÃ´micas
- **Sistemas de arquivos**: Snapshots de diretÃ³rios

## âš ï¸ LimitaÃ§Ãµes e Desafios

### ğŸ” Problemas PrÃ¡ticos
- **Overhead**: ComunicaÃ§Ã£o entre threads
- **Complexidade**: Algoritmos nÃ£o triviais
- **Escalabilidade**: O(nÂ²) para wait-free

### ğŸ¯ Desafios TeÃ³ricos
- **Timestamps**: Crescimento ilimitado
- **SincronizaÃ§Ã£o**: CoordenaÃ§Ã£o complexa
- **CorreÃ§Ã£o**: Provas nÃ£o triviais

## ğŸ¯ ConclusÃ£o

Snapshots atÃ´micos demonstram **poder da computaÃ§Ã£o concorrente** para criar operaÃ§Ãµes complexas a partir de primitivas simples. A **implementaÃ§Ã£o wait-free** garante robustez, enquanto **mecanismos de ajuda** mostram elegÃ¢ncia dos algoritmos distribuÃ­dos. 