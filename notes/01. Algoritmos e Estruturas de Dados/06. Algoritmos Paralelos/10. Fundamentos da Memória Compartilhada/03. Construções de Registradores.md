# ğŸ”¨ ConstruÃ§Ãµes de Registradores

## ğŸ¯ VisÃ£o Geral

**ConstruÃ§Ãµes de registradores** mostram como implementar registradores mais poderosos a partir de mais fracos. A sequÃªncia demonstra **equivalÃªncia computacional** entre todos os tipos de registradores.

## ğŸ“Š SequÃªncia de ConstruÃ§Ãµes

### ğŸ”„ Hierarquia de ImplementaÃ§Ãµes
| Base | Implementado | SeÃ§Ã£o | ğŸ“ DescriÃ§Ã£o |
|------|--------------|-------|--------------|
| **SRSW safe** | MRSW safe | 4.2.1 | MÃºltiplos leitores |
| **MRSW Boolean safe** | MRMW Boolean regular | 4.2.2 | MÃºltiplos escritores |
| **MRSW Boolean regular** | MRSW regular | 4.2.3 | Valores M-Ã¡rios |
| **MRSW regular** | SRSW atomic | 4.2.4 | Atomicidade |
| **SRSW atomic** | MRSW atomic | 4.2.5 | MÃºltiplos leitores atÃ´micos |
| **MRSW atomic** | MRMW atomic | 4.2.6 | MÃºltiplos escritores atÃ´micos |

## ğŸ”§ ConstruÃ§Ãµes Principais

### ğŸ“‹ 4.2.1 MRSW Safe Registers

#### ğŸ¯ EstratÃ©gia
- **Array de SRSW**: Um registrador por thread
- **Escritor**: Escreve em todos os registradores
- **Leitor**: LÃª apenas seu registrador associado

#### âœ… CorreÃ§Ã£o
- **Sem sobreposiÃ§Ã£o**: Retorna Ãºltimo valor escrito
- **Com sobreposiÃ§Ã£o**: Componentes safe permitem qualquer valor

### ğŸ”„ 4.2.2 Regular Boolean MRSW

#### ğŸ¯ Insight Chave
- **Problema**: Boolean safe vs regular sÃ³ difere quando novo valor = antigo
- **SoluÃ§Ã£o**: Escrever apenas se valor for diferente

#### ğŸ”§ ImplementaÃ§Ã£o
```java
public void write(Boolean x) {
    if (x != last.get()) {
        last.set(x);
        s_value = x;
    }
}
```

#### âœ… CorreÃ§Ã£o
- **Valor igual**: Evita escrita, mantÃ©m valor correto
- **Valor diferente**: true/false, ambos corretos para Boolean

### ğŸ“Š 4.2.3 Regular M-Valued MRSW

#### ğŸ¯ EstratÃ©gia Inovadora
- **RepresentaÃ§Ã£o unÃ¡ria**: Array de M registradores Boolean
- **Valor i**: i-Ã©simo bit = true, todos menores = false
- **Leitura**: Primeiro true encontrado

#### ğŸ”§ Algoritmo
```java
// Escrita
for (int i = x; i >= 0; i--) {
    r_bit[i] = (i == x);
}

// Leitura
for (int i = 0; i < M; i++) {
    if (r_bit[i]) return i;
}
```

#### âœ… Invariante
- **Propriedade**: Se leitor estÃ¡ em r_bit[j], algum bit â‰¥ j Ã© true
- **Garantia**: Sempre retorna valor vÃ¡lido

### âš¡ 4.2.4 Atomic SRSW Register

#### ğŸ¯ Problema
- **Regular**: Satisfaz (4.1.1) e (4.1.2)
- **Atomic**: Precisa tambÃ©m (4.1.3)
- **SoluÃ§Ã£o**: Timestamps para ordenaÃ§Ã£o

#### ğŸ”§ StampedValue
```java
public class StampedValue<T> {
    public long stamp;
    public T value;
    
    public static StampedValue max(StampedValue x, StampedValue y) {
        return (x.stamp > y.stamp) ? x : y;
    }
}
```

#### âœ… CorreÃ§Ã£o
- **Timestamps crescentes**: OrdenaÃ§Ã£o total de writes
- **CondiÃ§Ã£o 4.1.3**: Leitura posterior nÃ£o vÃª valor anterior

### ğŸ‘¥ 4.2.5 Atomic MRSW Register

#### ğŸ¯ Problema
- **SRSW atÃ´mico**: Cada leitor tem seu registrador
- **MRSW atÃ´mico**: Todos leitores veem mesma ordem

#### ğŸ”§ EstratÃ©gia
- **Matriz nÃ—n**: a_table[i][j] para comunicaÃ§Ã£o entre threads i e j
- **Diagonal**: Registradores individuais
- **Linhas/Colunas**: ComunicaÃ§Ã£o entre leitores

#### âœ… Mecanismo de Ajuda
- **Leitor A**: LÃª a_table[A][A], depois verifica coluna A
- **ComunicaÃ§Ã£o**: Escreve em linha A para ajudar outros leitores
- **Resultado**: Leitores posteriores veem valores de anteriores

### ğŸ”„ 4.2.6 Atomic MRMW Register

#### ğŸ¯ Algoritmo de Timestamps
- **Array de MRSW**: Um registrador por thread
- **Escrita**: LÃª todos, escolhe timestamp maior
- **Leitura**: Retorna valor com maior timestamp

#### ğŸ”§ ResoluÃ§Ã£o de Empates
- **LexicogrÃ¡fico**: (timestamp, thread_id)
- **Ordem**: Timestamp menor ou igual com ID menor

## ğŸ¨ Diagrama da SequÃªncia

```mermaid
graph TD
    ğŸ”’[SRSW Safe] --> ğŸ‘¥[MRSW Safe]
    ğŸ‘¥ --> ğŸ”„[MRSW Boolean Regular]
    ğŸ”„ --> ğŸ“Š[MRSW Regular]
    ğŸ“Š --> âš¡[SRSW Atomic]
    âš¡ --> ğŸ‘¥[MRSW Atomic]
    ğŸ‘¥ --> ğŸ”„[MRMW Atomic]
    
    subgraph "TÃ©cnicas"
        ğŸ“‹[Array de SRSW]
        ğŸ”¢[RepresentaÃ§Ã£o UnÃ¡ria]
        â°[Timestamps]
        ğŸ†”[Matriz de ComunicaÃ§Ã£o]
    end
```

## ğŸ” AnÃ¡lise de Complexidade

### ğŸ“Š Tabela de Overhead
| ConstruÃ§Ã£o | ğŸ• Tempo | ğŸ’¾ EspaÃ§o | ğŸ“ TÃ©cnica |
|------------|---------|-----------|------------|
| **MRSW Safe** | O(n) | O(n) | Array de SRSW |
| **Boolean Regular** | O(1) | O(1) | Evitar escrita desnecessÃ¡ria |
| **M-valued Regular** | O(M) | O(M) | RepresentaÃ§Ã£o unÃ¡ria |
| **SRSW Atomic** | O(1) | O(1) | Timestamps |
| **MRSW Atomic** | O(nÂ²) | O(nÂ²) | Matriz de comunicaÃ§Ã£o |
| **MRMW Atomic** | O(n) | O(n) | Algoritmo de timestamps |

### âš ï¸ LimitaÃ§Ãµes PrÃ¡ticas
- **Timestamps ilimitados**: Crescem sem limite
- **Overhead significativo**: Especialmente MRSW atomic
- **IneficiÃªncia**: ConstruÃ§Ãµes teÃ³ricas nÃ£o otimizadas

## ğŸ¯ ImplicaÃ§Ãµes TeÃ³ricas

### âœ… EquivalÃªncia Computacional
- **Resultado**: Todos os tipos de registradores sÃ£o equivalentes
- **ConsequÃªncia**: Algoritmos funcionam em qualquer arquitetura
- **Flexibilidade**: IndependÃªncia de primitivas de hardware

### ğŸ”§ AplicaÃ§Ãµes PrÃ¡ticas
- **Portabilidade**: Algoritmos funcionam em sistemas fracos
- **Robustez**: TolerÃ¢ncia a falhas de sincronizaÃ§Ã£o
- **Teoria**: Base para algoritmos concorrentes

## ğŸ¯ ConclusÃ£o

As construÃ§Ãµes de registradores demonstram **poder surpreendente** de primitivas fracas. A **sequÃªncia hierÃ¡rquica** mostra como construir sistemas complexos a partir de blocos bÃ¡sicos, estabelecendo **fundamentos universais** para computaÃ§Ã£o concorrente. 