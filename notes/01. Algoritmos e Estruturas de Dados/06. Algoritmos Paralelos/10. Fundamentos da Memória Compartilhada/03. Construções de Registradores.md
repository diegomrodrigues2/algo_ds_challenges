# 🔨 Construções de Registradores

## 🎯 Visão Geral

**Construções de registradores** mostram como implementar registradores mais poderosos a partir de mais fracos. A sequência demonstra **equivalência computacional** entre todos os tipos de registradores.

## 📊 Sequência de Construções

### 🔄 Hierarquia de Implementações
| Base | Implementado | Seção | 📝 Descrição |
|------|--------------|-------|--------------|
| **SRSW safe** | MRSW safe | 4.2.1 | Múltiplos leitores |
| **MRSW Boolean safe** | MRMW Boolean regular | 4.2.2 | Múltiplos escritores |
| **MRSW Boolean regular** | MRSW regular | 4.2.3 | Valores M-ários |
| **MRSW regular** | SRSW atomic | 4.2.4 | Atomicidade |
| **SRSW atomic** | MRSW atomic | 4.2.5 | Múltiplos leitores atômicos |
| **MRSW atomic** | MRMW atomic | 4.2.6 | Múltiplos escritores atômicos |

## 🔧 Construções Principais

### 📋 4.2.1 MRSW Safe Registers

#### 🎯 Estratégia
- **Array de SRSW**: Um registrador por thread
- **Escritor**: Escreve em todos os registradores
- **Leitor**: Lê apenas seu registrador associado

#### ✅ Correção
- **Sem sobreposição**: Retorna último valor escrito
- **Com sobreposição**: Componentes safe permitem qualquer valor

### 🔄 4.2.2 Regular Boolean MRSW

#### 🎯 Insight Chave
- **Problema**: Boolean safe vs regular só difere quando novo valor = antigo
- **Solução**: Escrever apenas se valor for diferente

#### 🔧 Implementação
```java
public void write(Boolean x) {
    if (x != last.get()) {
        last.set(x);
        s_value = x;
    }
}
```

#### ✅ Correção
- **Valor igual**: Evita escrita, mantém valor correto
- **Valor diferente**: true/false, ambos corretos para Boolean

### 📊 4.2.3 Regular M-Valued MRSW

#### 🎯 Estratégia Inovadora
- **Representação unária**: Array de M registradores Boolean
- **Valor i**: i-ésimo bit = true, todos menores = false
- **Leitura**: Primeiro true encontrado

#### 🔧 Algoritmo
```java
// Escrita
for (int i = x; i >= 0; i--) {
    r_bit[i] = (i == x);
}

// Leitura
for (int i = 0; i < M; i++) {
    if (r_bit[i]) return i;
}
```

#### ✅ Invariante
- **Propriedade**: Se leitor está em r_bit[j], algum bit ≥ j é true
- **Garantia**: Sempre retorna valor válido

### ⚡ 4.2.4 Atomic SRSW Register

#### 🎯 Problema
- **Regular**: Satisfaz (4.1.1) e (4.1.2)
- **Atomic**: Precisa também (4.1.3)
- **Solução**: Timestamps para ordenação

#### 🔧 StampedValue
```java
public class StampedValue<T> {
    public long stamp;
    public T value;
    
    public static StampedValue max(StampedValue x, StampedValue y) {
        return (x.stamp > y.stamp) ? x : y;
    }
}
```

#### ✅ Correção
- **Timestamps crescentes**: Ordenação total de writes
- **Condição 4.1.3**: Leitura posterior não vê valor anterior

### 👥 4.2.5 Atomic MRSW Register

#### 🎯 Problema
- **SRSW atômico**: Cada leitor tem seu registrador
- **MRSW atômico**: Todos leitores veem mesma ordem

#### 🔧 Estratégia
- **Matriz n×n**: a_table[i][j] para comunicação entre threads i e j
- **Diagonal**: Registradores individuais
- **Linhas/Colunas**: Comunicação entre leitores

#### ✅ Mecanismo de Ajuda
- **Leitor A**: Lê a_table[A][A], depois verifica coluna A
- **Comunicação**: Escreve em linha A para ajudar outros leitores
- **Resultado**: Leitores posteriores veem valores de anteriores

### 🔄 4.2.6 Atomic MRMW Register

#### 🎯 Algoritmo de Timestamps
- **Array de MRSW**: Um registrador por thread
- **Escrita**: Lê todos, escolhe timestamp maior
- **Leitura**: Retorna valor com maior timestamp

#### 🔧 Resolução de Empates
- **Lexicográfico**: (timestamp, thread_id)
- **Ordem**: Timestamp menor ou igual com ID menor

## 🎨 Diagrama da Sequência

```mermaid
graph TD
    🔒[SRSW Safe] --> 👥[MRSW Safe]
    👥 --> 🔄[MRSW Boolean Regular]
    🔄 --> 📊[MRSW Regular]
    📊 --> ⚡[SRSW Atomic]
    ⚡ --> 👥[MRSW Atomic]
    👥 --> 🔄[MRMW Atomic]
    
    subgraph "Técnicas"
        📋[Array de SRSW]
        🔢[Representação Unária]
        ⏰[Timestamps]
        🆔[Matriz de Comunicação]
    end
```

## 🔍 Análise de Complexidade

### 📊 Tabela de Overhead
| Construção | 🕐 Tempo | 💾 Espaço | 📝 Técnica |
|------------|---------|-----------|------------|
| **MRSW Safe** | O(n) | O(n) | Array de SRSW |
| **Boolean Regular** | O(1) | O(1) | Evitar escrita desnecessária |
| **M-valued Regular** | O(M) | O(M) | Representação unária |
| **SRSW Atomic** | O(1) | O(1) | Timestamps |
| **MRSW Atomic** | O(n²) | O(n²) | Matriz de comunicação |
| **MRMW Atomic** | O(n) | O(n) | Algoritmo de timestamps |

### ⚠️ Limitações Práticas
- **Timestamps ilimitados**: Crescem sem limite
- **Overhead significativo**: Especialmente MRSW atomic
- **Ineficiência**: Construções teóricas não otimizadas

## 🎯 Implicações Teóricas

### ✅ Equivalência Computacional
- **Resultado**: Todos os tipos de registradores são equivalentes
- **Consequência**: Algoritmos funcionam em qualquer arquitetura
- **Flexibilidade**: Independência de primitivas de hardware

### 🔧 Aplicações Práticas
- **Portabilidade**: Algoritmos funcionam em sistemas fracos
- **Robustez**: Tolerância a falhas de sincronização
- **Teoria**: Base para algoritmos concorrentes

## 🎯 Conclusão

As construções de registradores demonstram **poder surpreendente** de primitivas fracas. A **sequência hierárquica** mostra como construir sistemas complexos a partir de blocos básicos, estabelecendo **fundamentos universais** para computação concorrente. 