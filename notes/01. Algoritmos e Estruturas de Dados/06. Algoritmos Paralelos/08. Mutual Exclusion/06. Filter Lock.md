# ğŸ”’ Filter Lock

## ğŸ¯ Conceito Central

**GeneralizaÃ§Ã£o do Peterson Lock** para n threads. Cria n-1 "salas de espera" (nÃ­veis) que threads devem atravessar antes de entrar na seÃ§Ã£o crÃ­tica. Cada nÃ­vel filtra uma thread.

## ğŸ¨ Diagrama de Funcionamento do Filter

```mermaid
sequenceDiagram
    participant ğŸ‘¤ Thread A
    participant ğŸ‘¤ Thread B
    participant ğŸ‘¤ Thread C
    participant ğŸšª NÃ­vel 1
    participant ğŸšª NÃ­vel 2
    participant ğŸ”’ SeÃ§Ã£o CrÃ­tica
    
    Note over ğŸ‘¤ Thread A, ğŸ”’ SeÃ§Ã£o CrÃ­tica: CenÃ¡rio: 3 threads
    ğŸ‘¤ Thread A->>ğŸšª NÃ­vel 1: level[A] = 1, victim[1] = A
    ğŸ‘¤ Thread B->>ğŸšª NÃ­vel 1: level[B] = 1, victim[1] = B
    ğŸ‘¤ Thread C->>ğŸšª NÃ­vel 1: level[C] = 1, victim[1] = C
    
    Note over ğŸšª NÃ­vel 1: Ãšltimo a escrever victim[1] "ganha"
    ğŸ‘¤ Thread A->>ğŸšª NÃ­vel 1: while (conflictExists(A,1)) {} // ğŸ”’ Presa
    ğŸ‘¤ Thread B->>ğŸšª NÃ­vel 1: while (conflictExists(B,1)) {} // ğŸ”’ Presa
    ğŸ‘¤ Thread C->>ğŸšª NÃ­vel 1: while (conflictExists(C,1)) {} // âœ… Passa
    
    ğŸ‘¤ Thread C->>ğŸšª NÃ­vel 2: level[C] = 2, victim[2] = C
    ğŸ‘¤ Thread C->>ğŸšª NÃ­vel 2: while (conflictExists(C,2)) {} // âœ… Passa
    ğŸ‘¤ Thread C->>ğŸ”’ SeÃ§Ã£o CrÃ­tica: Entra seÃ§Ã£o crÃ­tica
    ğŸ‘¤ Thread C->>ğŸ”’ SeÃ§Ã£o CrÃ­tica: Sai seÃ§Ã£o crÃ­tica
    ğŸ‘¤ Thread C->>ğŸ  NÃ­vel 0: level[C] = 0
    
    ğŸ‘¤ Thread A->>ğŸšª NÃ­vel 1: while (conflictExists(A,1)) {} // âœ… Passa
    ğŸ‘¤ Thread A->>ğŸšª NÃ­vel 2: level[A] = 2, victim[2] = A
    ğŸ‘¤ Thread A->>ğŸšª NÃ­vel 2: while (conflictExists(A,2)) {} // âœ… Passa
    ğŸ‘¤ Thread A->>ğŸ”’ SeÃ§Ã£o CrÃ­tica: Entra seÃ§Ã£o crÃ­tica
```

## ğŸ”§ ImplementaÃ§Ã£o

```java
class Filter {
    int[] level;
    int[] victim;
    
    void lock() {
        int me = ThreadID.get();
        
        for (int i = 1; i < n; i++) {
            level[me] = i;                    // Entra no nÃ­vel i
            victim[i] = me;                   // Torna-se vÃ­tima
            
            while (conflictExists(me, i)) {}  // Aguarda conflitos
        }
    }
    
    void unlock() {
        int me = ThreadID.get();
        level[me] = 0;                        // Volta ao nÃ­vel 0
    }
}
```

## ğŸ“Š Propriedades dos NÃ­veis

### ğŸ¯ Filtragem Progressiva
- **NÃ­vel 0**: n threads podem estar simultaneamente
- **NÃ­vel 1**: n-1 threads podem estar simultaneamente  
- **NÃ­vel 2**: n-2 threads podem estar simultaneamente
- **NÃ­vel n-1**: Apenas 1 thread (seÃ§Ã£o crÃ­tica)

### ğŸ”§ CondiÃ§Ã£o de Conflito
```java
boolean conflictExists(int me, int level) {
    for (int k = 0; k < n; k++) {
        if (k != me && level[k] >= level && victim[level] == me) {
            return true;  // Conflito existe
        }
    }
    return false;
}
```

## ğŸ¨ Diagrama de Conflitos por NÃ­vel

```mermaid
graph TD
    subgraph "Filtragem Progressiva"
        Level0("ğŸ  NÃ­vel 0")
        Level1("ğŸšª NÃ­vel 1")
        Level2("ğŸšª NÃ­vel 2")
        CS("ğŸ”’ SeÃ§Ã£o CrÃ­tica")
        
        ThreadA("ğŸ‘¤ Thread A")
        ThreadB("ğŸ‘¤ Thread B")
        ThreadC("ğŸ‘¤ Thread C")
        
        Level0 --> Level1
        Level1 --> Level2
        Level2 --> CS
        
        ThreadA -.-> Level1
        ThreadB -.-> Level1
        ThreadC -.-> Level1
        
        ThreadA -.-> Level2
        ThreadB -.-> Level2
        
        ThreadA -.-> CS
    end
    
    Note1["MÃ¡ximo n-1 threads<br/>no NÃ­vel 1"]
    Note2["MÃ¡ximo n-2 threads<br/>no NÃ­vel 2"]
    Note3["MÃ¡ximo 1 thread<br/>na SeÃ§Ã£o CrÃ­tica"]
    
    Level1 -.-> Note1
    Level2 -.-> Note2
    CS -.-> Note3
    
    linkStyle 0,1,2 stroke:#333,stroke-width:2px
    linkStyle 3,4,5,6,7,8 stroke:#999,stroke-width:1px,stroke-dasharray: 3 3
```

## âœ… Propriedades

| Propriedade | Status | Garantia |
|-------------|--------|----------|
| **Mutual Exclusion** | âœ… | Apenas 1 thread na seÃ§Ã£o crÃ­tica |
| **Deadlock-Freedom** | âœ… | Sistema nunca congela |
| **Starvation-Freedom** | âœ… | Toda thread eventualmente consegue |

## ğŸ“Š AnÃ¡lise TeÃ³rica

### Lema: No mÃ¡ximo n-j threads no nÃ­vel j

**InduÃ§Ã£o em j:**
- **Base (j=0)**: Trivial, n threads podem estar no nÃ­vel 0
- **InduÃ§Ã£o**: Se n-j+1 threads no nÃ­vel j-1, pelo menos 1 nÃ£o progride para j

### Prova de Mutual Exclusion

- SeÃ§Ã£o crÃ­tica = nÃ­vel n-1
- MÃ¡ximo 1 thread no nÃ­vel n-1
- **ConclusÃ£o**: Mutual exclusion garantida

### Prova de Starvation-Freedom

**InduÃ§Ã£o reversa nos nÃ­veis:**
- **Base**: NÃ­vel n-1 (apenas 1 thread)
- **InduÃ§Ã£o**: Se threads no nÃ­vel j+1 eventualmente entram, threads no nÃ­vel j tambÃ©m entram

## âš¡ Vantagens e Desvantagens

### âœ… Vantagens
- **Escalabilidade**: Funciona para qualquer n
- **CorreÃ§Ã£o**: Todas as propriedades desejadas
- **Simplicidade**: Conceito intuitivo de nÃ­veis

### âŒ Desvantagens
- **Overhead**: O(n) operaÃ§Ãµes por lock()
- **MemÃ³ria**: O(n) variÃ¡veis compartilhadas
- **LatÃªncia**: Threads passam por todos os nÃ­veis

## ğŸ”§ ImplementaÃ§Ã£o Python

```python
class FilterLock:
    def __init__(self, n):
        self.n = n
        self.level = [0] * n
        self.victim = [0] * n
        
    def lock(self):
        me = threading.current_thread().ident % self.n
        
        for i in range(1, self.n):
            self.level[me] = i
            self.victim[i] = me
            
            while self._conflict_exists(me, i):
                pass
                
    def unlock(self):
        me = threading.current_thread().ident % self.n
        self.level[me] = 0
        
    def _conflict_exists(self, me, level):
        for k in range(self.n):
            if k != me:
                if (self.level[k] >= level and 
                    self.victim[level] == me):
                    return True
        return False
```

## ğŸ“‹ ComparaÃ§Ã£o com Outros Algoritmos

| Aspecto | Peterson (2 threads) | Filter (n threads) |
|---------|----------------------|-------------------|
| **Mutual Exclusion** | âœ… | âœ… |
| **Deadlock-Freedom** | âœ… | âœ… |
| **Starvation-Freedom** | âœ… | âœ… |
| **Complexidade** | O(1) | O(n) |
| **MemÃ³ria** | O(1) | O(n) |
| **Escalabilidade** | âŒ 2 threads | âœ… n threads |

## ğŸ¯ AplicaÃ§Ãµes PrÃ¡ticas

- **Sistemas multiprocessador**: CoordenaÃ§Ã£o entre mÃºltiplas CPUs
- **SimulaÃ§Ãµes paralelas**: Controle de acesso a recursos compartilhados
- **Algoritmos distribuÃ­dos**: Base para algoritmos mais complexos
- **EducaÃ§Ã£o**: Demonstra conceitos fundamentais de concorrÃªncia 